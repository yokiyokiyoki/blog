---
title: js浮点数的坑
date: 2018-05-06 11:22:06
tags: javascript
---

## 浮点数在计算机中的表示

* 日常中，32767 这个数用科学计数法可以写成 3.2767\*10^4，3.2767 称为尾数(Mantissa)，4 就是指数(exponent)
* 浮点数在计算机中基于科学技术法来表示的，上面是我们日常用十进制来表示，计算机则是二进制，它的基数是 2 不是 10

## 一种浮点数格式

> 假设共有 14bits，5bits 表指数，8bits 表尾数，1bit 表示符号

* 17=>10001=1.0001*2^4 类比十进制的 1.7*10^5

### 尾数部分

* 因为尾数在十进制里面 0<尾数<10，在二进制里面就是 0<尾数<2，那么规定最高位只能是 1
* 因为尾数默认是 1，所以这个 1 就不用保存了，可以节省一位提高精度。所以尾数部分本来是 10001，这样就只用存储 0001，去掉了 1
* 需要注意的是，这里我们尾数的有效位数是 8 位，而 128.25=>10000000.01,需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 也才 9 个有效位，所以 128.25 只能舍去末尾的 1，表示为 10000000.0，其实跟 128 相等。所以浮点数不能做精确比较就是这样的

### 指数部分

* 但是指数部分是 4，换算成二进制也就是 100，如果以为是 100 就错了。
* 因为 0.25=>0.01=1\*10^-2,但是这样我们无法用指数表示负数。第一个符号位表示的是整个数的正负
* 现在广泛采用的是偏移的指数。规定一个偏移值，比如偏移值是 16，实际的指数要加上这个偏移值才可以，这样比 16 大的就是正指数，小的就是负指数。
* 要表示 0.25，如果偏移值 16，那么指数部分是 14，要表示 17 的指数部分，是 16+5=21,换成二进制就是 10101

| 1bit     |  5bits   |    8bits |
| -------- | :------: | -------: |
| sign bit | exponent | Mantissa |
| 符号位   |   指数   |     尾数 |
| 0        |  10101   | 00010000 |

## js 的浮点数标准

> js 的 number 遵循 IEEE 754 标准，使用 64 位固定长度表示，也就是 64 位 double 双精度浮点数（类似的有 float 32 位单精度标准）

* 大多数语言的小数默认都是遵循这个标准，所以 js 有的问题他们也有，包括 java，ruby，python
* 64bits 分为三部分
  * 符号 S：1bit，0 表示正数，1 表示负数
  * 指数 E：中间的 11 位存储指数
  * 尾数 M：最后的 52 位是尾数
* 因为指数 E 有 11 位，取值范围是 2^11=2048，也就是[0,2047]，所以约定的偏移值是 1023，[0,1023]是负数

### 浮点误差

#### 0.1 浮点误差（转成二进制无限循环）

* 0.1 转成二进制==0.0001100110011001100(1100 循环)=1.100110011001100(1100 循环)x2^-4，因为尾数舍去首位的 1，存的是后面的数，但是最多也只能存 52 位，然后再把有误差的只有 52 位尾数的，转成十进制，就变成了 0.100000000000000005551115123126
* 0.1+0.2=0.30000000000000004，那是因为把这两个转成二进制（这里就有误差了）后再运算，然后再转回十进制，正好是 0.30000000000000004

#### 为什么 x=0.1 就能得到 0.1
