<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017展望与2018总结]]></title>
    <url>%2Fblog%2F2018%2F02%2F25%2F2018%2F</url>
    <content type="text"><![CDATA[2017总结 工作上 官网方面：17年1月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。 产品方面：官网完成之后，雷达刚好升级2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。 项目方面：期间维护MIG系统，并且重构了整个DBA，能更快地迁移类似的模块。后来参与研发ipsos雷达。 学习上 关于vue：这一年，也算写了大量的vue代码，但vue封装了大量的js代码，屏蔽底层实现细节，所以我很清楚会写vue并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。 关于可视化方向：由于echarts底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的api，这是我所遗憾的地方。 关于构建工具：先是接触了gulp，但并不是了解得很清楚。而对于webpack这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。 关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于JavaScript的书，把《你不知道的JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。 关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。 总结 总的来说，这一年，觉得自己是”开眼看世界”的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。 2018展望 工作上 前端系统搭建:yoda系统搭建。 后端：学习一下java，希望能接触组内一些后端的项目，简单写些接口。 业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。 数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。 学习上 MVVM框架：希望能熟练使用react和angular，最终目标希望能自己造一个小巧的mvvm框架，当然造轮子的意义是为了自己学习。 Node开发：能编写一个express或者koa的中间件。熟练掌握CRUD应用。 构建工具：梳理前端构建工具，把常用的大概研究一遍。 Typescript：学习typescript，相信强类型一定会在将来被纳入ECMAScript的标准。 关于笔记：希望能把每天要做的事，坚持写在oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。 Java：目标是能写控制器里的代码。 关于可视化方向：学习d3.js和three.js。 关于读书：坚持读书，温故知新更为重要。 关于英语：英语实在是太重要了，每周背一篇新概念。 一周输出一篇博客 生活习惯 保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。 坚持八点起床，注意自己的仪容仪表。 总结 多增加了一个维度，同时希望自己能真正对得起工程师这个title。]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript装逼指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F03%2Fwrite-nbjs%2F</url>
    <content type="text"><![CDATA[1.javascript 代码错误处理方式 12345try &#123; something;&#125; catch (e) &#123; window.location.href = "http://stackoverflow.com/search?q=[js]+" + e.message;&#125; 2.如何优雅的取随机字符串 123456Math.random() .toString(16) .substring(2);Math.random() .toString(36) .substring(2); 3.如何优雅的取整 12345let a = ~~2.33; //2let b = 2.33 | 0; //2let c = 2.33 &gt;&gt; 0; //2 4.金钱数字取千分位的非正则优雅实现 12345678910111213//用reducefunction formatCash(str) &#123; return str .split("") .reverse() .reduce((prev, next, index) =&gt; &#123; return (index % 3 ? next : next + ",") + prev; &#125;);&#125;console.log(formatCash("1234567890")); // 1,234,567,890//toLocaleString(23333333).toLocaleString("en-US");("23,333,333"); 5.最短代码实现数组去重 12[...new Set([1, "1", 2, 1, 1, 3])];//[1,'1',2,3] 6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组 12Array(6).fill(8);//[8,8,8,8,8,8] 7.短路表达式 123456789101112131415var a = b &amp;&amp; 1;// 相当于if (b) &#123; a = 1;&#125; else &#123; a = b;&#125;var a = b || 1;// 相当于if (b) &#123; a = b;&#125; else &#123; a = 1;&#125; 8.颜色 rgb 和 hex 的相互转换 123456789101112131415function rgbToHex(r, g, b) &#123; return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);&#125;function hexToRgb(hex) &#123; var result = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex); return result ? &#123; r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) &#125; : null;&#125;alert(hexToRgb("#0033ff").g); // "51";]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画了解一下]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2Fstudy-animate%2F</url>
    <content type="text"><![CDATA[基本概念 帧：在动画过程中，每一幅静止画面即为一“帧” 帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz) 帧时长：即每一幅静止画面的停留时间，单位一般是毫秒 丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象 我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz） 帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。 实现方式 js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame css3:transition 和 animation html5:使用 html5 提供的绘图方式(canvas/svg/webgl) requestAnimationFrame 这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘 目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。 代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。 其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。 12345678910111213&lt;div id="demo" style="position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;"&gt;&lt;/div&gt;&lt;script&gt;var demo = document.getElementById('demo');function render()&#123; demo.style.left = parseInt(demo.style.left) + 1 + 'px'; //每一帧向右移动1px&#125;requestAnimationFrame(function()&#123; render(); //当超过300px后才停止 if(parseInt(demo.style.left) &lt;= 300) requestAnimationFrame(arguments.callee);&#125;);&lt;/script&gt; cancelAnimationFrame 用于取消重绘 12var requestID = requestAnimationFrame(repeatOften);cancelAnimationFrame(requestID); 使用 requestAnimationFrame 的优势如下 会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz） 在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量 所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果 transition css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变 1transition:property duration timing-function delay property 是过渡效果的 css 属性的名称，比如 height duration 规定完成过渡效果需要多少毫秒或者秒 timing-function 规定速度效果的曲线(linear/ease..) delay 规定过渡效果何时开始 animation 跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果 1animation:name duration timing-function delay iteration-count direction name 是需要绑定到选择器的 keyframe 名称 duration 规定完成动画所花费的时间，以秒或者毫秒算 timing-function 是动画的速度曲线(line/ease..) delay 规定在动画开始之前的延迟 iteration-count 规定动画应该播放的次数 animation-direction 规定是否应该轮流反向播放动画(normal/alternate) Canvas html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。 它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染 它具有如下特点 依赖分辨率，基于位图 不支持事件处理器 弱的文本渲染能力 能够以.pbg 或者.jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像 它具有如下特点 不依赖分辨率，基于矢量图 支持事件处理器 最适合带有大型渲染区域的应用程序，如谷歌地图 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快） 不适合游戏应用 svg 示例 1234567891011&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;rect x="50" y="20" rx="20" ry="20" width="150" height="150" style="fill:red;stroke:black;stroke-width:5;opacity:0.5" /&gt;&lt;/svg&gt; svg 代码以 svg 根元素开始。 width 和 height 设定 svg 文档的高度和宽度 version 指定所使用的 svg 版本 xmlns 定义 svg 命名空间 webgl webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。 webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成 常用的动画库 Ani.js–基于 css 动画的生命处理库 Dynamics.js–创建具有物理运动效果动画的 js 库 Animate.css–齐全的 css3 动画库 Three.js–快速搭建 webgl 项目]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2Fblog%2F2017%2F11%2F09%2Fstudy-processAndthread%2F</url>
    <content type="text"><![CDATA[进程(process)和线程（thread） 进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。 进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。 线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。 他们之间的关系是 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程） 资源分配给进程，同一进程的所有线程共享该进程的所有资源 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。 处理机分给线程，即真正在处理机上运行得是线程 线程是指进程内的一个执行单元，也是进程内的可调度实体 他们之间的区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。 生动形象 书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。 形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。]]></content>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂乱无章]]></title>
    <url>%2Fblog%2F2017%2F09%2F24%2Fthink%2F</url>
    <content type="text"><![CDATA[最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。 在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。 出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。 有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。 看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。 不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。 思绪很杂，文字也随之杂乱无章。]]></content>
      <tags>
        <tag>“life”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数]]></title>
    <url>%2Fblog%2F2017%2F05%2F23%2Fuse-generator%2F</url>
    <content type="text"><![CDATA[Generator函数 generator是生成器。generator可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。 generator函数的创建 ES6中用function*来创建生成器函数 当想要generator产生一个值之后暂停执行，需要使用到yield（生成）关键字，有点类似于return关键字（都可以返回一个值），只是yield返回值之后generator函数会暂停运行 12345function* ticketGenerate()&#123; //创建一个取号机 yield 1; yield 2; yield 3;&#125; yield*是委派至另一个生成器函数 12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i)&#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 generator函数的使用 ticketGenerate()不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象 当这个迭代器对象的next方法被调用时候，生成器函数的主体会执行到第一个yield表达式，该表达式定义了迭代器对象返回的值。 next()返回一个对象：{value:1,done:false}，value属性是产出的值，done属性是表示生成器是否已经产出了它最后的值。12const ticket=ticketGenerate() //返回一个生成器对象ticket.next() //&#123;value: 1, done: false&#125; 影响generator的状态 next()的另一个妙用是可以给它传递值，它会被视为generator中的yield语句的结果对待。 因此next是在generator运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为0。123456789101112function* ticketGenerator()&#123; for(var i=0;true;i++)&#123; var reset=yield i; if(reset) &#123;i=-1&#125; &#125;&#125;var takeANumber = ticketGenerator(); console.log(takeANumber.next().value); //0 console.log(takeANumber.next().value); //1 console.log(takeANumber.next().value); //2 console.log(takeANumber.next(true).value); //0 console.log(takeANumber.next().value); //1]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js里的异常]]></title>
    <url>%2Fblog%2F2017%2F05%2F18%2Fuse-CatchException%2F</url>
    <content type="text"><![CDATA[throw 用来抛出一个异常，throw expression throw 12 //抛出数值12的异常 throw ‘err’ //抛出字符串’err’的异常 throw {name:’异常的名字’,message:’异常的信息’,stack:’一般还有个函数栈’} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下throw new Error(‘123’) 也可以创建自定义错误12345function UserException(message)&#123; this.name='UserException'; this.message=message&#125;throw new UserException('用户消息错误') try..catch大法 配合throw能找出自己程序的异常 123456789101112function printValue(value)&#123; if(value==1)&#123; throw new Error('值是1错误') &#125;else&#123; console.log(value) &#125;&#125;try&#123; printValue(1)&#125;catch(e)&#123; console.log(e.message,e.name,e.stack)&#125;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用promise]]></title>
    <url>%2Fblog%2F2017%2F05%2F17%2Fuse-promise%2F</url>
    <content type="text"><![CDATA[Promise Promise作为ES6的特性，可以很好地创建异步工作流 Promise是构造函数 Promise只有三种状态（pending，resolve，reject），pending是刚创建Promise实例的状态，然后一旦转为resolve或者reject，就不可变更 创建Promise 以封装xhr为例子 1234567891011121314151617function getURL(url)&#123; return new Promise((resolve,reject)=&gt;&#123; //Promise构造函数接受一个函数，这个函数接受两个参数 let xhr = new XMLHttpRequest() xhr.open('GET',url,true) xhr.onload=function()&#123; if(xhr.status==200)&#123; resolve(JSON.parse(xhr.responseText)) //如果成功响应，那么把这个值填充到resolve &#125;else&#123; reject(new Error(xhr.statusText)) //把该错误对象填充到reject里面 &#125; &#125; xhr.onError=function()&#123; reject(new Error(xhr.statusText)) //把该错误对象填充到reject里面 &#125; xhr.send(null) &#125;)&#125; reject必须是接受一个错误对象实例，比如new Error(&#39;12&#39;)里面是什么类型的都可以 使用Promise 使用上面封装xhr的getURL的函数，该函数返回一个Promise实例 Promise的实例方法有两个：then和catch，这个两个方法都返回新的Promise对象 then有两个参数。then(onfilled,onrejected)，第一个是参数值resolve来填充，第二个是reject来填充 catch实则是then(undefined,onrejected)的别名，但是一般情况下都是用这个 then检测不了自身Promise对象onfilled出了异常，而catch是基于对上次的then产生的promise对象 1234567let url1='http://azu.github.io/promises-book/json/comment.json', url2='http://azu.github.io/promises-book/json/people.json'getURL(url1).then((val)=&gt;&#123; console.log(val) //这里是onfilled填充&#125;).catch(error=&gt;&#123; console.log(error) //这里是onrejected填充&#125;) Promise chain获取上次promise的返回值 由于Promise 链式调用的时候，每个Promise都是独立的。但是可以通过return值来传给下一个Promise，因为return了值是填充了当前Promise对象的resolve1promise.then(val=&gt;&#123;return val&#125;).then(val=&gt;&#123;console.log(val)&#125;) Promise静态方法 Promise.resolve(42) === new Promise((resolve,reject)=&gt;resolve(42)) ,是它的语法糖 Promise.reject(new Error(42)) === new Promise((resolve,reject)=&gt;reject(new Error(42))) 是它的语法糖 如果有多个Promise同时需要判断才能进行下一步，可以用Promise.all([promise1,promise2])。这个then方法返回的参数也是一个数组，跟promise1和promise2的顺序一样。需要注意的是，all是并行执行的。 Promise.race([promise1,promise2]) 则和数组的some方法很像，只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。 123456promise.all([getURL(url1),getURL(url2)]).then(function(result)&#123; console.log(result) //[getURL(url1)的结果，getURL(url2)的结果]&#125;)promise.race([getURL(url1),getURL(url2)]).then(function(value)&#123; console.log(value) //一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面&#125;)]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nvm]]></title>
    <url>%2Fblog%2F2017%2F03%2F10%2Fuse-nvm%2F</url>
    <content type="text"><![CDATA[Node Version Manager（node版本管理）使用nvm安装和管理node node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。用nvm下载了相应的node也会下载相应的npm进行管理 安装nvm我们可以从Github下载 默认安装路径是C:\Users\Administrator\AppData\Roaming\nvm，存放我们下载的各个版本的node 验证安装，打开控制台，输入nvm,看是否输出所有命令 命令 nvm list #查看本地所有node版本 nvm install 4.2.2 #安装 4.2.2 版本 nvm use 4.2.2 #切换至 4.2.2 版本 nvm uninstall 4.2.2 #卸载4.2.2 版本 镜像 nvm默认的下载地址是http://nodejs.org/dist/,这是国外的服务器，在国内下载速度很慢。 需要把下列代码复制到你nvm的安装路径下的setting.txt12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
