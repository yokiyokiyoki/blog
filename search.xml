<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我理解的前端进阶]]></title>
    <url>%2Fblog%2F2018%2F03%2F13%2Ffe-progress%2F</url>
    <content type="text"><![CDATA[简单介绍 前端是一个需要广度的职位，感觉如果多了解上下游各部门的相关技术会对工作有极大的帮助。单从比起技术来，眼界跟逻辑思维其实更重要。 从技术上来说，走出前端那一亩三分地，多接触自己不熟悉的技术。当回头看前端的时候往往会有一种豁然开朗的感觉。 现阶段感觉是要接触不同的技术，换种不一样的思维。因为之前也写过 php（用的是国人 tp 框架），初次接触了 mvc 的思想，后来为学校的公众号也写过后台，用的是 python（Django），然后公司现在用的 java 的 spring 那一套（在疯狂补 java 核心卷 I 中…），后端的路已经很成熟的，前端还在探索属于自己的方式。这样看来是豁然开朗了～ 萌新 -&gt; 页面重构 -&gt; 前端开发工程师 -&gt; 大前端 -&gt; 前端打杂 -&gt; 团队打杂 练级之路可以写出方便维护的代码 commonjs/cmd/amd(node/sea.js/require.js) es6 module(babel) webpack mvvm 解决 jq 意大利面条 使用 async/await，promise 可以写出不容易出错的代码 类型检查，不能相信传进来的参数(当然现在有 ts) try-catch 捕获错误 window.onerror 可以写出性能比较好的代码 大量 dom 操作的时候可以批量读，批量写，会用缓存 会使用递归分而治之，将大问题分解成相似的小问题 可以灵活使用工具 charles/whistle 替换本地文件，模拟数据，代理 host 会用 ps 切图，markman 测量工具 各种带语法提示的小插件 sourcemap 定位代码 知道怎么定位到问题 会有 chrome devtool 里面的 network/performance 等，断点调试 网络不通，ping 一下百度 常见问题跨域 jsonp（get） 服务器代理 安全问题 xss（不能信任用户的输入，过滤一下输入，转义带有脚本的标签） csrf（所有请求都需要带有 token） 性能问题 小文件，快展现 图片资源无损压缩（webp 了解一下） 服务端渲染 预加载 dns 预解析 web workers 进行大计算 知道浏览器的内部工作原理 关注新技术，并能快速化为己用 webaseembly 将 js 转为二进制的规范 小程序 pwa 有感而发于公司内部分享 ppt]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017展望与2018总结]]></title>
    <url>%2Fblog%2F2018%2F02%2F25%2F2018%2F</url>
    <content type="text"><![CDATA[2017 总结 工作上 官网方面：17 年 1 月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。 产品方面：官网完成之后，雷达刚好升级 2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。 项目方面：期间维护 MIG 系统，并且重构了整个 DBA，能更快地迁移类似的模块。后来参与研发 ipsos 雷达。 学习上 关于 vue：这一年，也算写了大量的 vue 代码，但 vue 封装了大量的 js 代码，屏蔽底层实现细节，所以我很清楚会写 vue 并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。 关于可视化方向：由于 echarts 底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的 api，这是我所遗憾的地方。 关于构建工具：先是接触了 gulp，但并不是了解得很清楚。而对于 webpack 这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。 关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于 JavaScript 的书，把《你不知道的 JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。 关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。 总结 总的来说，这一年，觉得自己是”开眼看世界”的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http 等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。 2018 展望 工作上 前端系统搭建:yoda 系统搭建。 后端：学习一下 java，希望能接触组内一些后端的项目，简单写些接口。 业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。 数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。 学习上 MVVM 框架：希望能熟练使用 react 和 angular，最终目标希望能自己造一个小巧的 mvvm 框架，当然造轮子的意义是为了自己学习。 Node 开发：能编写一个 express 或者 koa 的中间件。熟练掌握 CRUD 应用。 构建工具：梳理前端构建工具，把常用的大概研究一遍。 Typescript：学习 typescript，相信强类型一定会在将来被纳入 ECMAScript 的标准。 关于笔记：希望能把每天要做的事，坚持写在 oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。 Java：能熟练进行 web 开发。 关于可视化方向：学习 d3.js 和 three.js。 关于读书：坚持读书，温故知新更为重要。 关于英语：英语实在是太重要了，需要加强学习。 生活习惯 保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。 坚持八点起床，注意自己的仪容仪表。 总结 多增加了一个维度，同时希望自己能真正对得起工程师这个 title。]]></content>
      <tags>
        <tag>生活随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端错误收集]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2Ffe-error%2F</url>
    <content type="text"><![CDATA[为什么要进行前端的错误进行监控 现在网页的要求已经趋近于原生的应用，几乎都是有着大量交互的。面对各种用户，不同的浏览器等等出现的不同问题，有必要进行及时的监控，毕竟有些问题复现也是挺困难的。 捕获错误的方法 try..catch 之前说过，但是它只能在 try 的块里运行才可以捕捉错误，无法捕捉全局的错误事件 window.onerror 可以用来捕捉全局的错误,但是它无法捕捉异步错误，我们在 ajax 模块统一埋点 window.onerror123456window.onerror=function(message,url,linNo,columnNo,error)message:错误信息url:发生错误对应的脚本路径，比如是bundle.jslineNo:错误发生的行号colunmnNo:错误发生的列号error：具体的error对象，包含更加详细的错误调用堆栈信息 常见问题Script Error 现在我们一般都把资源放在 cdn 上，其他资源在本页面相当于跨域为什么会有这种设置，这是避免数据泄露到不安全的域中。如果我是银行页面，随便引入一个 js 资源，读取了账户密码，那可如何是好。 解决手段添加信任的域 客户端的 script 添加 crossorigin，他的作用就是告诉浏览器，要加载一个其他域的资源，并且信任他 服务端设置Acess-Control-Allow-Origin的响应头，可以直接设置为*，信任全部资源。cdn 资源应该全部加上 CORS 响应头。 如果我们使用 nginx 的话，可以像下面那样简单配置 12345location / &#123; root /Users/**; index index.html index.htm; add_header "Access-Control-Allow-Origin" "*";&#125; 代码压缩 现代 web 工程都会直接压缩 js 代码，所以线上一般都是只有几行代码但是我们有 sourcemap，可以定位到源代码的位置。但是线上是没有这个东西，我们可以通过sourcemap这个工具来将压缩后的代码生成 sourcemap 这里简单介绍一下生成 sourcemap 文件的方式 1uglifyjs --source-map 最终生成的map名称 --output 压缩文件名称 原文件名称 简单通过 soucemap 定位到源文件的真正行数 12345let sourceMap = require("source-map");let mapData = require("./test.json");let consumer = new sourceMap.SourceMapConsumer(mapData);let info = consumer.originalPositionFor(&#123; line: 1, column: 102 &#125;);console.log(info); //&#123; source: "test.js", line: 11, column: 6, name: "yoki" &#125; 推荐工具 由以上可以简单知道前端收集的原理了，但真正到线上肯定是不够的，这里有一些成熟的工具 sentry fundebug 分享一篇干货如何设计一个前端监控系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx简单使用]]></title>
    <url>%2Fblog%2F2018%2F01%2F20%2Fstudy-nginx2%2F</url>
    <content type="text"><![CDATA[前情提要：由于公司也是使用 nignx 解决前后端分离跨域问题，这里简单学习一下 设置简单的代理服务器设置一个代理服务器，它即是一个用来接收请求，并传递它们到代理服务器，取回响应并发送响应给客户端的服务器。 我们将会配置一个简单的代理服务器，它将用本地文件来提供图片请求，而把其他请求转发到代理服务器。这个例子中，这两个服务器都将被定义在一个 nginx 实例中。 首先，在上面配置的基础上再添加一个 server 指令块到 nginx 的配置文件中： 12345678server &#123; listen 8080; root /data/upl; location / &#123; &#125;&#125; 这是一个监听在 8080 端口（location 指令没有指定，默认会使用 80 端口），并且会映射所有请求到本地路径/data/upl 的简单服务器。创建此路径并在里面创建 index.html 文件。注意 root 指令要放在 server 上下文中。这种 root 指令将会在没有自己 root 指令的 location 指令块被选中来处理请求时应用。 下一步，使用上一节的服务器配置，并且修改其为一个代理服务器配置。在第一个 location 指令块，放置 proxy_pass 指令，将代理服务器的地址作为参数（包括代理服务器的协议，域名和端口号）。例子中，它是http://localhost:8080： 123456789server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location /images/ &#123; root /data; &#125;&#125; 第二个 location 指令块目前指定的是/images/前缀到/data/images 路径的映射，为了使其能根据文件后缀匹配相应图片的请求，我们修改之： 123location ~ \.(gif|jpg|png)$ &#123; root /data/images;&#125; 这里参数是一个匹配哪些以.gif，.jpg 或者.png 结尾的 URIs 的正则表达式。正则表达式前面需要放置~。相应的请求将会被影射到/data/images 路径。 当 nginx 选择一个 location 指令块去服务一个请求，它首先检查 location 指令指定的前缀（并记住此最长前缀），然后检查正则表达式。如果有一个正则表达式匹配了，nginx 选中此 location，否则，它将会应用前一个记住的 location。 最后，代理服务器的配置将会是这样： 123456789server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location ~ \.(gif|jpg|png)$ &#123; root /data/images; &#125;&#125; 此服务器将会过滤那些以.gif，.jpg 或.png 结尾的请求，并且影射它们到/data/images 目录。传递其他所有请求到上面配置的代理服务上去。 location = 开头表示精确匹配 ^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配 / 通用匹配, 如果没有其它匹配,任何请求都会匹配到 顺序 no 优先级： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 1234567891011121314151617181920#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理#这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;#第三个规则就是通用规则，用来转发动态请求到后端应用服务器#非静态文件请求就默认是动态请求，自己根据实际把握#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了location / &#123; proxy_pass http://tomcat:8080/&#125;]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx官方文档译文]]></title>
    <url>%2Fblog%2F2018%2F01%2F14%2Fstudy-nginx%2F</url>
    <content type="text"><![CDATA[简介nginx 有一个 master 进程和几个 worker 进程。master 进程的主要作用是读取和操作配置文件，同时维护 worker 进程。而真正处理请求的是 worker 进程。nginx 采用基于事件模型和系统依赖的机制最终将请求分配给 worker 进程。worker 进程的数量被定义在配置文件中，或者有可能被自动调整为 CPU 的核心数。 默认情况下，配置文件命名为 nginx.conf，放在/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx 目录下 启动，停止，reloading 配置运行可执行文件即可开启 nginx。一旦 nginx 开启之后，它可以使用可执行的-s 参数进行控制。下面是其语法： 1nginx -s signal 信号(signal)可以是下面的其中一个： stop —— 快速关闭 quit —— 优雅地关闭 reload —— 重新加载配置文件 reopen —— 重新打开日志文件 比如，等待所有 worker 进程服务完当前请求，然后关闭 nginx 进程： 1nginx -s quit//这条命令，必须由开启nginx的同一个用户执行。 如果改变了配置文件，除非是 nginx 重启，否则可以执行下面的命令进行应用新的配置： 1nginx -s reload 一旦 master 进程收到信号重新加载配置文件，它会检查新的配置文件的语法，并尝试应用配置。如果成功，master 进程开启新的 worker 进程，并且给旧的 worker 进程发送信息，请求它们关闭。否则，master 进程将会回滚修改并继续使用旧配置。 旧的 worker 进程，接受到命令关闭，将会停止接收新的请求，并继续服务完当前请求。自此之后，worker 进程将正式退出。 信号可以通过 unix 工具发送给 nginx 进程，例如 kill 命令。这种情况下，信号会直接发送给指定 pid 的进程。默认情况下，nginx 的 master 进程 ID 被写在/usr/local/nginx/logs 或/var/run 目录下的 nginx.pid 文件中。 比如，假如 master 进程的 ID 是 1628，那么发送 QUIT 信号给 nginx 会导致其优雅地退出： 1kill -s QUIT 1628 获取所有正在运行的 nginx 进程列表信息，可以执行： 1ps -ax | grep nginx 配置文件结构nginx 由模块组成。这些模块都被配置文件中的指令所控制。指令包括简单指令和指令块。一条简单的指令由名字和参数组成，参数由空格隔开，以分号（;）结束。一个指令块的结构和简单指令的一样，但是，它以额外的指令集合结束，指令集用大括弧（{和}）包围。 如果一个指令块里面有其他的指令块，那么它被称为一个上下文（例如，events，http，server 和 location）。 配置文件中，那些位于任何上下文之外的指令都认为是在 main 上下文中。events 和 http 指令位于 main 上下文，server 位于 http 上下文之中，location 位于 server 之中。 一行位于#后面的被认为是注释。 静态内容web 服务器一个重要的任务就是提供静态资源服务（例如图片等）。我们会实现一个例子，这个例子会根据请求，从不同的本地目录提供静态文件：/data/www（包含 html 文件），/data/images（包含图片）。这时候我们需要在 http 指令块里面创建一个 server 指令块，里面又包含两个 location 指令块。 首先，创建/data/www/index.html 文件，并放置一些图片于/data/images 目录下。 打开配置文件，默认的配置文件已经包含几个实例 server 指令块，大部分都被注释了。我们取消注释，并且开始一个新的 server 指令块： 12345http &#123; server &#123; &#125;&#125; 通常来说，配置文件会包含几个 server 指令块，它们由它们监听的端口号和服务器名称来区分。一旦 nginx 决定由哪一个 server 处理一个请求，它会把在请求 header 中的 URI 与在 location 指令块中定义的参数进行测试比较。 向 server 指令块添加 location 指令块： 123location / &#123; root /data/www;&#125; location 指令块指定了 URI”/”前缀。为了匹配请求，URI 将会被添加到 root 指令指定的路径，即是/data/www，实现了从路径到本地文件系统的转变。如果有多个匹配的 location 指令块，那么 nginx 将会选择那个拥有最长匹配前缀的。上面的 location 指令块提供了最短的前缀，所以如果其他所有 location 指令块都匹配失败，此指令块才生效。 下一步，添加第二个 location 指令块： 123location /images/ &#123; root /data;&#125; 它会匹配以/images/开头的请求（虽然 location /也同时匹配此请求，但是却是更短的前缀匹配）。 最后 server 指令块的配置应该是这样的： 123456789server &#123; location / &#123; root /data/www; &#125; location /images/ &#123; root /data; &#125;&#125; 这已经是一个服务器的配置文件了，这个服务器将会在本地机器http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404 error 的响应。URIs 不是以/images/开头的请求将会被影射到/data/www 路径。例如，请求http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。 为了应用新的配置文件，如果 nginx 还没有开启，开启即可；否则可以发送 reload 信号给 nginx 的 master 进程： 1nginx -s reload]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器怎么渲染]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2Fstudy-render%2F</url>
    <content type="text"><![CDATA[为什么要知道浏览器是怎么渲染的 作为一个前端工程师，了解浏览器的渲染过程，可以掌握优化的指导原则。 现在有那么多的优化方案，预编译，预加载，资源合并，按需加载等等都是针对浏览器渲染的优化。 关键渲染路径 关键渲染路径(Critical Rendering Path)是指与当前用户操作有关的内容 比如用户刚刚打开一个页面，首屏的显示就是当前用户操作的内容，具体就是浏览器收到 html/css/js 等资源并对其进行处理从而渲染出页面 了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径 为了保障首屏内容的最快速显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就要做资源的拆分，怎么拆分，这是按场景考虑的 浏览器渲染页面过程 1.dns 查询 2.tcp 连接 3.http 请求即响应 4.服务端响应 5.客户端渲染 客户端渲染 以下步骤不一定一次性顺序完成，如果 dom 或者 cssom 被修改，则以下过程需要重复执行，这样才能计算哪些像素在屏幕上需要重新渲染 1.处理 html 标记并构建 dom 树 2.处理 css 并构建 cssom 树 3.将 dom 树和 cssom 树合并成一个渲染树 4.根据渲染树来布局，以计算每个节点的几何信息 5.将各个节点绘制到屏幕上 阻塞渲染 现代浏览器是并行加载资源的。当 HTML 解析器(html parser)被脚本阻塞的时候，解析器虽然会停止构建 dom，但仍然会识别该脚本后面的资源，并进行预加载。 默认情况下，css 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直到 cssdom 构建完毕 js 不仅可以读取和修改 dom 属性，还可以读取和修改 cssom 属性 存在阻塞的 css 资源的时候，浏览器就会延迟 js 的执行和 dom 构建 当浏览器遇到一个 script 标记的时候，dom 构建将暂停，直到脚本完成执行 cssom 构建的时候，js 执行将暂停，直到 cssdom 就绪 所以 script 标签的位置很重要，实际使用的时候，可以遵循下面两个原则 css 优先：引入顺序上，css 资源先于 js 资源 js 应该尽量少影响 dom 的构建 CSS 渲染树(Render-Tree)的关键渲染路径中，要求同时具有 dom 和 cssom，之后才会构建渲染树。所以 html 和 css 都是被阻塞的资源。html 一定是需要的，那么可以从 css 上想办法。 精简 css 并尽快提供它，例如将多个 css 合并成一个，并进行压缩 JavaScript 实际工程，常常将 js 资源放到文档底部 defer 和 async 可以改变阻塞模式 defer defer 属性表示延迟执行引入的 js，这段 js 加载时候 html 也并未停止解析，这两个过程是并行的 整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。 123&lt;script src="app1.js" defer&gt;&lt;/script&gt;&lt;script src="app2.js" defer&gt;&lt;/script&gt;&lt;script src="app3.js" defer&gt;&lt;/script&gt; defer 不会改变 script 中代码的执行顺序，示例代码会按照 1，2，3 的顺序执行。 async123&lt;script src="app.js" async&gt;&lt;/script&gt;&lt;script src="ad.js" async&gt;&lt;/script&gt;&lt;script src="statistics.js" async&gt;&lt;/script&gt; async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 多个 async-script 的执行顺序是不确定的。所以 app.js 和 ad.js 和 statistics.js 不一定是顺序执行，谁先加载完谁先执行。]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript装逼指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F03%2Fwrite-nbjs%2F</url>
    <content type="text"><![CDATA[1.javascript 代码错误处理方式 12345try &#123; something;&#125; catch (e) &#123; window.location.href = "http://stackoverflow.com/search?q=[js]+" + e.message;&#125; 2.如何优雅的取随机字符串 123456Math.random() .toString(16) .substring(2);Math.random() .toString(36) .substring(2); 3.如何优雅的取整 12345let a = ~~2.33; //2let b = 2.33 | 0; //2let c = 2.33 &gt;&gt; 0; //2 4.金钱数字取千分位的非正则优雅实现 12345678910111213//用reducefunction formatCash(str) &#123; return str .split("") .reverse() .reduce((prev, next, index) =&gt; &#123; return (index % 3 ? next : next + ",") + prev; &#125;);&#125;console.log(formatCash("1234567890")); // 1,234,567,890//toLocaleString(23333333).toLocaleString("en-US");("23,333,333"); 5.最短代码实现数组去重 12[...new Set([1, "1", 2, 1, 1, 3])];//[1,'1',2,3] 6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组 12Array(6).fill(8);//[8,8,8,8,8,8] 7.短路表达式 123456789101112131415var a = b &amp;&amp; 1;// 相当于if (b) &#123; a = 1;&#125; else &#123; a = b;&#125;var a = b || 1;// 相当于if (b) &#123; a = b;&#125; else &#123; a = 1;&#125; 8.颜色 rgb 和 hex 的相互转换 123456789101112131415function rgbToHex(r, g, b) &#123; return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);&#125;function hexToRgb(hex) &#123; var result = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex); return result ? &#123; r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) &#125; : null;&#125;alert(hexToRgb("#0033ff").g); // "51";]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识vps]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2Fstudy-vps%2F</url>
    <content type="text"><![CDATA[vps 是什么 以下来自维基百科 虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分区成多个虚拟专享服务器的服务。 实现 VPS 的技术分为容器技术和虚拟机技术 。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。 VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。 vps 能做什么 可以进行科学上网，参见搭建 ss 服务器 vps 可以配置一个 ip 或者多个 ip。既然有了 ip 那么干的事情就多了。 同时想了解一下 linux 服务器或者部署自己的小作品，这个时候一个配置较低的 vps 就可以发挥作用了。比如托管静态页面，爬虫，起 node 服务等等。 一些 vps 推荐 vultr(我就是用这个的) 搬瓦工 hostmybytes linode]]></content>
  </entry>
  <entry>
    <title><![CDATA[动画了解一下]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2Fstudy-animate%2F</url>
    <content type="text"><![CDATA[基本概念 帧：在动画过程中，每一幅静止画面即为一“帧” 帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz) 帧时长：即每一幅静止画面的停留时间，单位一般是毫秒 丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象 我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz） 帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。 实现方式 js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame css3:transition 和 animation html5:使用 html5 提供的绘图方式(canvas/svg/webgl) requestAnimationFrame 这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘 目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。 代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。 其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。 12345678910111213&lt;div id="demo" style="position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;"&gt;&lt;/div&gt;&lt;script&gt;var demo = document.getElementById('demo');function render()&#123; demo.style.left = parseInt(demo.style.left) + 1 + 'px'; //每一帧向右移动1px&#125;requestAnimationFrame(function()&#123; render(); //当超过300px后才停止 if(parseInt(demo.style.left) &lt;= 300) requestAnimationFrame(arguments.callee);&#125;);&lt;/script&gt; cancelAnimationFrame 用于取消重绘 12var requestID = requestAnimationFrame(repeatOften);cancelAnimationFrame(requestID); 使用 requestAnimationFrame 的优势如下 会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz） 在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量 所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果 transition css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变 1transition:property duration timing-function delay property 是过渡效果的 css 属性的名称，比如 height duration 规定完成过渡效果需要多少毫秒或者秒 timing-function 规定速度效果的曲线(linear/ease..) delay 规定过渡效果何时开始 animation 跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果 1animation:name duration timing-function delay iteration-count direction name 是需要绑定到选择器的 keyframe 名称 duration 规定完成动画所花费的时间，以秒或者毫秒算 timing-function 是动画的速度曲线(line/ease..) delay 规定在动画开始之前的延迟 iteration-count 规定动画应该播放的次数 animation-direction 规定是否应该轮流反向播放动画(normal/alternate) Canvas html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。 它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染 它具有如下特点 依赖分辨率，基于位图 不支持事件处理器 弱的文本渲染能力 能够以.pbg 或者.jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像 它具有如下特点 不依赖分辨率，基于矢量图 支持事件处理器 最适合带有大型渲染区域的应用程序，如谷歌地图 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快） 不适合游戏应用 svg 示例 1234567891011&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;rect x="50" y="20" rx="20" ry="20" width="150" height="150" style="fill:red;stroke:black;stroke-width:5;opacity:0.5" /&gt;&lt;/svg&gt; svg 代码以 svg 根元素开始。 width 和 height 设定 svg 文档的高度和宽度 version 指定所使用的 svg 版本 xmlns 定义 svg 命名空间 webgl webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。 webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成 常用的动画库 Ani.js–基于 css 动画的生命处理库 Dynamics.js–创建具有物理运动效果动画的 js 库 Animate.css–齐全的 css3 动画库 Three.js–快速搭建 webgl 项目]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2Fblog%2F2017%2F11%2F09%2Fstudy-processAndthread%2F</url>
    <content type="text"><![CDATA[进程(process)和线程（thread） 进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。 进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。 线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。 他们之间的关系是 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程） 资源分配给进程，同一进程的所有线程共享该进程的所有资源 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。 处理机分给线程，即真正在处理机上运行得是线程 线程是指进程内的一个执行单元，也是进程内的可调度实体 他们之间的区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。 生动形象 书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。 形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。]]></content>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂乱无章]]></title>
    <url>%2Fblog%2F2017%2F09%2F24%2Fthink%2F</url>
    <content type="text"><![CDATA[最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。 在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。 出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。 有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。 看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。 不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。 思绪很杂，文字也随之杂乱无章。]]></content>
      <tags>
        <tag>生活随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数]]></title>
    <url>%2Fblog%2F2017%2F05%2F23%2Fuse-generator%2F</url>
    <content type="text"><![CDATA[Generator 函数 generator 是生成器。generator 可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。 generator 函数的创建 ES6 中用function*来创建生成器函数 当想要 generator 产生一个值之后暂停执行，需要使用到yield（生成）关键字，有点类似于 return 关键字（都可以返回一个值），只是 yield 返回值之后 generator 函数会暂停运行 123456function* ticketGenerate() &#123; //创建一个取号机 yield 1; yield 2; yield 3;&#125; yield*是委派至另一个生成器函数 12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i) &#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 generator 函数的使用 ticketGenerate()不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象 当这个迭代器对象的 next 方法被调用时候，生成器函数的主体会执行到第一个 yield 表达式，该表达式定义了迭代器对象返回的值。 next()返回一个对象：{value:1,done:false}，value 属性是产出的值，done 属性是表示生成器是否已经产出了它最后的值。 12const ticket = ticketGenerate(); //返回一个生成器对象ticket.next(); //&#123;value: 1, done: false&#125; 影响 generator 的状态 next()的另一个妙用是可以给它传递值，它会被视为 generator 中的 yield 语句的结果对待。 因此 next 是在 generator 运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为 0。 1234567891011121314function* ticketGenerator() &#123; for (var i = 0; true; i++) &#123; var reset = yield i; if (reset) &#123; i = -1; &#125; &#125;&#125;var takeANumber = ticketGenerator();console.log(takeANumber.next().value); //0console.log(takeANumber.next().value); //1console.log(takeANumber.next().value); //2console.log(takeANumber.next(true).value); //0console.log(takeANumber.next().value); //1]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js里的异常]]></title>
    <url>%2Fblog%2F2017%2F05%2F18%2Fuse-CatchException%2F</url>
    <content type="text"><![CDATA[throw 用来抛出一个异常，throw expression throw 12 //抛出数值 12 的异常 throw ‘err’ //抛出字符串’err’的异常 throw {name:’异常的名字’,message:’异常的信息’,stack:’一般还有个函数栈’} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下 throw new Error(‘123’) 也可以创建自定义错误 12345function UserException(message) &#123; this.name = "UserException"; this.message = message;&#125;throw new UserException("用户消息错误"); try..catch 大法 配合 throw 能找出自己程序的异常 123456789101112function printValue(value) &#123; if (value == 1) &#123; throw new Error("值是1错误"); &#125; else &#123; console.log(value); &#125;&#125;try &#123; printValue(1);&#125; catch (e) &#123; console.log(e.message, e.name, e.stack);&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用promise]]></title>
    <url>%2Fblog%2F2017%2F05%2F17%2Fuse-promise%2F</url>
    <content type="text"><![CDATA[Promise Promise 作为 ES6 的特性，可以很好地创建异步工作流 Promise 是构造函数 Promise 只有三种状态（pending，resolve，reject），pending 是刚创建 Promise 实例的状态，然后一旦转为 resolve 或者 reject，就不可变更 创建 Promise 以封装 xhr 为例子 123456789101112131415161718function getURL(url) &#123; return new Promise((resolve, reject) =&gt; &#123; //Promise构造函数接受一个函数，这个函数接受两个参数 let xhr = new XMLHttpRequest(); xhr.open("GET", url, true); xhr.onload = function() &#123; if (xhr.status == 200) &#123; resolve(JSON.parse(xhr.responseText)); //如果成功响应，那么把这个值填充到resolve &#125; else &#123; reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面 &#125; &#125;; xhr.onError = function() &#123; reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面 &#125;; xhr.send(null); &#125;);&#125; reject 必须是接受一个错误对象实例，比如new Error(&#39;12&#39;)里面是什么类型的都可以 使用 Promise 使用上面封装 xhr 的 getURL 的函数，该函数返回一个 Promise 实例 Promise 的实例方法有两个：then 和 catch，这个两个方法都返回新的 Promise 对象 then 有两个参数。then(onfilled,onrejected)，第一个是参数值 resolve 来填充，第二个是 reject 来填充 catch 实则是 then(undefined,onrejected)的别名，但是一般情况下都是用这个 then 检测不了自身 Promise 对象 onfilled 出了异常，而 catch 是基于对上次的 then 产生的 promise 对象 123456789let url1 = "http://azu.github.io/promises-book/json/comment.json", url2 = "http://azu.github.io/promises-book/json/people.json";getURL(url1) .then(val =&gt; &#123; console.log(val); //这里是onfilled填充 &#125;) .catch(error =&gt; &#123; console.log(error); //这里是onrejected填充 &#125;); Promise chain 获取上次 promise 的返回值 由于 Promise 链式调用的时候，每个 Promise 都是独立的。但是可以通过 return 值来传给下一个 Promise，因为 return 了值是填充了当前 Promise 对象的 resolve 1234567promise .then(val =&gt; &#123; return val; &#125;) .then(val =&gt; &#123; console.log(val); &#125;); Promise 静态方法 Promise.resolve(42) === new Promise((resolve,reject)=&gt;resolve(42)) ,是它的语法糖 Promise.reject(new Error(42)) === new Promise((resolve,reject)=&gt;reject(new Error(42))) 是它的语法糖 如果有多个 Promise 同时需要判断才能进行下一步，可以用 Promise.all([promise1,promise2])。这个 then 方法返回的参数也是一个数组，跟 promise1 和 promise2 的顺序一样。需要注意的是，all 是并行执行的。 Promise.race([promise1,promise2]) 则和数组的 some 方法很像，只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。 123456promise.all([getURL(url1), getURL(url2)]).then(function(result) &#123; console.log(result); //[getURL(url1)的结果，getURL(url2)的结果]&#125;);promise.race([getURL(url1), getURL(url2)]).then(function(value) &#123; console.log(value); //一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面&#125;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板字符串的替换]]></title>
    <url>%2Fblog%2F2017%2F05%2F11%2Fstudy-replace-template%2F</url>
    <content type="text"><![CDATA[简单介绍 看到 vue 模板里都是用包含变量，然后替换成变量，觉得比字符串拼接实在是好太多了 es6 的字符串模板用起来实在是舒服，所以简单用实现一下 1234// 首先 str.replace(regexp|substr, newSubStr|function) ，replace 可以传递一个函数str.replace(reg,function(match,key)=&gt;&#123;&#125;)//正则匹配&#123;&#123;内容&#125;&#125;，应该是/\&#123;\&#123;(.*?)\&#125;\&#125;/，用\转义&#123;和&#125;// /\&#123;\&#123;(.*?)\&#125;\&#125;/g; 正则表达 .*?是正则的固定搭配用法，就是表示非贪婪模式，尽可能匹配少的意思 .*则表示贪婪模式 123456789源字符串：aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc正则表达式一：&lt;div&gt;.*&lt;/div&gt;匹配结果一：&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;(从头部匹配到尾部，从第一个div到最后的那个&lt;/div&gt;)正则表达式二：&lt;div&gt;.*?&lt;/div&gt;匹配结果二：&lt;div&gt;test1&lt;/div&gt;（这里指的是一次匹配结果，不使用\/g，所以没包括&lt;div&gt;test2&lt;/div&gt;） 简单实现 所以有上面的简单铺垫，可以简单写出 12345678910function render(template, context) &#123; return template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g, (match, key) =&gt; &#123; console.log(match, key); //match是&#123;&#123;name &#125;&#125;，key是name return context[key.trim()]; &#125;);&#125;//可以使用trim去掉前后空格const template = "我是&#123;&#123;name &#125;&#125;，现在&#123;&#123;age &#125;&#125;岁";const context = &#123; name: "yoki", age: "20" &#125;;console.log(render(template, context));]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和防抖]]></title>
    <url>%2Fblog%2F2017%2F04%2F10%2FthrottleAndDebounce%2F</url>
    <content type="text"><![CDATA[节流（throttle） 函数节流是指一定时间内只跑一次函数，就像是技能 cd，你再怎么按它一段时间内只能触发一次。 主要思想就是设置一个守卫（flag），如果 setTimeout 已经执行过了就不会创建新的 setTimeout 123456789101112131415let scrollFun = function(time) &#123; let canRun = true; //初始化守卫变量 return function() &#123; if (canRun) &#123; canRun = false; setTimeout(() =&gt; &#123; console.log("throttle"); //3s后变量才为true，才可以继续执行if条件 canRun = true; &#125;, time); &#125; &#125;;&#125;;//3s执行一次window.scroll = scrollFun(3000); 适用于窗口 resize 防抖(debounce) 函数防抖呢，就是频繁触发后，一旦空闲下来才开始执行这个函数。就像公交车司机，如果有人陆续刷卡，司机一直停车等待，直到所有人上来了才回开车。 主要思想就是如果频繁触发，就取消上一个，重新创建一个规定时长的 setTimeout 123456789101112let debounce = function(time) &#123; let setTimeId = null; return function() &#123; //取消上一个的 clearTimeout(setTimeId); setTimeId = setTimeout(() =&gt; &#123; console.log("debounce"); &#125;, time); &#125;;&#125;;//直到没有输入后，3s后才执行$(el).input(dubounce(3000)); 适用于输入框输入持续监听等]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nvm]]></title>
    <url>%2Fblog%2F2017%2F03%2F10%2Fuse-nvm%2F</url>
    <content type="text"><![CDATA[Node Version Manager（node版本管理）使用nvm安装和管理node node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。用nvm下载了相应的node也会下载相应的npm进行管理 安装nvm我们可以从Github下载 默认安装路径是C:\Users\Administrator\AppData\Roaming\nvm，存放我们下载的各个版本的node 验证安装，打开控制台，输入nvm,看是否输出所有命令 命令 nvm list #查看本地所有node版本 nvm install 4.2.2 #安装 4.2.2 版本 nvm use 4.2.2 #切换至 4.2.2 版本 nvm uninstall 4.2.2 #卸载4.2.2 版本 镜像 nvm默认的下载地址是http://nodejs.org/dist/,这是国外的服务器，在国内下载速度很慢。 需要把下列代码复制到你nvm的安装路径下的setting.txt12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中常用git命令]]></title>
    <url>%2Fblog%2F2017%2F02%2F13%2Fstudy-git%2F</url>
    <content type="text"><![CDATA[基础命令 git clone 克隆仓库 git checkout 切换分支 git add 添加文件 git commit 提交改动 git push 推送本地分支到远端 git merge 把某个分支的代码合并到当前分支 git pull = git fetch + git merge 把远端分支更新到本地 git status 当前分支状态 我一般习惯配置别名 alias，比如 merge 变成 mg，这样少打几个字母 常用命令组合1.丢掉本地未提交改动 git checkout -f 2.丢掉本地已提交但未推送到远端的提交 git reset –hard origin/xxx 测试和发布 内部使用 gitlab master 主分支：用于外网线上发布，永远保持跟线上一致 develop 分支：用于发布测试环境 日常开发说明 详情参见git flow 日常开发从 master 拉一个分支 feature-xxx 分支到本地 要发布测试环境，直接 mg 到 develop，然后发布 要发布线上，直接 mg 到 master，然后发布 日常紧急 bug 修复，可拉一个 hotfix 分支]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[add(1)(2)(3)解题思路]]></title>
    <url>%2Fblog%2F2017%2F02%2F08%2Fadd%2F</url>
    <content type="text"><![CDATA[投机解法 当时第一眼看到这个题目的时候，第一反应就是函数里返回一个新的函数 一个不灵活的解决方案,不具备拓展性 12345678function add(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125;; &#125;;&#125;add(1)(2)(3)=6 正确解法 函数最终的和要保存一个闭包当中 123456789101112131415function add(a) &#123; //sum保存于闭包之中 let sum = a; let tmp = function(b) &#123; sum = +b; //返回自己方便日后调用 return tmp; &#125;; //如果到这里什么都不写，那么console.log(add(1)(2)(3))是add这个函数的定义 //console.log有些情况下会调用toString和valueOf方法，所以我们重写这个方法 tmp.valueOf = tmp.toString = function() &#123; return sum; &#125;; return tmp;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017%2F01%2F15%2FhelloWorld%2F</url>
    <content type="text"><![CDATA[在程序的世界里，开始的话就循例来一个 hello world 一级标题 在文字前面加上#表示标题 标题一共有六级（6 个#号）在#后面加上空格，才是标准的 md 语法 列表 在文字前面加上- 列表 1 列表 2 引用 在文字前面加上&gt; 图片与链接 插入链接与图片的语法的区别在于一个!号; 12&gt; 图片为：![](relative address);&gt; 链接为：[](); 粗体 两个**包含一段文本就是粗体 粗体 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 用三个` 把中间的代码包裹,在第一段点之后加语言名可以显示代码高亮 1console.log(12); 分割线 分割线的语法为三个-]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
