---
title: 浅谈前端缓存(二)
date: 2018-05-13 14:33:46
tags: 浏览器
---

## 缓存历史

### http1.0 时代

* 主要通过 Pragma 和 Expires 这两个字段来规范。现在仍然有些古老的客户端不支持 http1.1，所以这个两个头还在使用。

#### Expires 字段不准确

* 是服务器返回该请求结果缓存的到期时间，如果再次发出这个请求，客户端的时间小于 Expires 的值，直接使用缓存结果
* 但是客户端和服务器如果有一方的时间不准确，比如时区，比如客户故意调整系统时间，都会失效

### http1.1 时代

* 主要就是 Cache-Control 来控制了

## 强缓存

* 命中状态码是 200，后面会跟着 from cache。现在高版本的 Chrome 换成了 from disk cache（磁盘缓存）和 from memory cache（内存缓存）

### 内存缓存

* 快速读取：将编译解析后的文件，直接存入该进程的内存，占据该进程的一定内存资源，以方便下次运行的快速读取
* 时效性：一旦进程关闭，那么该进程的内存将会被清空

### 磁盘缓存

* 直接将缓存写入磁盘文件中，读取缓存需要对缓存存放的硬盘文件进行 I/0 操作，然后重新解析该缓存内容，读取复杂，内容比内存缓存慢。

## 只有 get 请求能被缓存，post 不可以

* get 方法是从指定的资源请求数据，post 是向指定资源提交要被处理的数据
* get 请求可以被缓存，只应当用于取回数据，请求长度有限制
* post 请求不会被缓存，对数据长度没有要求

## 用户操作与缓存的关系

* 当按 F5 进行刷新的时候，会忽略叼 Expires/Cache-control 的设置，会再次发送请求取服务器请求，而 Last-Modified/ETag 还是有效的。就是有可能命中协商缓存。
* 当按住 ctrl+f5 进行强制刷新的时候，所有缓存机制都将失效
* 其他一些操作比如，地址栏回车，前进后退都不会影响缓存字段

## 缓存命中率

* 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。

## 推荐阅读

[node 实践 http 缓存](https://github.com/renjie1996/Doger-FrontEnd-Blog/issues/2)
