<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《图解算法》08-动态规划]]></title>
    <url>%2Fblog%2F2018%2F06%2F01%2Fstudy-Dynamic-planning%2F</url>
    <content type="text"><![CDATA[背包问题 继续上面贪婪算法的背包问题场景 简单算法 尝试各种可能的组合，并找出价值最高的组合 3 件商品就会计算 8 个组合，4 件商品就会计算 16 个集合 这就是前面说到的集合覆盖问题，每增加一件商品，需要计算的都要翻倍 这种简单算法的运行时是 O（2 ~n）2 的 n 次方 所以一多，这种算法就行不通，之前就用了近似算法 动态规划 动态规划就是背包问题的最优解 动态规划的本质是先解决子问题，再逐步解决大问题 每个动态规划都从一个网格开始 每个子问题都是离散的，不相互依赖才可以 最长公共子串 单元格中的值通常就是你要优化的值。在前面背包问题中，单元格中的值就是你要优化的值。 每个单元格都是子问题 场景 用户输错了单词，本来想输 fish，但是输了 hish 假设与 hish 类似的词只有两个（实际上上千个），fish 和 vista，怎么确定是哪一个（哪个单词和它更像） hish 和 fish 都包含的最长公共子串是 ish，用网格来算 hish 和 vista 都包含的最长公共子串是 is，用网格来算 因为 fish 的最长公共子串是 3 个，因此用户应该是想输入它 最长公共子序列 与最长公共子串计算方式不一样 动态规划应用 git diff 比较文件差异 生物学家使用最长公共子序列来确定 dna 的相似性]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》07-贪婪算法]]></title>
    <url>%2Fblog%2F2018%2F05%2F31%2Fstudy-greedy%2F</url>
    <content type="text"><![CDATA[教室调度问题场景 假设有五节课，从早上九点开始，每节课上一个小时，上到 12 点 如何将尽可能多的课程安排在同一个教室 解法 看起来很难，实际上很简单 找出结束最早的课，它就是这个教室里面上的第一节课 接下来，必须选择第一节课后开始的课。同样我们选择结束最早的课 重复上述步骤 所以贪婪算法就是每一步都采取最优解，最终得到的就是全局最优解 但是贪婪算法并不总是完美的，请看背包问题 背包问题场景 假设你是个贪婪的小偷，背着可装 35 磅的背包，去商场偷东西 共三样，音响 300 美元 30 磅重，电脑 200 美元 20 磅重，吉他 150 美元 15 磅重 如果按照贪婪算法，那么第一步就装了个音响就不能继续了 NP 完全问题 需要计算所有的解，并从中选出最短的那个 还没有找到快速解决的方法，只能用近似算法 定义 以难解著称的问题 旅行商问题 集合覆盖 近似算法 因为旅行商问题，5 个城市就是 5 的阶乘，一旦城市数量多了，根本不可能快速解出来 于是有人就想到了近似算法 随便选择出发的城市，然后每次选择下次要去的城市的时候 都选择最近的那个 如何识别 NP 完全问题场景 你正在为篮球队挑选队员，需要优秀的后卫，高高的前锋。。。 手里有一个名单，其中每个球员都符合某些要求 从这些名单里选出来 这就是一个集合覆盖的问题 可以使用近似算法 找出符合要求最多的 重复上面，直到满了 关键 不能将问题分解成小问题的 涉及所有组合的 如果问题可以转换成集合覆盖或者旅行商问题 想想旅行商问题和广度优先搜索的最短路径，后面是从 a 点到 b 点的，前者是经由指定点的就是 NP 完全问题]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中的四种fc（格式上下文）]]></title>
    <url>%2Fblog%2F2018%2F05%2F28%2Fstudy-formatting-context%2F</url>
    <content type="text"><![CDATA[什么是 FC formatting context 的缩写，格式上下文 是 css2.1 的一个规范 是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 css2.1 定义了两个格式上下文 BFC（block） IFC（inline） css3 定义了两个格式上下文 GFC(grid) FFC(flex) 概念 block-level boxes:display 属性值为’block’，‘list-item’,‘table’会生成一个 block-level box，这样盒子会参与到 bfc（一种布局方式）中 containing block:在浏览器内，想要把一个元素画出来，至少要知道定位和尺寸。定位有三种，无论哪一种都要先找到所在的 containing block，相当于一个大箱子里面摆很多小盒子，小盒子怎么摆取决于大箱子 BFC 是一个独立的渲染区域，只有 block-level boxes 参与，规定了内部的 block-level box 如何布局，并且与这个区域外部毫不相干。 布局规则 内部的 box 会在垂直方向一个接着一个的放置 box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠 bfc 的区域不会与 float box 重叠（可以用来实现两栏布局） bfc 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 如何触发 根元素（body） float 属性不为 none position 为 abs 或者 fixed display 为 inline-block, table-cell, table-caption(表格相关的) 在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）著作权归作者所有。 overflow 不为 visible 推荐阅读 理解 BFC 的原理及其作用 深入理解 BFC 和 Margin Collapse 理解 css 中的 bfc IFC 内联格式化上下文 如何触发 元素满足 inline-level box 布局特点 与 BFC 的区别是，水平方向的 内部元素全是 inline-level 如果由一个子节点是 block-level，父节点就要生成 BFC，但是 inline 元素怎么放进 BFC（浏览器会生成匿名盒子来容纳这些 inline 元素） IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。 每一行的多个内联元素都会生成同一个 line-box（线框） 计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。 具体作用 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过设置父容器 text-align:center 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 推荐阅读 浅析 CSS 中的 BFC 和 IFC line box，inline box 及 vertical-align 分析]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》06-狄克斯特拉算法]]></title>
    <url>%2Fblog%2F2018%2F05%2F27%2Fstudy-DijKstra%2F</url>
    <content type="text"><![CDATA[为什么有狄克斯特拉算法 这里的时间，换句话，我们给边加上了权重 之前 BFS 求出了最短路径，那么如果我们给边加上了时间呢？ 发现最短路径并不是最快路径 步骤 找出最便宜的节点，就是说可以在最短时间内到达的节点（算法关键） 更新该节点的邻居的开销，检查是否有前往他们的更短路径，有就更新 重复这个过程，直到对图中的每个节点都这样做了 计算最终路径 术语 权重：狄克斯特拉算法用于每条边都有关联数字的图，这些关联数字叫做权重 带权重的图叫做加权图，计算最短路径用狄克斯特拉算法 不带权重的叫非加权图，计算最短路径用广度优先搜索 图还可能有环 负权边：权重是负的。 有负权边的情况，不能使用狄克斯特拉算法。因为该算法这样假设：对于处理过的节点，没有前往该节点的更短路径，只要在没有负权边才成立。应该使用贝尔曼-福德算法。 算法实现 需要三个散列表 图的散列表 节点的开销的散列表 存储父节点的散列表 需要一个数组，用于记录处理过的节点，不用多次处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344//如何表示加权图graph = &#123;&#125;;graph["start"] = &#123;&#125;;graph["start"]["a"] = 6;graph["start"]["b"] = 2;graph["a"] = &#123;&#125;;graph["a"]["fin"] = 1;graph["b"] = &#123;&#125;;graph["b"]["a"] = 3;graph["b"]["fin"] = 5;graph["fin"] = &#123;&#125;; //终点没有任何邻居//开销表costs = &#123;&#125;;costs["a"] = 6;costs["b"] = 2;costs["fin"] = infinity;//父节点表parents = &#123;&#125;;parents["a"] = "start";parents["b"] = "start";parents["fin"] = None;//算法node = find_lowest_cost_node(costs) //在未处理的节点中找出开销最小的节点while node is not None: //←------这个while循环在所有节点都被处理过后结束 cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): //←------遍历当前节点的所有邻居 new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: //←------如果经当前节点前往该邻居更近， costs[n] = new_cost //←------就更新该邻居的开销 parents[n] = node //←------同时将该邻居的父节点设置为当前节点 processed.append(node) //←------将当前节点标记为处理过 node = find_lowest_cost_node(costs) //←------找出接下来要处理的节点，并循环//找出最便宜的节点且没处理过的函数def find_lowest_cost_node(costs): lowest_cost = float("inf") lowest_cost_node = None for node in costs: // ←------遍历所有的节点 cost = costs[node] if cost &lt; lowest_cost and node not in processed: //←------如果当前节点的开销更低且未处理过， lowest_cost = cost // ←------就将其视为开销最低的节点 lowest_cost_node = node return lowest_cost_node]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》05-广度优先搜索]]></title>
    <url>%2Fblog%2F2018%2F05%2F27%2Fstudy-breadth-first-search%2F</url>
    <content type="text"><![CDATA[广度优先算法简单介绍 breadth-first search ，以下简称 BFS 能让你找出两样东西之间的最短距离，不过最短距离的含义有很多。 可以干什么（感受一下多强大） 编写国际跳棋 AI，计算最少走多少就可以获胜 根据人际关系网络找到关系最近的医生 可以回答两类问题 从节点 A 出发，有前往节点 B 的途径吗 从节点 a 出发，前往节点 b 的路径哪条最短 如何实现 创建一个队列，存储要检查的人 从队列弹出一个人，检查这个人是否是想要的，不是的话，把这个人的邻居加入队列 假设队列里面肯定有重复的，所以要将检查的人标记，不能检查两次，不然会出现无限循环的情况 可以专门存一个数组来记录检查过的人，或者用散列表存储，本质去掉重复 运行时间 在整个人际关系网找到正确的，意味着要沿每条边前行，因此运行时间为 O(n) 还使用了队列，其中要包含每个检查的人。将一个人添加到队列是 O（1），n 个人就是 O（n） 所以运行时间通常为 O(V+E)，v 为定点数，e 为边数 图简介 想象以下场景 从我家到公园，需要几步，求最短路径 一个欠钱的关系图，几个人之间的 组成 图是由节点和边组成。 图用于模拟不同的东西是如何相连的 有向图和无向图 有向图的关系是单向的，从节点 a 到节点 b，但不能反过来 无向图直接相连 查找算法 有序列表的查找算法有二分法，同样，图的查找算法是广度优先搜索 如何实现图 因为图是由多个节点组成，每个节点都与邻近节点相连，怎么表示我-&gt;bob 这样的关系，可以使用散列表，将 key 映射到 value 这里我们将节点映射到所有邻居 图不过是一系列的节点和边的组合 12345let graph = &#123;&#125;;graph["me"] = ["alice", "bob"];graph["bob"] = ["peggy"];graph["alice"] = ["peggy"];graph["peggy"] = []; 队列 和生活中的队列完全一样 是一个先进先出的数据结构 队列只支持两种操作：入队和出队 树 特殊的图，没有往后指的边，自上而下 假设正在规划一场婚礼，并有一个很大的图 其中充满着需要做的事，但是却不知道从何开始 可以使用拓扑排序来创建一个有序列表]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》04-散列表（hash table）]]></title>
    <url>%2Fblog%2F2018%2F05%2F27%2Fstudy-hashtable-01%2F</url>
    <content type="text"><![CDATA[为什么散列表会出现 场景：如果超市买东西结账的时候，售货员在一个本子里查找价格 如果是有序的（二分查找）还好，时间是 O（logn）,如果是无序（简单查找）的话，那就是 O（n） 如果直接有一个 O(1)的查找速度就好了 散列函数 将输入映射到数字 一致性：输入 apple 时得到的是 4，那么每次输入 apple 都必须是 4 不同性：不同的输入将得到不同的输出。如果输入 apple 和 yoki 都得到 4，那么这是一个不好的散列函数。 创造散列表 结合散列函数和数组 创建一个空数组 apple 输入到散列函数，输出 3，然后把 apple 的价格存储到数组索引 3 接着各个类推，知道存完数组 然后我们要找 apple 的价格，就把 apple 输入交给散列函数，得到 3 去数组里面找 散列表的经典应用 查找，防止重复，用于缓存 查找 被用于大海捞针的查找 这个就不用细说了，类似的有 dns 解析 防止重复 场景：负责一个投票站，每个人只能投一票，如何避免重复投票 有一个方法是：有人来投票，就将它记录在一个投票名单里面，然后接下来的人都遍历这个投票名单，如果有就不能投票，但是这样就列表会越来越长，就会变慢 另外一种就是散列表，超快 缓存 浏览器缓存的数据存储在散列表里面 如果访问 facebook 的页面，会先检查散列表中是否存储了该页面 如果不在缓存中，才去访问服务器，然后把数据放到缓存里，这样下次有人访问就可以直接命中缓存 冲突 事实上不可能不同的输入都能获得不同的值 假设有一个数组包含 26 个位置，而我们使用的散列函数非常简单，按照字母表顺序分配位置 apple 第一个，bear 第二个，接下来来了一个 banana，理应分到第二个，但是这个时候第二个位置已经是 bear 了 这个就叫冲突，解决冲突的办法有很多，简单的就是在这个冲突的位置存储一个链表，bear 末尾的指针指向 banana 所以散列函数很重要，好的散列函数将 key 均匀的映射到散列表的不同位置 如何避免冲突 较低的填装因子 散列表包含的元素数：位置总数就是填装因子 越小越好，满了只能调整长度，换一个更长的数组 一个不错的经验规则就是，一旦填装因子大于 0.7，那么就要调整散列表的长度 良好的散列函数 SHA 函数 散列表性能如何平均情况 查找，插入，删除都是 O（1）,常量时间 最糟糕情况 查找，插入，删除都是 O（1）,线性时间 为什么会有两种情况，这是因为有了冲突可能会靠链表解决，n 个长度的链表，最好情况下没有冲突，就常量时间]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈同构（CSR+SSR）]]></title>
    <url>%2Fblog%2F2018%2F05%2F24%2Fstudy-isomorphism%2F</url>
    <content type="text"><![CDATA[什么是同构 维基百科：在抽象代数中，同构（英语：isomorphism）指的是一个保持结构的双射。在更一般的范畴论语言中，同构指的是一个态射，且存在另一个态射，使得两者的复合是一个恒等态射。 一套代码既可以在服务端运行，又可以在客户端运行，这就是同构应用。 服务端直出（html 字符串）和客户端渲染的组合，能够充分结合两者的优势，并有效避免两者的不足。 具备单页应用和多页应用的所有优势 服务端渲染和客户端渲染 以下叫做 SSR 和 CSR ssr 的话，服务器返回的结构相对完整的 html 文件，通过解析 html 文件，浏览器就可以渲染出来页面。 csr 的话，拿到的只是包含 js 代码的 html 文件，在浏览器渲染页面之前，需要动态创建 html 标签 CSR 的优势 即单页应用的优势 局部刷新。不用每次都进行完整页面请求。 懒加载。如在页面初始的时候可以只加载可视区域内的数据，滚动后加载别的。 富交互。js 实现各种炫酷效果。 节约服务器成本。省电省钱。 SSR 的优势 不需要下载一堆 js 和 css 后才能看到首页（首屏性能） SEO 对于电量不给力的手机，减少在客户端的电量消耗 推荐阅读 “服务端渲染”吊打“客户端渲染”的那些事 为什么要同构 通过 Node 直出，将传统的三次 http 请求简化成一次 http 请求，降低首屏渲染时间 seo：服务端渲染对搜索引擎的爬取有着天然的优势 同构的实现策略 要实现同构，首先要正视一点，全盘同构是没有意义的。服务器端和浏览器端是两个不同的平台和环境，他们专注于解决各自的问题。 能够同构的代码，直接复用 无法同构的代码，封装成形式同构（具体看react 同构与性能极致优化） 比如 User-Agent 字符串，浏览器端直接 navigation.userAgent，服务器端需要 req.get(‘user-agent’) 同构并没有想象中那么美 框架可以尽力帮我们做好，比如 next.js 性能：把原来放在几百万浏览器端的工作拿过来给服务器端做，计算力大。个性化的缓存，可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。 不容忽视的服务器端和浏览器环境差异：dom api 在客户端找不到等 内存溢出：前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出没有充分考虑。 异步操作：前端可以做非常复杂的请求合并和延迟处理 推荐阅读 精读前后端渲染之争 同构 mvc 的前端实践 react 同构与性能极致优化 解密 Vue SSR]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能之用户可操作时间]]></title>
    <url>%2Fblog%2F2018%2F05%2F23%2Fstudy-screen-02%2F</url>
    <content type="text"><![CDATA[官方的一个浏览器从打开一个页面内部的一系列状态 用 performance.timing 的 api 就可以获取到各个阶段的 一般 start 和 end 间包括一个阶段 具体可以观察推荐阅读的那张图 navigationStart 到 responseEnd 之间是网络传输层面 domLoading 到 domComplete 是服务器传输回字节后浏览器的各种事件状态 domLoading domInteractive(dom tree 构建完成) domContentLoadedEventStart(触发的是 domContentLoaded 事件，这个很重要，network 都有体现) domContentLoadedEventEnd domComplete（资源全部加载完成，包括异步 js） loadEventStart（触发 load 事件） loadEventEnd 用户可操作时间 用户可以进行正常的事件输入交互操作 就是 domContentLoadedEventEnd-navigationStart 的时间 jq 的$()就是指 domContentLoaded 事件 一些知识点 document 到达 domInteractiv 状态的时候，代表 dom 树的构建完成 浏览器拿到文档首字节之后，也就是 responseEnd 之后。浏览器将 html 解析并构建成 DOM tree，同时将 css 解析成 cssom，这个过程是同步的 如果有 js 参与，因为同步的 js 可以改写文档在任何节点，所以 domtree 一旦碰上同步的 script 标签就会停止构建 js 能查询 dom 对象的可被计算的样式，cssom 构建完之后才轮到 js 执行，但是这是指 css 文件在 js 之前，如果 css 在 js 之后，不会阻塞 js 推荐阅读 前端性能的几个基础指标]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白屏和首屏时间]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fstudy-screen-01%2F</url>
    <content type="text"><![CDATA[白屏时间 浏览器开始显示内容的时间。从我们输入网址，到浏览器出现第一个字符的时间 chrome 有自己的 api，window.chrome.loadTimes().firstPaintTime * 1000 - window.performance.timing.navigationStart 如何计算通常认为浏览器开始渲染 body 标签或者解析完 head 标签的时刻就是页面白屏结束的时间 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;白屏&lt;/title&gt; &lt;script type="text/javascript"&gt; // 不兼容performance.timing 的浏览器，如IE8 window.pageStartTime = Date.now(); &lt;/script&gt; &lt;!-- 页面 CSS 资源 --&gt; &lt;link rel="stylesheet" href="common.css"&gt; &lt;link rel="stylesheet" href="page.css"&gt; &lt;script type="text/javascript"&gt; // 白屏时间结束点 window.firstPaint = Date.now(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页面内容 --&gt;&lt;/body&gt;&lt;/html&gt; 如果可以使用 performance api 的时候，白屏时间=firstPaint - performance.timing.navigationStart（浏览器打开网站开始） 如果不可以使用，比如 ie8，那么白屏时间= firstPaint - pageStartTime 首屏时间 指用户打开网站开始，到浏览器首屏内容渲染完成的时间。一般来说，5s 内优秀，10 之内可以接受，10s 以上不可以接受 怎么计算 1.首屏模块标签标记法，2.统计首屏内加载最慢的图片的时间，3.自定义首屏内容计算法 首屏模块标签标记法 适用于首屏内容不需要通过拉取数据才能生存以及页面不考虑图片等资源加载的情况。 但是现在大多数情况都需要通过接口拉数据才能完整显示，所以这个不太使用 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首屏&lt;/title&gt; &lt;script type="text/javascript"&gt; window.pageStartTime = Date.now(); &lt;/script&gt; &lt;link rel="stylesheet" href="common.css"&gt; &lt;link rel="stylesheet" href="page.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 首屏可见模块1 --&gt; &lt;div class="module-1"&gt;&lt;/div&gt; &lt;!-- 首屏可见模块2 --&gt; &lt;div class="module-2"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; window.firstScreen = Date.now(); &lt;/script&gt; &lt;!-- 首屏不可见模块3 --&gt; &lt;div class="module-3"&gt;&lt;/div&gt; &lt;!-- 首屏不可见模块4 --&gt; &lt;div class="module-4"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 统计首屏内图片完成加载的时间 通常首屏内容加载最慢的就是图片资源，因此我们会把首屏内加载最慢的图片的时间当作首屏时间 遍历首屏内所有图片标签，并且监听所有图片标签的 onload 事件，最终遍历图片标签的加载时间的最大值，然后用这个最大值减去 navigationStart 自定义模块内容计算法 由于统计图片加载时间比较复杂，通常会自定义模块内容，来简化 忽略图片等资源加载情况，只考虑页面主要 dom 只考虑首屏的主要模块，而不是严格意义首屏线上的所有内容 推荐阅读 7 天打造前端性能监控系统]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/2的学习]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fstudy-http2%2F</url>
    <content type="text"><![CDATA[HTTP/1.0 的通信 每完成一次请求和响应，TCP 连接就会断开。 HTTP/1.1 的通信 TCP 连接有 RTT（Round Trip Time，就是往返时延的），每次请求一个资源就要有一次 RTT，用户可是等不得这种慢节奏的响应。 到了 1.1，tcp 可以持久连接了，请求同域名下的 n 个资源，可以节约(n-1)*rtt 的时间 http 管道技术虽然实现了客户端向服务器并行发送多个请求，但是 1.1 有严格的串行返回机制（前一个响应没有完成，下一个响应就不能返回），如果第一个响应时间很长，那么后面的响应处理完了也没法发送，只能被缓存起来，占用服务器内存。 SPDY 谷歌推出的传输协议，最终演变成 HTTP/2 HTTP/2.0 二进制分帧层，多向请求与响应，优先级与依赖性，首部压缩，服务器推送 二进制分帧层 tcp 连接在客户端和服务器间建立了一条运输的通道，可以双向通信 当一端要向另一端发送消息的时候，把这个拆成几部分（帧），然后通过发起一个流来对这些帧进行发送，最后在另一端将同一个流的帧组合 就好比搬家，先把桌子拆成零件，再通过几次的搬运，到了新家，再把桌子重新拼装起来 多向请求与响应（多路复用） 一端发送消息会先对消息进行拆分，与此同时，也会给同一个消息拆分出来的帧带上一个编号（stream ID），这样另一端接受这些帧后就可以根据编号进行组合 优先级和依赖性 流可以有一个优先级属性 首部压缩 在客户端和服务器各自维护一个首部表，表中用索引代表首部名，上一次发送，两端都会记住已发送哪些首部，下一次传输只用传输差异的数据，相同的数据直接用索引表示即可。 服务器推送 服务器可以对一个客户端请求发送多个响应，也就是说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源 由上可得 http/2 通过二进制分帧和多路复用机制，有效解决了 1.x 下请求/响应延迟的问题 新的首部压缩技术使得 1.x 首部信息臃肿的问题得到解决 优先级和依赖性与服务器推送使得我们可以更有效地利用好这个单一的 tcp 连接 推荐阅读 http/2 安利篇(一) http/2 优化篇(二) 谷歌的 http2 学习篇]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP学习（二）]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fstudy-tcpip-02%2F</url>
    <content type="text"><![CDATA[TCP 和 IP 协议IP（Internet Protocol 网际协议） 是计算机用来相互识别的通信的一种机制，每台计算机都有一个 ip 来识别在 internet 上的位置 ip 协议仅仅是允许计算机相互发消息，但是它并不检查消息是否以发送的次序到达而且没有损坏 为了提供消息校验功能，直接在 IP 协议上设置 TCP TCP（Transmission Control Protocol 传输控制协议） 保证数据包以正确序列到达，并且尝试确认数据包的内容没有改变 tcp 在 ip 地址之上引端口，允许计算机通过网络提供各种服务 用于从应用程序到网络的数据传输控制，而 ip 负责计算机间的通信 HTTP 工作过程 一次 HTTP 操作称作一个事务 地址解析 从地址分解出协议名，主机名，端口 需要 DNS 解析域名，得到主机的 ip 地址 封装 HTTP 请求数据包 封装成 TCP 包，建立 TCP 连接（三次握手） 在 http 工作之前，首先要通过网络与服务器建立连接，该连接通过 tcp 完成 http 是比 tcp 更高层次的应用层协议，更具规则，只有低层次协议建立之后，才能进行更高层协议的连接 发送 http 请求 服务器响应 服务器关闭 TCP 连接 如果加入了长连接（keep-alive），tcp 连接仍然保持打开状态，减少建立新连接所需的时间，还节约了带宽 HTTPS 的 TLS/SSL TLS 全称是 transport layer security（安全传输层协议） 主要作用 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全 对网站服务器进行真实身份认证 依赖的基本算法 主要是三类 散列函数验证信息的完整性 对称加密算法采用协商好的秘钥对数据加密 非对称加密实现身份认证和密钥协商 推荐阅读 HTTP 和 HTTPS 详解]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP学习（一）]]></title>
    <url>%2Fblog%2F2018%2F05%2F21%2Fstudy-tcpip-01%2F</url>
    <content type="text"><![CDATA[TCP/IP 概念层模型 对比的是 OSI 七层模型 应用层（http） 传输层（tcp） 网络层（ip） 链路层(以太网) 数据包 网络中传输的数据包由两部分组成，一个是协议所要用到的首部，另一部分是上一层传过来的数据。 首部，明确标明了协议应该如何读取数据，就像协议的脸。 传输层协议 具有代表性的两个，分别是 tcp 和 udp TCP 面向连接的，可靠的协议。 为提供可靠性传输，提供顺序控制和重发控制。 UDP 不具有可靠性的数据报协议 实时性要求高 端口号 一台计算机上可以同时运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序。 数据链路层，指的是 mac 地址，用于识别统一链路中不同的计算机。 网络层，指的是 ip 地址，用于识别 tcp/ip 网络中互联的主机和路由器 传输层，指的是端口号，用于识别同一计算机中进行通信的不同应用程序。被称为程序地址。 端口号的确定标准既定的端口号 每个应用程序都有其指定的端口号，但不是说随意使用任何一个端口号。例如 http，ftp 所使用的端口号就是固定的，这些叫知名端口号。 知名端口号分布在 0-1023 此外还有一些端口号被正式注册，他们分布在 1024-49151 之间，可用于任何通信用途 时序分配法 服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号 客户端应用程序全权交由操作系统设置 TCP 的三次握手 建立连接 第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。 第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RCVD 状态。 第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。 TCP 的四次挥手 中断连接端可以是客户端，也可以是服务器端。 第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。 第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。 第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。 推荐阅读 tcp/ip 协议篇二]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webp压缩图片（一）]]></title>
    <url>%2Fblog%2F2018%2F05%2F17%2Fstudy-webp-01%2F</url>
    <content type="text"><![CDATA[什么是 webp 提供了有损压缩和无损压缩的图片格式 谷歌推出的一种图片格式 webp 的目标 减少文件大小，但达到和 jpeg 格式相同的图片品质，希望减少图片在网络上的发送时间。 webp 的 MIME 类型 image/webp 推荐阅读 webp 适配]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈浏览器跨域（二）之最终方案]]></title>
    <url>%2Fblog%2F2018%2F05%2F16%2Fstudy-domain-02%2F</url>
    <content type="text"><![CDATA[单向跨域（一般用来获取数据） 上面是两个页面之间的交互，现在是单方面向外面聊天的 JSONP JSON With Padding 原理是 html 的 script 标签可以加载并执行其他域的 js 文件。 一般 query 是 callback，当然是其他也是，只不过现在和服务端约定好了，服务队会获取到 req.query.callback 这样 1234567891011121314&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt;//服务器&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt;//服务器会返回domething(['a','b','c'])给浏览器，就可以直接执行了 优点是兼容性好，并且在请求完毕后可以通过调用 callback 的方法回传结果 缺点是支持 get 请求，传输的数据长度有限制 缺点是错误处理机制不完善，没办法进行错误处理 更主要的缺点是安全问题，如果被不信任的服务使用的时候会很危险，比如，callback 参数恶意添加标签（如 script，造成 xss 漏洞） websocket 协议 是一种通信协议，使用 ws://和 wss（加密）:// 这个协议不实行同源策略，只要服务器支持，就可以 通过 CORS 跨域 Cross-Origin Resource Sharing 跨域资源共享 规定了浏览器应该如何与服务器如何通过，背后的思想是使用自定义的 http 头部让浏览器和服务器沟通，从而决定请求或者响应是成功还是失败 浏览器不能低于 IE10 对于开发者来说 CORS 通信和同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨域，就会自动添加一些附加的头部信息，有时还会多处一次附加的请求，但是用户不会有感觉 实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信 1234567891011//相对路径是本源&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("POST", "/damonare",true); xhr.send();&lt;/script&gt;//绝对路径，跨域，无感&lt;script type="text/javascript"&gt; var xhr = new XMLHttpRequest(); xhr.open("￼GET", "http://segmentfault.com/u/trigkit4/",true); xhr.send();&lt;/script&gt; 两种请求 cors 分为两类，简单请求和非简单请求 简单请求满足下面三个条件，就属于简单请求 请求方法是 get，post，head (Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain 中的一种 不会使用自定义请求头（类似于 X-Modified 这种） 基本流程简单 请求的话，浏览器直接发出 CORS 请求。具体就是浏览器发现这次请求是简单请求，就主动在头信息之中，增加一个 origin 字段 1234567891011121314151617181920212223//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.example //该请求来自于 http://foo.exmaple。//以上是浏览器发送请求HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61Access-Control-Allow-Origin: * //这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml//以上是服务器返回信息给浏览器 服务器返回的与 CORS 有关的字段 一般都是以 Access-Control 开头 Access-Control-Allow-Origin 接受域名的请求，必须的 Access-Control-Allow-Credentials 可选，表示允不允许发送 cookie。如果需要发送，浏览器的 ajax 请求要打开 withCredentials 属性（xhr.withCredentials = true;） Access-Control-Expose-Headers 可选。因为 cors 请求，xhr 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想要拿到其他字段，只能在服务器里面指定，比如 getResponseHeader(‘FooBar’)可以返回 FooBar 字段 非简单请求 非简单请求是对服务器有特殊要求的请求，比如请求方法是 put 和 delete，或者 content-type 是 application/json 会在正式通信之前，增加一次 http 查询请求，称为预检请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错 预检请求的方法是 options，表示这个请求是询问的 浏览器发出的预请求 1234567891011121314//浏览器var url = "http://api.alice.com/cors";var xhr = new XMLHttpRequest();xhr.open("PUT", url, true);xhr.setRequestHeader("X-Custom-Header", "value");xhr.send();//http头OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUT//（必须的）告知请求是什么方法Access-Control-Request-Headers: X-Custom-Header//发送额外的头部信息，以逗号分割Host: api.alice.comAccept-Language: en-USConnection: keep-alive 服务器的回应,在检查 origin，method 和 headers 字段后 12345678910111213HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.com//（关键）Access-Control-Allow-Methods: GET, POST, PUT//必须，返回的是所有支持方法，而不但是浏览器请求的那个方法，这样是避免多次预检请求Access-Control-Allow-Headers: X-Custom-Header//如果浏览器有，则这个字段也是必须的Access-Control-Max-Age: 1728000 //本次预检请求的有效期，单位是秒，允许缓存该条回应多少秒。在此期间，不用发出另一条预检请求。Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 一旦服务器通过了预检请求，以后每次浏览器的请求都跟简单请求一样 优点：CORS 的优点：CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端跨域（一）]]></title>
    <url>%2Fblog%2F2018%2F05%2F16%2Fstudy-domain-01%2F</url>
    <content type="text"><![CDATA[什么是跨域 因为有浏览器同源策略限制，当前域名的 js 只能读取同域下的窗口属性 跨域不仅仅是指跨域名。 只要协议，域名，端口有任意不同，都被当作不同的域。 解决跨域问题主域相同的跨域 如果主域相同，比如 a.com 和 b.a.com，那么可以在 b.a.com 设置 1document.domain = "a.com"; 完全不同源的跨域（两个页面之间的通信）window.name 跨域 window 对象有个属性 name，在一个窗口的生命周期内，窗口载入的所有页面都是共享一个 window.name，每个页面对于 window.name 都有读写的权限 window.name 是持久存在一个窗口载入过的所有页面中的。 window.name 的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改当然就不会变化） 可以支持非常长的 name 值（2mb） window.postMessage html 为了解决这个问题，引入了一个全新的 api，跨文档通信 API，它为 window 对象新增了 postMessage 的方法 允许跨窗口通信，不论这个两个窗口是否同源 123//父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法。let popup = window.open("http://bbb.com", "title");popup.postMessage("Hello World!", "http://bbb.com"); postMessage 的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源（origin），也可以设置为‘*’，表示向所有窗口发送 父窗口和子窗口都可以通过 message 事件，监听对方的消息。message 事件的事件对象 event，有三个属性 event.source:发送消息的窗口 event.origin:消息发向的网址 event.data:消息内容 123456789101112131415var onmessage = function(event) &#123; var data = event.data; //消息 var origin = event.origin; //消息来源地址 var source = event.source; //源Window对象 if (origin == "http://www.aaa.com") &#123; console.log(data); //hello world! &#125; source.postMessage("Nice to see you!", "*");&#125;;if (typeof window.addEventListener != "undefined") &#123; window.addEventListener("message", onmessage, false);&#125; else if (typeof window.attachEvent != "undefined") &#123; //ie window.attachEvent("onmessage", onmessage);&#125;]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密传输之加盐]]></title>
    <url>%2Fblog%2F2018%2F05%2F13%2Fstudy-https-03%2F</url>
    <content type="text"><![CDATA[加盐提高安全性 盐：一个随机的字符串，往明文密码和一个随机的字符串拼接在一起 为了应对黑客们用彩虹表破解密码，我们可以先往明文密码加盐，然后再对加盐之后的密码用哈希算法加密。由于盐在密码校验的时候还要用到，因此通常盐和密码的哈希值是存储在一起的。 采用加盐的哈希算法对密码加密，要确保要往每个密码里添加随机的唯一的盐，而不是让所有密码共享一样的盐。 虽然加盐的算法能有效应对彩虹表的破解法，但它的安全级别并不高，因为计算哈希值耗时极短，黑客仍然可以用穷举法来破解，只是增加了一些耗时。 用 BCrypt 或者 PBKDF2 增加破解的难度为了应对暴力破解法，我们需要非常耗时的而不是非常高效的哈希算法。BCrypt 和 PBKDF2 算法应运而生。 这两个算法最大的特点是我们可以通过参数设置重复计算的次数，重复计算的次数越多耗时越长。如果计算一个哈希值需要耗时 1 秒甚至更多，那么黑客们采用暴利法破解密码将几乎不再可能。破解一个 6 位纯数字密码需要耗时 11.5 天，更不要说高安全级别的密码了。 摘自如何加密传输和存储用户密码]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密传输之HTTPS]]></title>
    <url>%2Fblog%2F2018%2F05%2F13%2Fstudy-https-02%2F</url>
    <content type="text"><![CDATA[http 和 https常规的 http 请求，所有信息明文传播，只要中间人在链路中的任意阶段进行劫持，就会带来三大风险： 窃听风险：第三方可以获取通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份参与通信 https 可以解决这些问题 https http+TLS，TLS 是传输层加密协议，前身是 SSL 协议（1999 年应用广泛，然后标准化，改名就是 TLS，所以同一个东西的不同阶段） SSL/TLS 协议是为了解决 http 的三大风险而设计的，希望达到： 内容加密：所有信息不再明文传播，都是加密的，第三方无法窃听 数据完整性：防止内容被第三方冒充或者篡改。具有校验机制，一旦被篡改，通信双方会立刻发现。 身份认证：配备身份证书，防止身份被冒充。即使被 DNS 劫持到了第三方站点，也会提醒用户有可能被劫持。 DNS 劫持 又叫域名劫持 是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名 深入理解 http 请求，dns 劫持与解析dns 劫持和 http 劫持的区别 https 流程 客户端发起 https 请求 服务端的配置 一般需要向权威机构申请一个证书（也可以自己制作，这个会在之后的中间人攻击中讲到，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会提示），证书会生成 RSA 加密使用的一对公钥 A 和私钥 B 传送证书 这个证书主要内容是公钥 A，也包含了其他信息，如证书的颁发机构，过期时间等等 客户端解析证书 由客户端的 TLS 来完成的，主要是验证公钥 A 是否有效，比如颁发机构，过期时间等等，如果发现异常就会弹出一个警告框，提示证书有问题 如果证书没有问题，那么就生成一个随机值（秘钥 D）。之后就进入了不对称加密（RSA）的过程，用证书对该随机值加密（秘钥 D），生成私钥 C 传送加密信息 这部分传送的是用证书加密后的随机值（私钥 C） 服务端解密信息 服务端私钥 B 解密私钥 C 后，得到客户端传过来的秘钥 D，到此 RSA 非对称加密的过程结束，后续所有的数据都可以用私钥 D，进行对称加密和解密 传输加密后的信息 服务端用秘钥 D 加密信息 客户端解密信息 客户端用之前生成的私钥 D 解密服务端传过来的信息，于是获取到了解密后的内容 中间人攻击 https 信息的安全完全建立在证书可信的基础上，如果中间人伪造证书怎么办？ 黑客自己伪造的证书需要通过客户端验证通过，才可以继续访问，只要客户端验证通过，那么公钥 A，私钥 B，私钥 C 对黑客来说都是透明的。 所以黑客只要诱导用户安装自己伪造的证书就可以，例如各种钓鱼的不可描述网站 推荐阅读https 加密过程和 tls 证书验证]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密传输之加密方式]]></title>
    <url>%2Fblog%2F2018%2F05%2F13%2Fstudy-https-01%2F</url>
    <content type="text"><![CDATA[加密传输方式 主要有两种，一种是对称加密（想想 shadowsocks），另外一种是非对称加密 对称加密 对称加密算法在加密和解密的时候用的是同一个秘钥 对称加密模式： 甲方选择某一种加密规则，对信息进行加密 乙方使用同一种规则，对信息进行解密 客户端和服务端进行通信，采用对称加密，如果只用一个秘钥，很容易破解；如果每次用不同的，海量秘钥的管理和传输成本又比较高，所以可以采用非对称加密。 非对称加密 需要两个密钥，一个是公钥，一个是私钥 非对称加密模式： 乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 甲方获得乙方的公钥后，用它对信息进行加密 乙方拿到加密后的数据后，用私钥进行解密 即使黑客拿到了公钥，没有私钥也是没有办法解密，不考虑彩虹表的情况下，完全可以长期使用一对私钥 什么是彩虹表彩虹表是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。 查找表常常用于包含有限字符固定长度纯文本密码的加密。这是以空间换时间的典型实践，在每一次尝试都计算的暴力破解中使用更少的计算能力和更多的储存空间，但却比简单的每个输入一条散列的翻查表使用更少的储存空间和更多的计算性能。 RSA 算法最经典的非对称加密算法是 RSA RSA 公钥加密算法是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。公钥私钥成对出现，用其中一个加密只能用另一个解密，通常用公钥加密私钥解密。]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端缓存(二)]]></title>
    <url>%2Fblog%2F2018%2F05%2F13%2Fstudy-cache02%2F</url>
    <content type="text"><![CDATA[缓存历史http1.0 时代 主要通过 Pragma 和 Expires 这两个字段来规范。现在仍然有些古老的客户端不支持 http1.1，所以这个两个头还在使用。 Expires 字段不准确 是服务器返回该请求结果缓存的到期时间，如果再次发出这个请求，客户端的时间小于 Expires 的值，直接使用缓存结果 但是客户端和服务器如果有一方的时间不准确，比如时区，比如客户故意调整系统时间，都会失效 http1.1 时代 主要就是 Cache-Control 来控制了 强缓存 命中状态码是 200，后面会跟着 from cache。现在高版本的 Chrome 换成了 from disk cache（磁盘缓存）和 from memory cache（内存缓存） 内存缓存 快速读取：将编译解析后的文件，直接存入该进程的内存，占据该进程的一定内存资源，以方便下次运行的快速读取 时效性：一旦进程关闭，那么该进程的内存将会被清空 磁盘缓存 直接将缓存写入磁盘文件中，读取缓存需要对缓存存放的硬盘文件进行 I/0 操作，然后重新解析该缓存内容，读取复杂，内容比内存缓存慢。 只有 get 请求能被缓存，post 不可以 get 方法是从指定的资源请求数据，post 是向指定资源提交要被处理的数据 get 请求可以被缓存，只应当用于取回数据，请求长度有限制 post 请求不会被缓存，对数据长度没有要求 用户操作与缓存的关系 当按 F5 进行刷新的时候，会忽略叼 Expires/Cache-control 的设置，会再次发送请求取服务器请求，而 Last-Modified/ETag 还是有效的。就是有可能命中协商缓存。 当按住 ctrl+f5 进行强制刷新的时候，所有缓存机制都将失效 其他一些操作比如，地址栏回车，前进后退都不会影响缓存字段 缓存命中率 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。 推荐阅读node 实践 http 缓存]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http表单的常见编码]]></title>
    <url>%2Fblog%2F2018%2F05%2F11%2Fstudy-web-form%2F</url>
    <content type="text"><![CDATA[什么是 http 表单 web 最常见的就是 post 和 get 方法。其中 get 一般将参数编码在 url 中来传递数据，post 或者 put 必须要将数据放在 http 请求实体中，这样的数据就是 http 表单 表单数据的编码方式是 http 头部设置 Content-Type Content-Type 可以是任意 MIME 类型 下面五种最为常见 URLencoded：application/x-www-form-urlencoded mutipart:mutipart/form-data json:application/json xml:text/xml 纯文本：text/plain html 的 form 表单支持 urlencoded，mutipart 和 plain text 的编码，通过 enctype 属性来设定。 ajax 默认是 json 格式的编码 URLencoded form 表单的 enctype 默认就是 urlencoded 123456789&lt;form method='post' enctype='application/x-www-form-urlencoded'&gt; &lt;input type="text" name='title'&gt; &lt;input type="text" name='subtitle'&gt; &lt;input type="submit"&gt;&lt;/form&gt;//http请求头Content-Type: application/x-www-form-urlencoded//请求体title=test&amp;subtitle=%E4%B8%AD%E5%9B%BD=&gt;base64编码（url通用的编码，可以在chrome控制台用decodeURI解码） JSON1234567$.post('/xxx', &#123; title: 'test', content: [1,2,3]&#125;);Content-Type: application/json;charset=utf-8//请求实体&#123;"title":"test","content":[1,2,3]&#125; XML12345678910Content-Type: text/xml//请求实体&lt;!--?xml version="1.0"?--&gt;&lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt;&lt;/methodcall&gt;]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax使用FormData对象上传文件]]></title>
    <url>%2Fblog%2F2018%2F05%2F11%2Fform-data%2F</url>
    <content type="text"><![CDATA[背景 因为发现用 postman 很轻松的就可以选择 file 类型 但是 ajax 直接 data 提交键值对却是报不合法的 12345678910//报错的this.$proxy(&#123; url: "/pgsls/kol/addExcel", type: "post", data: &#123; brandId: "1", type: "1", file: file //文件类型 &#125;&#125;); 解决方案 因为要上传类型是文件（二进制数据，而 http 提供的基于文本的通信协议），所以请求头的 Content-Type 要改成 multipart/form-data(默认是 application/x-www-form-urlencoded) input 的 file 类型可以通过 change 事件来获取 file 对象（event.target.files） HTTP 请求实体 每个字段由一段 boundary string 来分隔，浏览器保证该 boundary string 不与内容重复,因而 multipart/form-data 能够成功编码二进制数据 1234567891011121314------WebKitFormBoundaryWyjhf3VZMVeInmDeContent-Disposition: form-data; name="brandId"0------WebKitFormBoundaryWyjhf3VZMVeInmDeContent-Disposition: form-data; name="type"1------WebKitFormBoundaryWyjhf3VZMVeInmDeContent-Disposition: form-data; name="file"; filename="test.xlsx"Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet------WebKitFormBoundaryWyjhf3VZMVeInmDe-- 说一下为什么这里文件只有文件名，没有文件路径？ 按照浏览器的安全策略，网页是不能获取到一个文件的完整路径。因为网页开发者可能从这个路径获取到其他信息，甚至发起攻击。 实际发送123456789101112let formData = new FormData();formData.append("brandId", this.dialog.selectBrand);formData.append("type", this.dialog.selectType);formData.append("file", this.dialog.file);return this.$proxy(&#123; url: "/pgsls/kol/addExcel", type: "post", data: formData, cache: false, processData: false, contentType: false&#125;); cacah:false cache 设为 false 可以禁止浏览器对该 URL（以及对应的 HTTP 方法）的缓存。 jQuery 通过为 URL 添加一个冗余参数来实现。 该方法只对 GET 和 HEAD 起作用，然而 IE8 会缓存之前的 GET 结果来响应 POST 请求。 这里设置 cache: false 是为了兼容 IE8。 contentType：false jq 的 contentType 默认值是 application/x-www-form-urlencoded,因此传给 data 参数的对象会默认转换为 query string 我们不需要 jq 做这个转换，否则会破坏掉 multipart/form-data 的编码格式。所以设置 false 来禁止 jq 的转换操作 processData:false jq 会将 data 对象转换为字符串来发送 http 请求，默认情况会用 application/x-www-form-urlencoded 编码转换 我们设置 contentType:false 后该转换会失败。因此设置 processData:false 来禁止这个转换过程（相当于双层保险） data 本来就是用 formData 编码好的数据，不需要进行字符串转换 兼容性 由于 formdata 对象是 XMLHttpRequest Level2 接口，需要 IE 10+, Firefox 4.0+, Chrome 7+, Safari 5+, Opera 12+ 低版本浏览器只能用 form 表单了]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端缓存(一)]]></title>
    <url>%2Fblog%2F2018%2F05%2F11%2Fstudy-cache%2F</url>
    <content type="text"><![CDATA[为什么需要前端缓存 重复利用资源，提高网页打开资源 减少 http 请求，减少网络带宽 两种缓存 200(from cache)和 304（not modified） 强缓存：200(from cache)强缓存命中不会发送请求到服务端，直接从本地缓存中获取资源 协商缓存：会发送请求到服务器，服务器通过请求头部字段来验证资源是否命中协商缓存，如果命中，返回 304,通知浏览器从缓存中获取资源 与缓存策略相关的字段 三个字段 Cache-Control,Pragma,Expires(过期时间)，下面介绍一下响应头中的 Cache-Control http1.1 新增的字段，是控制浏览器缓存的主要字段。 no-cache：资源可以被缓存，但是立刻过期，下次访问必须验证资源有效性 max-age：缓存资源，在指定时间（是 res 里面的 Date 字段）后过期，单位是秒 no-store：资源不会被缓存 public：资源可以被浏览器和代理服务器缓存 private:资源只能被浏览器缓存 Pragma 是 http1.0 的字段，只有一个值 no-cache，功能和 Cache-control:no-cache；一样，但是优先级比他低。 Expires 是缓存到期时间，是一个服务器的绝对时间，由于时区的误差等因素已经较少使用。优先级比 Cache-control:max-age 低。 强缓存命中条件 有些场景下必须避免浏览器缓存，响应头可以这样设置：Cache-Control: no-cache, no-store, must-revalidate(必须验证) 公开资源直接命中强缓存，这是响应最快的。 请求头部不包括 Pragma 字段 响应头部 Cache-Control 中不包括 no-cache、no-store 响应头部 max-age 或者 expire 大于请求日期 如果我们在很短的一段时间内多次访问同一个资源，并且响应头部却没有 max-age 或者 expires 信息，是不是就不会命中强缓存？不是的，浏览器会做出优化，默认会使用一个启发式算法，取响应头(Date-Last-Modified)*0.1 作为缓存的有效时间（其实就相当于 max-age），只要在这段时间内请求这个资源，即使没有缓存过期字段，也会命中强缓存 协商缓存命中条件Last-Modified/If-Modified-Since 响应头会有一个 Last-Modified，代表这个资源最后修改的时间。 当浏览器再次向服务器请求该资源的时候，会传送 If-Modified-Since（也就是上次服务器传送过来的 Last-Modified），服务器会拿这个值跟本地资源实际最后修改时间作比较，如果文件没有被修改，那么返回 304，通知浏览器从缓存中读取文件。 ETag/If-None-Match ETag 是一个响应首部字段，他是根据资源内容生成的一段 hash 值，标识资源的状态，由服务器产生。 当浏览器再次向服务器端请求这个资源，会带上 If-None-Match（其实就是上次服务器发过来的 ETag 的 hash 值），服务器收到后，会拿这个值和资源实际的 ETag 做比较。 如果一样就命中协商缓存，返回 304 ETag 的优先级比 Last-Modified 高 本来已经有了一个 Last-Modified，为什么还需要 ETag？ 这是因为 Last-Modified 只能精确到秒，而如果我们在服务器一秒内多次更改资源，那么将无法识别，还是会命中协商缓存 而且某些服务器不能精确得到文件的最后修改时间 一些文件或许会周期性被更改，但是他内容并没有改变，只是改变了修改时间，这个时候我们并不希望浏览器重新请求这个资源]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks了解一下]]></title>
    <url>%2Fblog%2F2018%2F05%2F09%2Fss%2F</url>
    <content type="text"><![CDATA[有时候需要科学上网，这个时候 ss 就大显身手了 初步认识 ss 是一个能骗过防火墙的网络代理工具。把要传输的原数据经过加密后再传输，网络中的防火墙由于得不出要传输的内容是啥，就只好放行了。 于是就完成了防火墙穿透，也就是所谓翻墙。 网络环境 自由的网络环境下 ，本机访问其他互联网服务建立连接传输数据的时候，直接 req 过去，res 回来 但是一般情况下，会有 GFW。req 过去的数据和 res 回来的数据都必须通过 GFW 的检查。 如果发现传输受限的内容，就会拦截本次传输，就会导致本机无法访问远程服务。 ss 做什么 ss 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，如果想要破解加密数据可能经过大量运算，所以防火墙只好放弃。 放行这个请求，本机就可以访问到了远程服务 ss 准备什么 一台在 GFW 之外的服务器，ip 是国外的，比如（vultr 的 vps） 在本机安装 ss 客户端，用于加密传输数据 服务器需要安装 ss 服务端，用于解密加密的传输数据，然后再把揭秘后的原数据发送到目标服务器 原理 由两部分组成，运行在本地的 ss-local 和运行在 GFW 之外的服务器的 ss-server。 ss-local 在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，然后按照用户配置的加密方法和密码加密传输数据，再转发到墙外的 ss-server PAC 代理模式和全局代理模式 pac 模式是访问网站先匹配 pac list，如果有在里面才会访问，否则直接连接访问网站 节省 ss 流量，提高国内的访问速度 ss-server 在墙外服务器启动和监听一个服务，监听 ss-local 的请求。 收到 ss-local 转发过来的数据后，会先根据用户配置的加密方法和密码对数据进行对称揭秘，以获得加密后的数据的原内容。 同时还会解析 socks5 协议，读出本次请求真正的目标服务地址（例如 facebook，google 服务器地址），再把解密后的数据发过去 当真正的目标服务返回了数据，比如谷歌返回了页面，ss-server 会把返回的数据加密返回给 ss-local。ss-local 收到数据后再解密，发给本机的软件。 这是一个对称相反的过程。 ss-local 和 ss-server 都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。 ss 提供一系列的标准可靠的对称算法供用户选择。如 rc4,aes,does。 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法算出传输的原数据。 chrome 下 SwitchyOmega 配合使用 下载 SwitchyOmega 插件，勾选系统代理，将流量全部转给 ss-local 推荐阅读本文节选自从零开始写一个 shadowsocks自建 ss 服务教程]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx初步使用（-）]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2Fstudy-nginx3%2F</url>
    <content type="text"><![CDATA[在本地用 brew install nginx 之后，迫不及待的想要使用一下 mac 下默认监听 8080 端口，输入 localhost:8080 就可以看到 nginx 的欢迎页 更改默认配置文件 默认安装在/usr/local/etc/nginx 下面 位置 nginx.conf 是其默认配置文件，nginx -s reload 读取的就是这个 如果想配置多个域名，可以在 nginx 目录下新建一个 sites-enabled 文件夹，然后再建一个以区分 http 和 https，在 nginx.conf 里include /usr/local/etc/nginx/sites-enabled/* 我看 centos 系统里新建的文件夹是 conf.d 域名配置文件一个最佳实践就是按照域名来写，比如 yoki.com.cn.conf 配置介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# user字段表明了Nginx服务是由哪个用户哪个群组来负责维护进程的，默认是nobody# 我这里用了liyoujie用户，staff组来启动并维护进程# 查看当前用户命令： whoami# 查看当前用户所属组命令： groups ，当前用户可能有多个所属组，选第一个即可user liyoujie staff;# worker_processes字段表示Nginx服务占用的内核数量# 为了充分利用服务器性能你可以直接写你本机最高内核# 查看本机最高内核数量命令： sysctl -n hw.ncpuworker_processes 4;# error_log字段表示Nginx错误日志记录的位置# 模式选择：debug/info/notice/warn/error/crit# 上面模式从左到右记录的信息从最详细到最少error_log /usr/local/var/logs/nginx/error.log debug;# Nginx执行的进程id,默认配置文件是注释了# 如果上面worker_processes的数量大于1那Nginx就会启动多个进程# 而发信号的时候需要知道要向哪个进程发信息，不同进程有不同的pid，所以写进文件发信号比较简单# 你只需要手动创建，比如我下面的位置： touch /usr/local/var/run/nginx.pidpid /usr/local/var/run/nginx.pid;events &#123; # 每一个worker进程能并发处理的最大连接数 # 当作为反向代理服务器，计算公式为： `worker_processes * worker_connections / 4` # 当作为HTTP服务器时，公式是除以2 worker_connections 2048;&#125;http &#123; # 关闭错误页面的nginx版本数字，提高安全性 server_tokens off; include mime.types; default_type application/octet-stream; # 日志记录格式，如果关闭了access_log可以注释掉这段 #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; # 关闭access_log可以让读取磁盘IO操作更快 # 当然如果你在学习的过程中可以打开方便查看Nginx的访问日志 access_log off; sendfile on; # 在一个数据包里发送所有头文件，而不是一个接一个的发送 tcp_nopush on; # 不要缓存 tcp_nodelay on; keepalive_timeout 65; gzip on; client_max_body_size 10m; client_body_buffer_size 128k; # 引入其他文件，一个是http服务的，一个是https服务的 # 由这里include可以知道，那些被include的文件都是server上下文开始的（并不是http上下文） # default default-ssl include /usr/local/etc/nginx/sites-enabled/*;&#125;]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》03-快速排序]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2Fstudy-Graphical-algorithm04%2F</url>
    <content type="text"><![CDATA[分而治之（divide and conquer） 缩写就是 D&amp;C 一种著名的递归式问题解决办法 快速排序是一个重要的 D&amp;C 算法 步骤 找出基线条件，这种条件应该尽可能简单 不断将问题分解（或者说缩小规模），直到符合基线条件 场景 给定一个数组[2,4,6]，然后相加，并返回结果，不使用循环 第一步找到基线条件，最简单的数组是怎样的？如果数组不包含一个元素或者只有一个元素，那么计算总和就容易了，这就是基线条件 每次递归调用都必须离空数组更近 12345678function sum(arr) &#123; if (arr.length == 1) &#123; return arr[0]; &#125; else &#123; //别忘了递归记录了状态 return arr.shift() + sum(arr); &#125;&#125; 快速排序 使用快排对数组进行排序 对于排序算法来说，最简单的数组是怎么样的？没错，就是根本不需要排序的一个元素的数组或者空数组 原理 [33,15,10]  首先在数组中选择一个元素，这个元素被称为基准值（pivot），等等介绍如何选择合适的基准值，这里选择第一个元素 33 找出比基准值小的元素和比他大的元素，这叫分区 现在我有：一个由所有小于基准值的数字组成的子数组，基准值，一个由所有大于基准值的数字组成的子数组 然后再对子数组进行排序，然后合并结果就能得到有序数组：quicksort([15,10])+[33]+quicksort([]) 1234567891011121314151617181920function quicksort(arr) &#123; if (arr.length &lt; 2) &#123; //基线条件：为空或者包含一个元素的数组有序 return arr; &#125; else &#123; let pivot = arr[0]; //递归条件 let less = [], greater = []; //子数组 arr.forEach(item =&gt; &#123; if (item &lt; pivot) &#123; less.push(item); &#125; if (item &gt; pivot) &#123; greater.push(item); &#125; &#125;); return [...quicksort(less), pivot, ...quicksort(greater)]; &#125;&#125; 最糟情况和平均情况 平均情况下是 O（n*logn） 有一种算法叫合并排序也是这个，但是为什么不用这个呢，是因为大 O 表示法有个常量（也被叫做固定时间量）被省去了，如果两个算法的大 O 运行时间不一样，那么常量无关紧要，参考简单查找和二分查找。如果一样的话，那么常量的影响非常大。两个函数，后面那个我每读一个元素，睡一秒种，但是其实两个函数速度一样，但是前面所需的时间更少。同理可得，快排所需的时间更少，而且相对于遇上最糟情况，它遇上平均情况的可能性大得多。 最糟糕就是与选择排序一样慢，O（n^2） 场景 比如[1,2,3,4,5,6,7] 如果从第一个数作为基准值，数组没有被切成两半，这将导致调用栈很长，栈长 n 个，而且最上面那层都涉及 n 个元素，然后类推 n-1 个元素，最终得出 n*n*1/2 个操作，去掉常数，也就是 n^2 如果总是将中间的元素作为基准值，数组分成两半，最佳情况下,栈长为 logn 个,然后每次也是涉及 O（n）个元素（去掉常量），也就是 n*logn。而且最佳情况也是平均情况，只要每次随机地选择一个数组元素作为基准值，那么平均运行时间就是 O（nlogn） 123456789101112131415161718192021222324252627282930313233343536function quicksort(arr) &#123; if (arr.length &lt; 2) &#123; //基线条件：为空或者包含一个元素的数组有序 return arr; &#125; else &#123; //随机选择索引 let index = randomNum(0, arr.length - 1); let pivot = arr[index]; //递归条件 let less = [], greater = []; //子数组 arr.forEach(item =&gt; &#123; if (item &lt; pivot) &#123; less.push(item); &#125; if (item &gt; pivot) &#123; greater.push(item); &#125; &#125;); return [...quicksort(less), pivot, ...quicksort(greater)]; &#125;&#125;//随机数function randomNum(minNum, maxNum) &#123; switch (arguments.length) &#123; case 1: return parseInt(Math.random() * minNum + 1, 10); break; case 2: return parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10); break; default: return 0; break; &#125;&#125; 说一下冒泡排序 想象一下一个个冒泡上来，第一次遍历，第一个跟接下来的比较，如果比他大就换位置，一圈完事后。到第二个，跟接下来的换位置。 运行时是 O（n^2） 12345678910111213function bubbleSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.log(arr); return arr;&#125;]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》03-递归和栈]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2Fstudy-Graphical-algorithm03%2F</url>
    <content type="text"><![CDATA[递归概念 函数调用自己 需要有基线条件和递归条件 基线条件和递归条件 每个递归函数都有两部分：基线条件和递归条件。 递归条件是指函数调用自己 基线条件是指函数不再调用自己，从而避免无限循环 12345678910//倒计时function countdown(i) &#123; console.log(i); if (i &lt;= 0) &#123; return; //基线条件 &#125; else &#123; countdown(i - 1); //递归条件; &#125;&#125; 栈概念 一种类似堆叠的盘子的数据结构 调用栈 函数里面调用函数，形成一个栈结构 greet 里面调用 greet1 函数，计算机先为第一个函数调用分配一个内存块，再为第二个分配一个内存块（位于第一个上面），然后第二个从函数调用返回，此时栈顶的内存块被弹出，然后剩下第一个 递归调用栈 特殊一点的调用栈，就是调用自己的 栈中包含未完成的函数调用，这样栈就帮你跟踪了函数 使用栈虽然方便，但也要付出代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》02-数组,链表和选择排序]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2Fstudy-Graphical-algorithm02%2F</url>
    <content type="text"><![CDATA[数组和链表 当需要将数据存储到内存的时候，我们请求计算机提供存储空间，计算机给我们一个存储地址。需要存储多项数据的时候，有两种基本方式——数组和链表。 数组想象画面 java 中一开始要确定数组的大小，不是没有道理的… 两个人去电影院看电影，找到地方就座后，又来了一个朋友，但是你们下一个位置是别人占用了，你们三个是好朋友，没理由分开，只得挪去其他有三个位置的地方。 所以来了新朋友是很麻烦的，但是有一种解决办法就是预先买了 10 个座位的，但是这样会浪费资源，要是超过 10 个还是转移（数组插入很麻烦） 但是我想知道另外一个朋友坐哪里，这是很简单的，挨在一起（数组查找快） 另一个朋友要走的话也很麻烦，因为剩下的朋友要往前来挨在一起坐，反正不管怎样大家是个整体，坐在一起就对了（数组删除很麻烦） 链表 链表和数组不一样，一定要顺序排着队这样。链表的元素可以存储再内存中的任何地方，当前元素存储存储着下一个元素的地址，从而使得一系列随机的内存地址串在了一起 想象画面 寻宝游戏：前往第一个地址，那有宝箱，打开后是下一个宝箱的地址。 但是我直接想要最后一个宝箱，是无法做到的，是要一个个查找直到倒数第二个才得到最后一个宝箱的位置（链表查找效率很低） 移走一个宝箱很容易，直接把上一个宝箱的地址指向下一个的地址就可以了（链表删除很快） 如果是五个人去看一部很火的电影，但是根本就无法坐一起，但是换做链表，就可以分开来做，所以这个来了新朋友一点也不麻烦（链表的优势就是插入） 运行时 这里是最差的情况，比如数组插入一个刚好就要移走（因为原来已经满了） 数组 链表 插入 O(n) O(1) 读取 O(1) O(n) 删除 O(n) O(1) O（n）是线性时间，O（1）是常量时间 选择排序场景 qq 音乐列表里面记录了每个音乐的播放次数，你要对它进行排序，从多到少 一种办法是遍历这个列表，然后找到播放次数最多的，然后添加到一个新列表 然后删除刚刚那个次数最多的，再继续这样找到第二多的 需要检查的就越来越少 算法复杂度（运行时） 第一次每个元素都查看一次，那就是执行 n 次 第二次执行 n-1 次 依次查看最后得出，要执行 n（n-1）（n-2）..2*1=n*1/2*n 但是大 O 表示法省略常数，所以最后是 O(n^2)]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《图解算法》01-二分查找和大O表示法]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2Fstudy-Graphical-algorithm01%2F</url>
    <content type="text"><![CDATA[场景电话本 假设从电话本里面找 yoki 的电话，最常见的不是从开头开始找，而是从中间开始查找 电话本是有序列表 1-100 猜想 以目标最少的次数猜到这个数字 简单查找 如果从 1 开始猜，这叫简单查找，换句话说就是傻找 如果是 99，那么得猜 99 次（临界点就是这个数） 二分查找 如果从中间值开始猜 那么临界点就是 99，最坏的情况下只用猜七次，50 错，75 错..这样猜 那么得出结论，对于 n 个元素，用二分查找最多需要 log2 n 步，简单查找最多需要 n 步 2^log2 n=n，log 叫对数运算，2^n 叫幂运算，他们互为逆运算 算法实现 注意二分查找法必须是有序的 大 O 表示法 指出的是最糟情况下的运行时间，也可以说是操作数 这里用大 O 表示法讨论运行时间，都是讨论的最糟糕的临界值，比如简单查找 100 个元素，就是要看每一个元素。二分查找也是查看最远的，那么就只用查看 log100 个元素约为 7 log 时间这里的底数默认是 2，也就是默认是 log2 其实我们是用幂运算的眼光来看，我们求的运行时其实就是指数 概念 大 O 表示法指出了算法有多快。例如，假设列表包含 n 个元素，简单查找需要检查每个元素，因此需要执行 n 次查找,运行时间位 O（n） O(n),单位不是秒，大 O 表示法指的并不是以秒为单位的速度，而是能够比较操作数，它指出了算法运行时间的增数 所以 n 是操作数的意思 谈论算法的速度，是随着输入的增加，其运行事件将以怎么样的速度增加 常见的大 O 运行时间 由快到慢的经常遇到的五种，可以自己想象一下坐标系图 O（log n）,也叫对数时间，这样的算法包括二分查找 O(n)，线性时间，包括简单查找 O(n*log n)，包括快速排序（业界俗称快排），一种速度较快的快速排序 O（n^ 2）,包括选择排序，一种速度较慢的排序算法 O（n！），包括旅行商问题的解决方案，一种非常慢的算法 旅行商问题 旅行商要前往 5 个城市，同时确保旅程最短，这样它要每个城市都去，然后计算总旅程，再挑选路线最短的 5 个城市有 120 种不同的排列方式，因此需要 120 个操作 这是一个非常非常慢的算法，但是这个问题也是计算机科学领域待解决的问题]]></content>
      <tags>
        <tag>图解算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js浮点数的坑]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2Fstudy-number%2F</url>
    <content type="text"><![CDATA[浮点数在计算机中的表示 日常中，32767 这个数用科学计数法可以写成 3.2767*10^4，3.2767 称为尾数(Mantissa)，4 就是指数(exponent) 浮点数在计算机中基于科学技术法来表示的，上面是我们日常用十进制来表示，计算机则是二进制，它的基数是 2 不是 10 一种浮点数格式 假设共有 14bits，5bits 表指数，8bits 表尾数，1bit 表示符号 17=&gt;10001=1.00012^4 类比十进制的 1.710^5 尾数部分 因为尾数在十进制里面 0&lt;尾数&lt;10，在二进制里面就是 0&lt;尾数&lt;2，那么规定最高位只能是 1 因为尾数默认是 1，所以这个 1 就不用保存了，可以节省一位提高精度。所以尾数部分本来是 10001，这样就只用存储 0001，去掉了 1 需要注意的是，这里我们尾数的有效位数是 8 位，而 128.25=&gt;10000000.01,需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 也才 9 个有效位，所以 128.25 只能舍去末尾的 1，表示为 10000000.0，其实跟 128 相等。所以浮点数不能做精确比较就是这样的 指数部分 但是指数部分是 4，换算成二进制也就是 100，如果以为是 100 就错了。 因为 0.25=&gt;0.01=1*10^-2,但是这样我们无法用指数表示负数。第一个符号位表示的是整个数的正负 现在广泛采用的是偏移的指数。规定一个偏移值，比如偏移值是 16，实际的指数要加上这个偏移值才可以，这样比 16 大的就是正指数，小的就是负指数。 要表示 0.25，如果偏移值 16，那么指数部分是 14，要表示 17 的指数部分，是 16+5=21,换成二进制就是 10101 1bit 5bits 8bits sign bit exponent Mantissa 符号位 指数 尾数 0 10101 00010000 js 的浮点数标准 js 的 number 遵循 IEEE 754 标准，使用 64 位固定长度表示，也就是 64 位 double 双精度浮点数（类似的有 float 32 位单精度标准） 大多数语言的小数默认都是遵循这个标准，所以 js 有的问题他们也有，包括 java，ruby，python 64bits 分为三部分 符号 S：1bit，0 表示正数，1 表示负数 指数 E：中间的 11 位存储指数 尾数 M：最后的 52 位是尾数 因为指数 E 有 11 位，取值范围是 2^11=2048，也就是[0,2047]，所以约定的偏移值是 1023，[0,1023]是负数 浮点误差 浮点数不是精确存储的 0.1 浮点误差（转成二进制无限循环） 0.1 转成二进制==0.0001100110011001100(1100 循环)=1.100110011001100(1100 循环)x2^-4，因为尾数舍去首位的 1，存的是后面的数，但是最多也只能存 52 位，然后再把有误差的只有 52 位尾数的，转成十进制，就变成了 0.100000000000000005551115123126 0.1+0.2=0.30000000000000004，那是因为把这两个转成二进制（这里就有误差了）后再运算，然后再转回十进制，正好是 0.30000000000000004 为什么 x=0.1 就能得到 0.1 因为尾数的固定长度是 52 位，那么加上省略的一位，最多可以表示的数位 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992,我们只用记住 2^53 就好了 2^53 的长度是 16 位,这也是 js 最多能表示的精度 所以可以近似用 toPrecision(16) 来做精度运算，超过的精度会自动凑整处理 Precision 是精确的意思 所以 0.1 转成二进制然后再成十进制是 0.100000000000000005551115123126.toPrecision(16)=0.1000000000000000，去掉末尾的 0 正好是 0.1 所以我们看到的 0.1 并不是 0.1 可以用更高的精度解释：0.1.toPrecision(21) = 0.100000000000000005551 toPrecision vs toFixed 两者都能对多余数字取整，但是，前者是处理精度，精度是从左到右第一个不为 0 的数开始计算。后者是小数点指定位数取整，从小数点开始数起来 有些用 toFixed 用来四舍五入，但是其实是有 bug 的， 1.005.toFixed(2)=1.00 而不是 1.01 因为 1.005 实际上是 1.00499999999999989，4 是进不了 1 的 解决浮点数方案 由于理论上用有限的空间来存储无限的小数是不可能保证精确的，但是我们可以处理一下得到我们精确的结果 数据展示类 1.4000000000000001 这样的数据要展示的话，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示 parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 为什么选用 12 作为精度，因为这是一个经验之谈，大部分够用了 数据运算类 要把小数转成整数后再运算]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解二进制转换]]></title>
    <url>%2Fblog%2F2018%2F05%2F03%2Fstudy-Conversion%2F</url>
    <content type="text"><![CDATA[十进制是为了人们方便记忆使用的，而计算机的世界里只有 0 和 1，也就是只有二进制 二进制 想要了解计算机，首先要了解二进制 以下来自维基百科 二进制（binary）数是指用二进制记数系统，即以 2 为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号 0（代表零）和 1（代表一）来表示。以 2 为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit 的缩写） 二进制转换成十进制 以 2 为底数，指数是权重（换句话说是位数-1，权重从 0 开始） 例如：11=&gt;12^1+12^0=3 十进制转换成二进制 每一步除以进制数（2），直到商数为 0，然后取每一步的余数，再倒过来就是了 例如 10=&gt;10/2=5 余 0,5/2=2 余 1，2/2=1 余 0，1/2=0 余 1,然后再取倒就是 1010 如果是有小数的，比如 10.25,那么小数部分乘以 2，取它整数部分的结果，然后再用这个结果继续乘以 2 算，直到小数部分为 0 例如 10.25 的小数部分是，0.25*2=0.5(取整数就是 0),0.5*2=1.0(取 1，然后终止，因为小数部分是 0），答案是 1010.01]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Data URL]]></title>
    <url>%2Fblog%2F2018%2F05%2F01%2Fstudy-dataUrl%2F</url>
    <content type="text"><![CDATA[Data URL 是什么是一种提供让外置资源直接内嵌在页面中的方案。格式如下： 格式1data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt; 第一部分是data：协议头，它标识这个内容为一个 dataurl 资源 第二部分是 MIME 类型，表示这串内容的展现方式，比如 text/plain，就是文本展示;image/jpeg,就是以 jpeg 图片形式展示，同样浏览器会根据这个 MIME 类型来解析数据。 第三部分是编码设置，默认编码是 charset=US-ASCII，可以在浏览器输入框分别输入下面内容： 12345678// output: &amp;auml;&amp;frac12; &amp;aring;&amp;yen;&amp;frac12; -&gt; 使用默认的编码展示，故乱码data:text/html,你好// output: 你好 -&gt; 使用 UTF-8 展示data:text/html;charset=UTF-8,你好// output: 浣犲ソ -&gt; 使用 gbk 展示（浏览器默认编码 UTF-8，故乱码）data:text/html;charset=gbk,你好// output: 你好 -&gt; UTF-8 编码，内容先使用 base64 解码，然后展示data:text/html;charset=UTF-8;base64,5L2g5aW9 第四部分是 base64 编码设定，可选 最后一部分是这个 dataurl 承载的内容，可以是纯文本，也可以是经过 base64 编码的内容 平时我们经常见到的是这样的： 12//内嵌base64图片background-image: url("data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7"); Data URL 的优劣优点 img 的 src 说明这个是外部资源，浏览器会向服务器拉取一次资源请求，占用网络资源 大多数浏览器都有一个并发请求数不能超过 4 个的限制。如果一个网页里嵌入了太多的外部资源，请求会使整个页面加载延迟。 图片体积太小的时候，不值得占用一个 http 会话 缺点 base64 编码的数据体积是原数据的体积 4/3，也就是说 data url 形式的图片会比二进制格式的图片体积大 1/3 data url 形式的图片不会被浏览器缓存，这意味着每次访问这样页面的时候都会被下载一次。如果这个图片被整个网站使用，就是一个使用效率问题（已被解决） 如何将 data url 数据放入浏览器缓存，通过 css 样式文件。所有浏览器都会积极缓存 css 文件来提高页面加载效率]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈http]]></title>
    <url>%2Fblog%2F2018%2F04%2F23%2Fstudy-http%2F</url>
    <content type="text"><![CDATA[http（hypertext transfer protocol）超文本传输协议 http 传输流 发送端在层与层间传输，每经过一层都会被加上首部信息，接受端每经过一层都会删除一条 应用层：本来是 http 数据 经过传输层，加上 tcp 首部 经过网络层，加上 ip 首部 经过链路层，加上以太网首部 然后接收端依次经过链路层，网络层，传输层，应用层 状态码1xx 传达信息 100 continue 101 switching protocols 2xx 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 206 Partial Content，进行范围请求 3xx 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和 302 含义相同 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 405 method not allowed 一般是 get 和 post 弄错了 5xx 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 504 gateway timeout 网关超时 http 协议格式 http 的请求和响应的消息协议是一样的，分为三个部分，起始行，消息头和消息体。这三个部分以 CRLF 作为分隔符，最后一个消息头有两个分隔符，表示消息头部结束。 起始行：如 GET /index.html HTTP/1.1 消息头部（http header）：多个键值对组成，如 Content-Encoding: gzip，多个键值对之间使用 CRLF 作为分隔符 消息体（http body）：实体部分，请求实体和响应实体 http 的无状态性 所谓 HTTP 协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在 HTTP 协议之上的应用程序就无法维持状态。应用层可以通过会话 Session 来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话 ID，浏览器可以将会话 ID 记录在本地缓存 LocalStorage 或者 Cookie，在后续的请求都带上这个会话 ID，服务器就可以为每个请求找到相应的会话状态。 输入 url 到页面加载发生了什么 输入地址 浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等） 浏览器发送异步请求]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用set数据结构]]></title>
    <url>%2Fblog%2F2018%2F04%2F22%2Fstudy-set%2F</url>
    <content type="text"><![CDATA[使用 set 数据结构 set 是一个类似数组的数据结构，但是它没有重复值 如何生成 set 数据结构 直接 new Set() 往 new Set()传入具有 iterator 接口的数据结构，比如数组 1234567891011121314151617// 例一const set = new Set([1, 2, 3, 4, 4]);[...set];// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size; // 5// 例三const set = new Set(document.querySelectorAll("div"));set.size; // 56// 类似于const set = new Set();document.querySelectorAll("div").forEach(div =&gt; set.add(div));set.size; // 56 set 实例属性和方法属性 Set.prototype.constructor：构造函数，默认就是 Set 函数 Set.prototype.size：返回实例的总数 方法操作方法 add(val)：添加某个值，返回 该实例 delete(val):删除某个值，返回布尔值，表示是否成功 has(val)：返回布尔值，表示是否拥有 clear()：清空所有，返回值 void 遍历方法 set 结构是具有 itrator 接口的，可以直接 for..of 遍历，相当于下面的 values keys：返回键名的遍历器对象 values：返回值的遍历器对象 entries:返回键值对的遍历器对象 forEach:使用回调函数遍历每个成员 由于 set 没有键名，只有键值，或者说键名和键值一样，所以 keys===values 应用 扩展运算符（…）内部使用 for..of，所以也可以应用在 set 结构。同时数组的 map 和 filter 方法也可以应用于 set。 12345678910let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; x % 2 == 0));// 返回Set结构：&#123;2, 4&#125; set 结构很容易实现交集，并集，差集 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈闭包]]></title>
    <url>%2Fblog%2F2018%2F04%2F21%2Fclosures%2F</url>
    <content type="text"><![CDATA[闭包是什么词法作用域 先要了解什么是词法作用域 作用域是由书写代码时候函数的位置决定的 可以想象函数里面嵌套函数，最里面函数可以方面函数的变量 也就是说内部函数可以读取外部函数的变量 但是我们外部怎么访问内部的局部变量，这就需要闭包 12345678910//如果我们在外部想拿到n的变量，可以函数内部返回//function f1() &#123; let n = 999; function f2() &#123; return n; &#125; return f2;&#125;let n = f1()(); 函数可以记住并访问它所在的词法作用域，换言之，它记住了定义时候的位置 然后它在其他作用域执行的时候，带上了它的词法作用域，这就是闭包 闭包可以干什么 很多高级应用都需要用到闭包来实现，主要用处有三个 上面提到的，可以访问内部函数变量 保持内部变量在内存之中 私有变量和模块化 123456789101112131415161718192021222324252627282930function f1() &#123; var n = 999; nAdd = function() &#123; n += 1; &#125;; function f2() &#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 999nAdd();result(); // 1000//私有变量和模块化var monitor = (function() &#123; var imgs = []; return function(src) &#123; var img = new Image(); imgs.push(img); img.src = src; &#125;;&#125;)(); 因为 f1 是 f2 的父函数，f2 依赖于 f1 的存在，f2 被赋给了全局变量，所以垃圾回收机制不会回收 因为 f2 不回收，所以 f1 也会存在于内存之中 n 的变量就静静呆在内存之中 比如 add(1)(2)(3)=6 就是这样解的 闭包的问题 闭包会导致变量都保存在内存里面，所以大量闭包会导致性能问题。遇到可以不用的，设置为 null，通知垃圾回收机制回收。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Iterator接口]]></title>
    <url>%2Fblog%2F2018%2F04%2F21%2Fstudy-iterator%2F</url>
    <content type="text"><![CDATA[简单介绍 Iterator（遍历器） 为不同的数据结构提供统一的访问机制，只要数据结构有这种接口，就可以用 for..of 完成遍历 遍历过程12345let it = makeIterator(["a", "b"]);it.next(); // &#123; value: "a", done: false &#125;it.next(); // &#123; value: "b", done: false &#125;it.next(); // &#123; value: undefined, done: true &#125; 第一次调用 next 方法返回数据结构的第一个成员，第二次就第二个直到没有 部署 Iterator 接口 当使用 for..of 遍历某种数据结构，就会自动去寻找 Iterator 接口 es6 规定改接口默认部署在Symbol.iterator属性里面 返回一个遍历器对象，该对象的本质特征就是具有 next 方法 每次调用 next 方法，都会返回一个当前成员的信息对象 12345678910111213//当执行for..of，会自动执行Symbol.iterator这个函数const obj = &#123; [Symbol.iterator]: function() &#123; return &#123; next: function() &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 有些数据结构，本身就具有该接口 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对象没有部署该接口 无法确定哪个属性先后 如果实在要遍历，可以使用 map 结构]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用map数据结构]]></title>
    <url>%2Fblog%2F2018%2F04%2F21%2Fstudy-map%2F</url>
    <content type="text"><![CDATA[object 和 map object 映照现实生活的物体，但是想使用 key-value 的遍历结构最好使用 map 数据结构 object 结构实际上是字符串—值的结构 map 具有 iterator 接口，并且是值-值对映射，也就是 key 可以是 function，obj 等 12345const data = &#123;&#125;;const element = document.getElementById("myDiv");//由于对象只接受字符串为键名，所以element被自动转化字符串data[element] = "metadata";data["[object HTMLDivElement]"]; // "metadata" 生成 map 结构 new Map() 往 new Map()里面传入任何具有 iterator 接口的数据结构，包括数组等，甚至包括 map 本身 需要注意的是，map 的 key 存的是内存地址，也就是说[‘a’]和[‘a’]不相等。基础值才相等 123456789101112const map = new Map();map.set(["a"], 555);map.get(["a"]); // undefinedconst k1 = ["a"];const k2 = ["a"];map.set(k1, 111).set(k2, 222);map.get(k1); // 111map.get(k2); // 222 实例属性和方法 size：返回成员总数 set(key, value)：返回该实例，如果 key 有值会更新，没有就新生成 get(key)：找到就返回，没有就 undefined has(key)：布尔值 delete(key)：删除成功返回 true，失败 false clear：清除所有成员，没有返回值 遍历方法与 set 类似，但是没有 filter 和 map 比较有意思的是，map 结构默认的 iterator 接口就是 entries 方法 123456789101112for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes" 应用与其他数据结构的互相转换 map 转为数组，使用…运算符 123const myMap = new Map().set(true, 7).set(&#123; foo: 3 &#125;, ["abc"]);[...myMap];// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组转为 map，观察数组结构 12345new Map([[true, 7], [&#123; foo: 3 &#125;, ["abc"]]]);// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; 过滤和遍历，但是 map 本身没有 map 和 filter 方法,先转为数组，再塞回 map12345678910const map0 = new Map() .set(1, "a") .set(2, "b") .set(3, "c");const map1 = new Map([...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map([...map0].map(([k, v]) =&gt; [k * 2, "_" + v]));// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈TCP]]></title>
    <url>%2Fblog%2F2018%2F04%2F19%2Fstudy-http-tcp%2F</url>
    <content type="text"><![CDATA[TCP tcp 协议对应于传输层，而 HTTP 协议对应于应用层。 http 协议基于 tcp 协议 TCP/IP 协议分层模型 物理层将二进制的 0 和 1 和电压高低，光的闪灭和电波的强弱信号进行转换 链路层代表驱动 网络层 使用 IP 协议，IP 协议基于 IP 转发分包数据 ip 协议是个不可靠协议，不会重发 ip 协议发送失败会使用 icmp 协议通知失败 ARP 解析 ip 中的 mac 地址，mac 地址由网卡出厂提供 ip 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信 传输层 通用的 tcp 和 udp 协议 tcp 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开链接，需要至少七次的发包收包，资源浪费 udp 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层 会话层 tcp/ip 分层中，会话层，表示层，应用层集中在一起 网络管理通过 snmp 协议 TCP 三次握手，建立连接 客户端-发送带有 syn 标志的数据包——一次握手-服务端 服务端-发送带有 syn/ack 标志的数据包——二次握手-客户端 客户端-发送带有 ack 标志的数据包-三次握手-服务端 TCP 四次挥手，断开连接 客户端-发送一个 fin，用来关闭客户端到服务器的数据传送 服务器-收到这个 fin，发回一个 ack，确认序号为收到的序号为 1。和 syn 一样，一个 fin 将占用一个序号 服务器-关闭与客户端的连接，发送一个 fin 给客户端 客户端-发回 ack 报文确定，并将确认序号设置为收到序号加 1 TCP 和 UDP tcp 就好比在微信聊天，你说一句我说一句 udp 就好比我找你，直接就打电话，简单粗暴]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈各种数据结构]]></title>
    <url>%2Fblog%2F2018%2F04%2F17%2Fstudy-data%2F</url>
    <content type="text"><![CDATA[列表，栈，队列，链表，字典，散列，图，二叉查找树 列表 日常生活中：购物清单，待办事项列表等 数据结构较为简单 不需要在一个长序列中查找元素，或者对其进行排序 栈 栈是一种特殊的列表，只能通过列表的一端进行访问，这一端被称为栈顶 餐厅里的盘子叠在一起，从最上面取盘子，洗完也只能放在上面 所以他是先进后出，后入先出的高效数据结构，因为数据只能在栈顶添加或删除，所以操作很快 比如函数调用栈 队列 队列也是一种特殊的列表 只能在队尾添加元素（入队），只能在队头删除元素（出队） 我们在银行排队，排在最前面的人第一个办理业务，然后出去 链表 链表也是一种特殊的列表 每个节点存下个节点的指针 有双向链表，单向链表，循环链表 字典 键值对的存储结构 散列 （散列）哈希表是一种常用的数据结构，散列后的数据可以快速插入 在散列表上插入，删除都非常快，但是查找效率非常低 查找一组数组中的最大值和最小值，一般要求助于其他数据结构，比如二叉查找树 即使一个高效的散列函数，也可能将两个键映射为同一个值的可能，这种现象叫碰撞。常见碰撞的处理方法：开链法和线性探测法 图 图是由边的集合和顶点的集合组成 两个城镇由某种道路相连，每个城镇是一个顶点，道路就是边 顶点也有权重，也叫成本 如果一个图的顶点对是有序的：有向图==流程图 如果无序，就是无序图 搜索图的算法：深度优先搜素和广度优先搜索 二叉树和二叉查找树 树是一种非线性结构，以分层的方式存储数据。 二叉树每个节点的子节点不允许超过两个。 一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为 2 个，可以高效插入，查找，删除。 二叉查找树（BST）是一种特殊得二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高。]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js性能填坑之路]]></title>
    <url>%2Fblog%2F2018%2F04%2F15%2Fstudy-performance%2F</url>
    <content type="text"><![CDATA[简单介绍 javascript 是解释性语言，性能很慢，随着 web 在生活中的普及，这点性能显然不够用。你能想象双十一的一个按钮点半天才有反应嘛？所幸很多大神，都在不断的改进这个性能问题 漫漫填坑路JIT google 在 09 年 v8 引擎里引入 just in time compiling（即时编译），跟之前 ajax 出现引起的轰动是一样的，性能瞬间就上升了 20-40 倍的速度。 从此网页进入了网页应用的时代 解释器和编译器 解释器是一行行解释代码，性能会下降。编译器是把源代码编译成目标代码。 解释器是叫他干什么立刻就去干什么，比如买菜，马上去市场回来，再去买油又马上市场 编译器是叫他干什么直到说完才去干什么，去买菜，买油统一去市场 但是 jit 是基于运行期编译，js 是一个没有类型的语言，所以 jit 大多数时候都在猜测 js 的类型。 123456function add(a, b) &#123; return a + b;&#125;add(1, 2); //这时候jit就把a和b确认为int类型//然后你这样做add("hi", "yoki"); //已经编译成机器码了，但是又变成字符串类型，只能推倒重来，有时候jit的性能提升，还没有这个重编的开销大 TypeScript 既然 jit 大多数时候在猜测类型，那索性搞个强类型语言，再编译成 js 就行了 asm.js ts 是 js 的超集，这个是语法兼容 js 的汇编语言，是 js 的子集 通过标注声明类型，而且不得改变，这样就节省了类型判断的时间 WebAssembly 一种二进制码的规范，是比 asm.js 更为激进的东西 理论上所有语言都可以编译成这个，然后泡在浏览器上 但是目前还摸不了 dom]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈重排和重绘]]></title>
    <url>%2Fblog%2F2018%2F04%2F10%2Frepaint%2F</url>
    <content type="text"><![CDATA[简单介绍 网页生成布局(重排 reflow)，页面绘制（重绘 repaint）一个个盒子元素 重排一定会引起重绘，重绘不一定引起重排 为什么这样说，如果我改变了布局，比如改变边框宽度或者给段落增加文字，浏览器需要重新计算元素的几何属性，就会重排，然后就会重新绘制 但是如果改变元素的背景色，就只会发生重绘，而不会影响布局 重绘和重排非常消耗资源，应该尽量避免 怎样优化批量读或者批量写 现代浏览器已经很智能，会把所有变动排在一起，然后一次性集中在一起，推入到一个队列然后再渲染，这样通过队列话修改然后批量执行可以优化重排过程。 123456789div.stryle.color = "red";div.style.marginTop = "30px";//这里不会是一次次变，而是只会触发一次重排和重绘//但是下面这样，就会触发两次重排和重绘div.style.color = "blue";var margin = parseInt(div.style.marginTop);div.style.marginTop = margin + 10 + "px";//第二行中，我们读取该div的元素位置，这个时候浏览器这个队列马上就要推出去渲染，才可以得知新的布局的位置，所以浏览器必须要重排 由上可知，如果我们在写操作之后，再读会立即渲染，有以下读操作 1234offsetTop / offsetLeft / offsetWidth / offsetHeight;scrollTop / scrollLeft / scrollWidth / scrollHeight;clientTop / clientLeft / clientWidth / clientHeight;getComputedStyle(); 所以我们要懂得批量读和批量写 123456789// baddiv.style.left = div.offsetLeft + 10 + "px";div.style.top = div.offsetTop + 10 + "px";// goodvar left = div.offsetLeft;var top = div.offsetTop;div.style.left = left + 10 + "px";div.style.top = top + 10 + "px"; 合并样式操作 尽管现代浏览器做了优化，但是旧的浏览器可能没有，所以我们应该尽可能合并对样式的修改 cssText：el.style.cssText=’border-left: 1px; border-right: 2px; padding: 5px;’ 修改 className：如果不是那么依赖计算，可以通过修改 className 修改 dom 元素的时候使其脱离文档流 当我们需要对 dom 元素频繁操作的时候，我们可以这样减少重排和重绘 让该 dom 元素脱离文档流（重排） 操作元素 完成后再添加到 document（重排） 如何脱离文档流 隐藏元素：display:none，然后一系列操作后，再显示 推荐：使用 document fragment，就是传说中的文档碎片了，document.createDocumentFragment()，另外的 dom 子树，操作完后，再拷贝回来文档中，div.appendChild（fragment） 将原始元素拷贝到一个脱离文档的节点中，cloneNode,修改这个副本，然后再通过这个元素的父元素的 replaceChild 替换他 1234let old = document.getElementById("mylist");let clone = old.cloneNode(true);appendDataToElement(clone, data);old.parentNode.replaceChild(clone, old); 缓存读过的样式结果 div.style.top 读取可能会重排，这样最好这个缓存到变量里面，下次要用到这个就不用再读 div 的信息了 定位脱离文档流 可以将要多次重排的元素，position 可以设置 abs 和 fixed，这样就脱离文档流，不会影响其他元素。 有动画效果的可以设置为绝对定位 使用 window.requestAnimationFrame()、window.requestIdleCallback() 重新渲染]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的一些问题集合（二）]]></title>
    <url>%2Fblog%2F2018%2F04%2F05%2Fstudy-vue2%2F</url>
    <content type="text"><![CDATA[再写一波 ‘@/components/‘的@ webpack 可以配置 alias 配置别名，这个@一般是 src 目录的别名 npm run dev 报端口已经在运行 可能你在运行其他项目，去修改一下默认端口 父组件怎么调用子组件的方法 this.$refs 里面找到该实例,前提是先设置了 ref this.$children 里面找到该实例 nginx 怎么配置一大波不靠谱的 nginx 配置 v-if 和 v-show v-if 是 dom 没有插入到文档里面，等条件成立，才 append 到 document 里面。 等拿到值才可以处理组件内部的逻辑的，不然会报错 有些 v-for 但是还没有拿到值的 v-show 只是简单通过 css 隐藏了 不会导致页面重绘，改善用户体验 axios 的请求后台不接受 axios 默认是 json 格式提交，如果后台只支持表单序列化，就要自己转义 axios 有个 qs 模块可以试试 css 的 scoped 有什么功能 给每个类或者 id 自动添加 hash，只能给该组件用，不同组件不能进行继承 12345/ 写的时候是这个.a&#123;&#125;// 编译过后,加上了 hash.a[data-v-1ec35ffc]&#123;&#125; 小图片渲染出来 base64 webpack 的 url-loader 处理，对于小于多少 k 一下的图片转成 base64 内联到 html 减少 http 请求降低服务器负担 网络不好的时候，内联的内容先加载，优化体验 ERROR in static/js/xxxxxxx.js from UglifyJs 引入压缩后的 js，webpack 又开启了 uglifyjs 压缩，报错 keep-alive 缓存组件后很慢 因为都是保存在内存里面的，一旦大量组件缓存性能肯定不会好]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的一些问题集合（一）]]></title>
    <url>%2Fblog%2F2018%2F04%2F02%2Fstudy-vue1%2F</url>
    <content type="text"><![CDATA[在公司一直用 vue 开发，有时候被一些小伙伴经常问到的问题，这里收集一下勉强再挖个坑 npm install 安装超时 cnpm:npm i cnpm -g yarn 和 npm 改成淘宝源 12npm config : npm config set registry https://registry.npm.taobao.orgyarn config : yarn config set registry https://registry.npm.taobao.org data functions should return an object这是因为你肯定在书写单组件，而单组件的 data 必须返回一个单例，可以参见data 必须是函数 这里简单解释下，如果一个组件 data 引用的是一个同一个对象指针，那么当你在另外一个组件应用这个组件，v-for 他的时候，比如三个，那么你修改其中一个组件，另外两个这个组件的状态也会改变，但是我们的原则是组件间相互隔离，互不影响。 在函数内写了 this.name（data 里存在 name），却报错 Cannot set property ‘xxx’ of undefined 你期待 this 指向 vue 实例，实际上它指的是 window，this 和当前上下文有关 promise 的回调 setInterval 比较好的解决方案就是使用箭头函数，绑定当前对象为 this 的上下文 Component template shold contain exactly one root element.If you are useing v-if on multiple elements 单组件文件里必须要有个根元素，一个大 div No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 跨域问题 CORS 前后端配置 nginx 反向代理，一般线上使用 本地开发，脚手架 vue-cli 里有 proxyTable 123456789101112// target : 就是 api 的代理的实际路径// changeOrigin: 必须是变源// pathRewrite : 路径重定向proxyTable: &#123; "/api": &#123; target: "http://yoki.com", changeOrigin: true, // pathRewrite: &#123; // "^/api": "/" // &#125; &#125;&#125; 数组里的值手动更新了，为什么视图不更新 this.arr[0]=1,但是视图没更新 这是因为 vue 重写了数组的原生方法，使用了数组方法 push，pop 等，会对其观察，并响应到视图。究其原因是 js 无法检测到到数组的变化 可以使用 this.$set 可以数组的方法更改 为什么根目录下会有 lock 文件 先简单介绍一下 A.B.C：A 是 major 版本表示和上个版本不兼容的大更改，B 是 minor 版本增加了新功能，可以向后兼容，C 是 patch 版本修复了 bug 向后兼容 npm 上包那么多，说不定什么时候就会更新，根据 package.json 里的^(会更新到 major 版本号最新的),~（会更新到 minor 版本最新的） 有些包甚至不遵循发包规范 所以我们需要统一版本号，这样不同的电脑在不同的时间就会下载到一样的包了 npm i -S 和-D 的区别 -S 会放到 dependencies 里面，存放到线上能访问到的代码，比如 vue，vue-router -D 会放到 devDependcies：处于开发模式所依赖的模块，不产生额外代码到生产环境，比如 babel-core 单页应用没办法做 seo 吗 spa 的页面由 javascript 根据 API 发回的数据在用户的浏览器里自动生成的，Baidu 不会看 Javascript，那么页面对于它来说就是一个空洞洞的 html 和很多 scirpt 元素 解决方案：服务端渲染(SSR)可以,请求回来是一个处理好的 html，vue 的服务端渲染方案nuxt 为什么首屏加载这么慢 打包文件文件很大 减少 jq 这种库的引入，现在都是数据驱动 webpack 压缩 js，css 路由懒加载，代码分割 采用服务端渲染，可以避免浏览器去解析模板和指令]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单介绍Typescript]]></title>
    <url>%2Fblog%2F2018%2F03%2F30%2Fstudy-ts%2F</url>
    <content type="text"><![CDATA[简单介绍 以下来自维基百科 TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。C#的首席架构师以及 Delphi 和 Turbo Pascal 的创始人安德斯·海尔斯伯格参与了 TypeScript 的开发。 TypeScript 设计目标是开发大型应用，然后转译成 JavaScript。[7]由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。 为什么需要 ts 普通的 js：假设我一个函数里面只能对字符串进行操作，要是我传了数字，直接就报错了，由此可见 增加了代码的可读性和可维护性 在编译阶段就能发现错误 类型推论 同时与 JavaScript 兼容良好，把.js 改为.ts 就能用 基本使用基础类型12345678910111213//布尔值const isDone = (boolean = false);// 数值const num: number = 6;//字符串const str: string = "yoki";//空值返回function say(): void &#123; console.log("hi");&#125;//null，undefinedconst u: undefined = undefined;const n: null = null; 数组123456//全是数字的数组const numArr: number[] = [1, 2, 3];//数字和字符串都有的数组const tmp: (number | string)[] = [1, "2", 3];//一个可能什么都有类型都有的数组const anyArr: any[] = [1, "1", true]; 函数1234567891011121314151617//传入参数是数字，返回的也是数字function sum(x: number, y: number): number &#123; return x + y;&#125;//可选型，用?,sum2(1)可以，sum（1，2）也可以function sum2(x:number,y?:number):number&#123; return y?:x+y:x&#125;//参数默认值,sum3(1,'5')，y会被自动推导为numberfunction sum3(x?:number,y=0)&#123; return x+y&#125;//剩余参数function concat(arr:any[],...items:any[])&#123; return arr.concat(items)&#125;concat([],1,2,3)=[1,2,3] 接口 在面向对象，接口是一个很重要的概念，他是对行为的抽象，而具体如何行动需要由 class 去实现 ts 的接口是非常灵活的，既可以对类的一部分行为进行抽象，也可以用于对对象的形状进行描述 1234567891011121314//对对象形状的描述interface Person&#123; name:string age?:number, say?:()=&gt;void&#125;const yoki:Person=&#123; name:'yoki', age:18&#125;//只读属性，不可修改interface Person&#123; readonly id:number&#125; 类 public 修饰的属性或者方法都是公有的，可以在任何地方被访问到，默认所有的属性或方法都是 public private 修饰的属性或者方法都是私有的，不能在声明它的类的外部访问 protected 修饰的属性或者方法都是受保护的，它与 pravate 类似，区别是它在子类是允许访问的 1234567891011121314151617181920212223242526272829class Animal&#123; publick name; public constructor(name)&#123; this.name=name &#125;&#125;let a=new Animal('rabbit')a.name//rabbita.name='tom'//tomclass Animal2&#123; private name; public constructor(name)&#123; this.name=name &#125;&#125;let b=new Animal('rabbit')b.name='tom'//报错class Animal3&#123; protected name; public constructor(name)&#123; this.name=name &#125;&#125;class Cat extends Animal&#123; constructor(name)&#123; super(name) console.log(this.name)//可以的 &#125;&#125; 泛型是指在定义函数/接口或者类的时候，不预先指定具体的类型，而在使用的时候再指定类型 1234567891011121314151617181920212223242526272829303132333435363738//T是运行时候的类型function createArray&lt;T&gt;(value: T, len: number): Array&lt;T&gt; &#123; return Array(len).fill(value);&#125;//多个类型function swap&lt;T1,T2&gt;(tuple:[T1,T2]):[T1,T2]「return [tuple[1],tuple[0]]swap([7,'six'])//['six',7]//泛型约束function getlen&lt;T&gt;(a:T):number&#123; return a.length&#125;// length属性不存在type‘T’的里面，errorinterface lengthwise&#123; length:number&#125;function getlen2&lt;T extends lengthwise&gt;(a:T):number&#123; return a.length&#125;getlen2([])//okgetlen2(123)//error//泛型类interface Props&#123;size:'big'|'small'&#125;interface State&#123;visibily:boolean&#125;class App extends React.Component&lt;Props,State&gt;&#123; state=&#123;visibily:true&#125; constructor(props,context)&#123; super(props,context) &#125; handleClick=()=&gt;this.setState(&#123;show:false&#125;) //'error',show不在state接口 render()&#123; return this.state.visibily&amp;&amp; &lt;button&gt; type=&#123;this.props.size&#125; onClick=&#123;this.handleClick&#125; /&gt; &#125;&#125;ReactDom.render(&lt;App size='middle' /&gt;,document.body)// error,middle不在props的size里]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我理解的前端进阶]]></title>
    <url>%2Fblog%2F2018%2F03%2F13%2Ffe-progress%2F</url>
    <content type="text"><![CDATA[简单介绍 前端是一个需要广度的职位，感觉如果多了解上下游各部门的相关技术会对工作有极大的帮助。单从比起技术来，眼界跟逻辑思维其实更重要。 从技术上来说，走出前端那一亩三分地，多接触自己不熟悉的技术。当回头看前端的时候往往会有一种豁然开朗的感觉。 现阶段感觉是要接触不同的技术，换种不一样的思维。因为之前也写过 php（用的是国人 tp 框架），初次接触了 mvc 的思想，后来为学校的公众号也写过后台，用的是 python（Django），然后公司现在用的 java 的 spring 那一套（在疯狂补 java 核心卷 I 中…），后端的路已经很成熟的，前端还在探索属于自己的方式。这样看来是豁然开朗了～ 萌新 -&gt; 页面重构 -&gt; 前端开发工程师 -&gt; 大前端 -&gt; 前端打杂 -&gt; 团队打杂 练级之路可以写出方便维护的代码 commonjs/cmd/amd(node/sea.js/require.js) es6 module(babel) webpack mvvm 解决 jq 意大利面条 使用 async/await，promise 可以写出不容易出错的代码 类型检查，不能相信传进来的参数(当然现在有 ts) try-catch 捕获错误 window.onerror 可以写出性能比较好的代码 大量 dom 操作的时候可以批量读，批量写，会用缓存 会使用递归分而治之，将大问题分解成相似的小问题 可以灵活使用工具 charles/whistle 替换本地文件，模拟数据，代理 host 会用 ps 切图，markman 测量工具 各种带语法提示的小插件 sourcemap 定位代码 知道怎么定位到问题 会有 chrome devtool 里面的 network/performance 等，断点调试 网络不通，ping 一下百度 常见问题跨域 jsonp（get） 服务器代理 安全问题 xss（不能信任用户的输入，过滤一下输入，转义带有脚本的标签） csrf（所有请求都需要带有 token） 性能问题 小文件，快展现 图片资源无损压缩（webp 了解一下） 服务端渲染 预加载 dns 预解析 web workers 进行大计算 知道浏览器的内部工作原理 关注新技术，并能快速化为己用 webaseembly 将 js 转为二进制的规范 小程序 pwa 有感而发于公司内部分享 ppt]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017展望与2018总结]]></title>
    <url>%2Fblog%2F2018%2F02%2F25%2F2018%2F</url>
    <content type="text"><![CDATA[2017 总结 工作上 官网方面：17 年 1 月进入到公司，当时正值官网重构，组长为了锻炼我，便让我参与到了官网的重构当中。 产品方面：官网完成之后，雷达刚好升级 2.0，我去负责其中两个模块的迁移。之后一直负责雷达的开发，维护过立方，聚合，接触了很多公司的产品。 项目方面：期间维护 MIG 系统，并且重构了整个 DBA，能更快地迁移类似的模块。后来参与研发 ipsos 雷达。 学习上 关于 vue：这一年，也算写了大量的 vue 代码，但 vue 封装了大量的 js 代码，屏蔽底层实现细节，所以我很清楚会写 vue 并不算什么，在前端框架日新月异的今天，只有深入地了解并掌握其中原理，才能以不变应万变。 关于可视化方向：由于 echarts 底层封装实在是过于复杂，也没有仔细去研究，只能去应用它的 api，这是我所遗憾的地方。 关于构建工具：先是接触了 gulp，但并不是了解得很清楚。而对于 webpack 这一块，配置得也算还可以，也大概知晓构建工具在前端方面的应用，但是我觉得不要满足于只做一个配置工程师，知道思想最为重要，要知道为什么会有压缩代码，合并请求等操作。 关于读书：喜欢看人物传记，比如爱因斯坦。物理学和哲学上有趣的书也看了不少,极大的开阔了我的眼界。关于 JavaScript 的书，把《你不知道的 JavaScript》也翻了一遍，对于算法（图解算法）也大概翻了一下。 关于印象笔记：只是自己选择的一种记录的工具，因为之前请教别人的时候发现，别人说了一遍方法，但是会很快忘记，所以这时候最好把它记录下来。笔记里记录了今年工作上遇到的问题，方便自己快速复查。 总结 总的来说，这一年，觉得自己是”开眼看世界”的一年，知道自己是热爱前端的，也知道一个好的前端工程师，他首先得是一个工程师，势必要了解算法，http 等基础知识。而纵向学习是提升学习深度的结果，而不是追求学习广度的结果。 2018 展望 工作上 前端系统搭建:yoda 系统搭建。 后端：学习一下 java，希望能接触组内一些后端的项目，简单写些接口。 业务组件库：业务上建立一个属于自己乃至于公司的组件库，因为做产品发现，一个好用的业务组件能提升很多开发效率。 数据分析：由于我们团队比较偏向分析，可以多向分析师取经。眼光应该放宽一点，学习数据方面的分析，才能对公司的产品和项目有更好的感知度。 学习上 MVVM 框架：希望能熟练使用 react 和 angular，最终目标希望能自己造一个小巧的 mvvm 框架，当然造轮子的意义是为了自己学习。 Node 开发：能编写一个 express 或者 koa 的中间件。熟练掌握 CRUD 应用。 构建工具：梳理前端构建工具，把常用的大概研究一遍。 Typescript：学习 typescript，相信强类型一定会在将来被纳入 ECMAScript 的标准。 关于笔记：希望能把每天要做的事，坚持写在 oneNote，养成良好习惯。而工作上要记下来的写在印象笔记。 Java：能熟练进行 web 开发。 关于可视化方向：学习 d3.js 和 three.js。 关于读书：坚持读书，温故知新更为重要。 关于英语：英语实在是太重要了，需要加强学习。 生活习惯 保持精力充沛的前提是要有足够的锻炼，如果每天实在是没有忙到要加班的情况，可以九点走，放好书包后出来跑半小时的步。 坚持八点起床，注意自己的仪容仪表。 总结 多增加了一个维度，同时希望自己能真正对得起工程师这个 title。]]></content>
      <tags>
        <tag>生活随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端错误收集]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2Ffe-error%2F</url>
    <content type="text"><![CDATA[为什么要进行前端的错误进行监控 现在网页的要求已经趋近于原生的应用，几乎都是有着大量交互的。面对各种用户，不同的浏览器等等出现的不同问题，有必要进行及时的监控，毕竟有些问题复现也是挺困难的。 捕获错误的方法 try..catch 之前说过，但是它只能在 try 的块里运行才可以捕捉错误，无法捕捉全局的错误事件 window.onerror 可以用来捕捉全局的错误,但是它无法捕捉异步错误，我们在 ajax 模块统一埋点 window.onerror123456window.onerror=function(message,url,linNo,columnNo,error)message:错误信息url:发生错误对应的脚本路径，比如是bundle.jslineNo:错误发生的行号colunmnNo:错误发生的列号error：具体的error对象，包含更加详细的错误调用堆栈信息 常见问题Script Error 现在我们一般都把资源放在 cdn 上，其他资源在本页面相当于跨域为什么会有这种设置，这是避免数据泄露到不安全的域中。如果我是银行页面，随便引入一个 js 资源，读取了账户密码，那可如何是好。 解决手段添加信任的域 客户端的 script 添加 crossorigin，他的作用就是告诉浏览器，要加载一个其他域的资源，并且信任他 服务端设置Acess-Control-Allow-Origin的响应头，可以直接设置为*，信任全部资源。cdn 资源应该全部加上 CORS 响应头。 如果我们使用 nginx 的话，可以像下面那样简单配置 12345location / &#123; root /Users/**; index index.html index.htm; add_header "Access-Control-Allow-Origin" "*";&#125; 代码压缩 现代 web 工程都会直接压缩 js 代码，所以线上一般都是只有几行代码但是我们有 sourcemap，可以定位到源代码的位置。但是线上是没有这个东西，我们可以通过sourcemap这个工具来将压缩后的代码生成 sourcemap 这里简单介绍一下生成 sourcemap 文件的方式 1uglifyjs --source-map 最终生成的map名称 --output 压缩文件名称 原文件名称 简单通过 soucemap 定位到源文件的真正行数 12345let sourceMap = require("source-map");let mapData = require("./test.json");let consumer = new sourceMap.SourceMapConsumer(mapData);let info = consumer.originalPositionFor(&#123; line: 1, column: 102 &#125;);console.log(info); //&#123; source: "test.js", line: 11, column: 6, name: "yoki" &#125; 推荐工具 由以上可以简单知道前端收集的原理了，但真正到线上肯定是不够的，这里有一些成熟的工具 sentry fundebug 分享一篇干货如何设计一个前端监控系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx简单使用]]></title>
    <url>%2Fblog%2F2018%2F01%2F20%2Fstudy-nginx2%2F</url>
    <content type="text"><![CDATA[前情提要：由于公司也是使用 nignx 解决前后端分离跨域问题，这里简单学习一下 设置简单的代理服务器设置一个代理服务器，它即是一个用来接收请求，并传递它们到代理服务器，取回响应并发送响应给客户端的服务器。 我们将会配置一个简单的代理服务器，它将用本地文件来提供图片请求，而把其他请求转发到代理服务器。这个例子中，这两个服务器都将被定义在一个 nginx 实例中。 首先，在上面配置的基础上再添加一个 server 指令块到 nginx 的配置文件中： 12345678server &#123; listen 8080; root /data/upl; location / &#123; &#125;&#125; 这是一个监听在 8080 端口（location 指令没有指定，默认会使用 80 端口），并且会映射所有请求到本地路径/data/upl 的简单服务器。创建此路径并在里面创建 index.html 文件。注意 root 指令要放在 server 上下文中。这种 root 指令将会在没有自己 root 指令的 location 指令块被选中来处理请求时应用。 下一步，使用上一节的服务器配置，并且修改其为一个代理服务器配置。在第一个 location 指令块，放置 proxy_pass 指令，将代理服务器的地址作为参数（包括代理服务器的协议，域名和端口号）。例子中，它是http://localhost:8080： 123456789server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location /images/ &#123; root /data; &#125;&#125; 第二个 location 指令块目前指定的是/images/前缀到/data/images 路径的映射，为了使其能根据文件后缀匹配相应图片的请求，我们修改之： 123location ~ \.(gif|jpg|png)$ &#123; root /data/images;&#125; 这里参数是一个匹配哪些以.gif，.jpg 或者.png 结尾的 URIs 的正则表达式。正则表达式前面需要放置~。相应的请求将会被影射到/data/images 路径。 当 nginx 选择一个 location 指令块去服务一个请求，它首先检查 location 指令指定的前缀（并记住此最长前缀），然后检查正则表达式。如果有一个正则表达式匹配了，nginx 选中此 location，否则，它将会应用前一个记住的 location。 最后，代理服务器的配置将会是这样： 123456789server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location ~ \.(gif|jpg|png)$ &#123; root /data/images; &#125;&#125; 此服务器将会过滤那些以.gif，.jpg 或.png 结尾的请求，并且影射它们到/data/images 目录。传递其他所有请求到上面配置的代理服务上去。 location = 开头表示精确匹配 ^~ 开头表示 uri 以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配 / 通用匹配, 如果没有其它匹配,任何请求都会匹配到 顺序 no 优先级： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 1234567891011121314151617181920#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理#这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;#第三个规则就是通用规则，用来转发动态请求到后端应用服务器#非静态文件请求就默认是动态请求，自己根据实际把握#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了location / &#123; proxy_pass http://tomcat:8080/&#125;]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx官方文档译文]]></title>
    <url>%2Fblog%2F2018%2F01%2F14%2Fstudy-nginx%2F</url>
    <content type="text"><![CDATA[简介nginx 有一个 master 进程和几个 worker 进程。master 进程的主要作用是读取和操作配置文件，同时维护 worker 进程。而真正处理请求的是 worker 进程。nginx 采用基于事件模型和系统依赖的机制最终将请求分配给 worker 进程。worker 进程的数量被定义在配置文件中，或者有可能被自动调整为 CPU 的核心数。 默认情况下，配置文件命名为 nginx.conf，放在/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx 目录下 启动，停止，reloading 配置运行可执行文件即可开启 nginx。一旦 nginx 开启之后，它可以使用可执行的-s 参数进行控制。下面是其语法： 1nginx -s signal 信号(signal)可以是下面的其中一个： stop —— 快速关闭 quit —— 优雅地关闭 reload —— 重新加载配置文件 reopen —— 重新打开日志文件 比如，等待所有 worker 进程服务完当前请求，然后关闭 nginx 进程： 1nginx -s quit//这条命令，必须由开启nginx的同一个用户执行。 如果改变了配置文件，除非是 nginx 重启，否则可以执行下面的命令进行应用新的配置： 1nginx -s reload 一旦 master 进程收到信号重新加载配置文件，它会检查新的配置文件的语法，并尝试应用配置。如果成功，master 进程开启新的 worker 进程，并且给旧的 worker 进程发送信息，请求它们关闭。否则，master 进程将会回滚修改并继续使用旧配置。 旧的 worker 进程，接受到命令关闭，将会停止接收新的请求，并继续服务完当前请求。自此之后，worker 进程将正式退出。 信号可以通过 unix 工具发送给 nginx 进程，例如 kill 命令。这种情况下，信号会直接发送给指定 pid 的进程。默认情况下，nginx 的 master 进程 ID 被写在/usr/local/nginx/logs 或/var/run 目录下的 nginx.pid 文件中。 比如，假如 master 进程的 ID 是 1628，那么发送 QUIT 信号给 nginx 会导致其优雅地退出： 1kill -s QUIT 1628 获取所有正在运行的 nginx 进程列表信息，可以执行： 1ps -ax | grep nginx 配置文件结构nginx 由模块组成。这些模块都被配置文件中的指令所控制。指令包括简单指令和指令块。一条简单的指令由名字和参数组成，参数由空格隔开，以分号（;）结束。一个指令块的结构和简单指令的一样，但是，它以额外的指令集合结束，指令集用大括弧（{和}）包围。 如果一个指令块里面有其他的指令块，那么它被称为一个上下文（例如，events，http，server 和 location）。 配置文件中，那些位于任何上下文之外的指令都认为是在 main 上下文中。events 和 http 指令位于 main 上下文，server 位于 http 上下文之中，location 位于 server 之中。 一行位于#后面的被认为是注释。 静态内容web 服务器一个重要的任务就是提供静态资源服务（例如图片等）。我们会实现一个例子，这个例子会根据请求，从不同的本地目录提供静态文件：/data/www（包含 html 文件），/data/images（包含图片）。这时候我们需要在 http 指令块里面创建一个 server 指令块，里面又包含两个 location 指令块。 首先，创建/data/www/index.html 文件，并放置一些图片于/data/images 目录下。 打开配置文件，默认的配置文件已经包含几个实例 server 指令块，大部分都被注释了。我们取消注释，并且开始一个新的 server 指令块： 12345http &#123; server &#123; &#125;&#125; 通常来说，配置文件会包含几个 server 指令块，它们由它们监听的端口号和服务器名称来区分。一旦 nginx 决定由哪一个 server 处理一个请求，它会把在请求 header 中的 URI 与在 location 指令块中定义的参数进行测试比较。 向 server 指令块添加 location 指令块： 123location / &#123; root /data/www;&#125; location 指令块指定了 URI”/”前缀。为了匹配请求，URI 将会被添加到 root 指令指定的路径，即是/data/www，实现了从路径到本地文件系统的转变。如果有多个匹配的 location 指令块，那么 nginx 将会选择那个拥有最长匹配前缀的。上面的 location 指令块提供了最短的前缀，所以如果其他所有 location 指令块都匹配失败，此指令块才生效。 下一步，添加第二个 location 指令块： 123location /images/ &#123; root /data;&#125; 它会匹配以/images/开头的请求（虽然 location /也同时匹配此请求，但是却是更短的前缀匹配）。 最后 server 指令块的配置应该是这样的： 123456789server &#123; location / &#123; root /data/www; &#125; location /images/ &#123; root /data; &#125;&#125; 这已经是一个服务器的配置文件了，这个服务器将会在本地机器http://localhost/监听80端口，并且是可访问状态。服务器将从路径/data/images发送文件去响应URIs以/images/开头的请求。比如，客户请求http://localhost/images/example.png，nginx将发送/data/images/example.png文件。如果该文件不存在，nginx将返回包含404 error 的响应。URIs 不是以/images/开头的请求将会被影射到/data/www 路径。例如，请求http://localhost/some/example.html，nginx将会发送/data/www/some/example.html文件。 为了应用新的配置文件，如果 nginx 还没有开启，开启即可；否则可以发送 reload 信号给 nginx 的 master 进程： 1nginx -s reload]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈浏览器渲染]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2Fstudy-render%2F</url>
    <content type="text"><![CDATA[作为一个前端工程师，了解浏览器的渲染过程，可以掌握优化的指导原则。 现在有那么多的优化方案，预编译，预加载，资源合并，按需加载等等都是针对浏览器渲染的优化。 关键渲染路径 关键渲染路径(Critical Rendering Path)是指与当前用户操作有关的内容 比如用户刚刚打开一个页面，首屏的显示就是当前用户操作的内容，具体就是浏览器收到 html/css/js 等资源并对其进行处理从而渲染出页面 了解浏览器渲染的过程与原理，很大程度上是为了优化关键渲染路径 为了保障首屏内容的最快速显示，通常会提到渐进式页面渲染，但是为了渐进式页面渲染，就要做资源的拆分，怎么拆分，这是按场景考虑的 浏览器渲染页面过程 1.dns 查询 2.tcp 连接 3.http 请求即响应 4.服务端响应 5.客户端渲染 客户端渲染 以下步骤不一定一次性顺序完成，如果 dom 或者 cssom 被修改，则以下过程需要重复执行，这样才能计算哪些像素在屏幕上需要重新渲染 1.处理 html 标记并构建 dom 树 2.处理 css 并构建 cssom 树 3.将 dom 树和 cssom 树合并成一个渲染树 4.根据渲染树来布局，以计算每个节点的几何信息 5.将各个节点绘制到屏幕上 阻塞渲染 现代浏览器是并行加载资源的。当 HTML 解析器(html parser)被脚本阻塞的时候，解析器虽然会停止构建 dom，但仍然会识别该脚本后面的资源，并进行预加载。 默认情况下，css 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直到 cssdom 构建完毕 js 不仅可以读取和修改 dom 属性，还可以读取和修改 cssom 属性 存在阻塞的 css 资源的时候，浏览器就会延迟 js 的执行和 dom 构建 当浏览器遇到一个 script 标记的时候，dom 构建将暂停，直到脚本完成执行 cssom 构建的时候，js 执行将暂停，直到 cssdom 就绪 所以 script 标签的位置很重要，实际使用的时候，可以遵循下面两个原则 css 优先：引入顺序上，css 资源先于 js 资源 js 应该尽量少影响 dom 的构建 CSS 渲染树(Render-Tree)的关键渲染路径中，要求同时具有 dom 和 cssom，之后才会构建渲染树。所以 html 和 css 都是被阻塞的资源。html 一定是需要的，那么可以从 css 上想办法。 精简 css 并尽快提供它，例如将多个 css 合并成一个，并进行压缩 JavaScript 实际工程，常常将 js 资源放到文档底部 defer 和 async 可以改变阻塞模式 defer defer 属性表示延迟执行引入的 js，这段 js 加载时候 html 也并未停止解析，这两个过程是并行的 整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。 123&lt;script src="app1.js" defer&gt;&lt;/script&gt;&lt;script src="app2.js" defer&gt;&lt;/script&gt;&lt;script src="app3.js" defer&gt;&lt;/script&gt; defer 不会改变 script 中代码的执行顺序，示例代码会按照 1，2，3 的顺序执行。 async123&lt;script src="app.js" async&gt;&lt;/script&gt;&lt;script src="ad.js" async&gt;&lt;/script&gt;&lt;script src="statistics.js" async&gt;&lt;/script&gt; async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。 多个 async-script 的执行顺序是不确定的。所以 app.js 和 ad.js 和 statistics.js 不一定是顺序执行，谁先加载完谁先执行。]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画了解一下（二）]]></title>
    <url>%2Fblog%2F2017%2F12%2F13%2Ffps%2F</url>
    <content type="text"><![CDATA[fps fps 是 frame per second，一秒能够重新渲染多少个画面 网页的每一帧都是一次重新渲染，一帧（frame）就是一个画面。 我们平时看电视，电视上的画面连续播放，其实一个画面接着一个画面的，如果一秒有 60 个画面播放，我们看着就很流畅了。如果一秒 10 个画面，可能就会感觉像在跳机械舞一样，一顿一顿的 现在大多数显示器的刷新频率都是 60Hz，浏览器一般也会自动按照这个频率，刷新动画。 所以网页动画能够做到每秒 60 帧，就可以和显示器同步刷新，视觉效果达到最佳。 一秒之内进行 60 次渲染，每秒不能超过 16.66 毫秒 如果想要到 60 帧的刷新率，那么 js 线程每个任务的耗时，必须少于 16ms。一个解决办法是用 web worker，主线程只用于 ui 渲染，其他和 ui 渲染不想干的任务，都放在 worker 线程。 调节渲染 有一些 js 方法可以调节重新渲染，大幅度提高网页性能 requestAnimationFrame 他可以将代码放到下次重新渲染执行 1234567891011121314function doubleHeight(element) &#123; var currentHeight = element.clientHeight; element.style.height = currentHeight * 2 + "px";&#125;elements.forEach(doubleHeight);//读了马上又去写，这就会马上重排，导致重新渲染，这就对网页性能很不利//可以使用window.requestAnimation把读写操作分离，把所有写操作放到下一次浏览器正常的重新渲染function doubleHeight(element) &#123; var currentHeight = element.clientHeight; window.requestAnimationFrame(function() &#123; element.style.height = currentHeight * 2 + "px"; &#125;);&#125;elements.forEach(doubleHeight); 适用于页面滚动事件，推迟到下一次重新渲染 适用于网页动画，比如 1234567891011//元素一帧旋转一度var rAF = window.requestAnimationFrame;var degrees = 0;function update() &#123; div.style.transform = "rotate(" + degrees + "deg)"; console.log("updated to degrees " + degrees); degrees = degrees + 1; rAF(update);&#125;rAF(update); requestIdleCallback 只有当一帧的末尾有空闲时间，才会执行回调 requestIdleCallback(fn) 因为一秒 60 帧，一帧就 16.66ms，只有当前帧的运行时间小于 16.66ms 的时候，fn 才会执行。如果当前没有空闲时间，就推迟到下一帧，直到有空闲时间为止。 requestIdleCallback(fn，5000)可以制定第二个参数，表示指定的 ms，表示这段时间内，如果每一帧都没有空间时间，fn 将强制执行 网页性能管理详解]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript装逼指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F03%2Fwrite-nbjs%2F</url>
    <content type="text"><![CDATA[1.javascript 代码错误处理方式 12345try &#123; something;&#125; catch (e) &#123; window.location.href = "http://stackoverflow.com/search?q=[js]+" + e.message;&#125; 2.如何优雅的取随机字符串 123456Math.random() .toString(16) .substring(2);Math.random() .toString(36) .substring(2); 3.如何优雅的取整 12345let a = ~~2.33; //2let b = 2.33 | 0; //2let c = 2.33 &gt;&gt; 0; //2 4.金钱数字取千分位的非正则优雅实现 12345678910111213//用reducefunction formatCash(str) &#123; return str .split("") .reverse() .reduce((prev, next, index) =&gt; &#123; return (index % 3 ? next : next + ",") + prev; &#125;);&#125;console.log(formatCash("1234567890")); // 1,234,567,890//toLocaleString(23333333).toLocaleString("en-US");("23,333,333"); 5.最短代码实现数组去重 12[...new Set([1, "1", 2, 1, 1, 3])];//[1,'1',2,3] 6.最短代码实现一个长度为 m(6)且值都为 n（8）的数组 12Array(6).fill(8);//[8,8,8,8,8,8] 7.短路表达式 123456789101112131415var a = b &amp;&amp; 1;// 相当于if (b) &#123; a = 1;&#125; else &#123; a = b;&#125;var a = b || 1;// 相当于if (b) &#123; a = b;&#125; else &#123; a = 1;&#125; 8.颜色 rgb 和 hex 的相互转换 123456789101112131415function rgbToHex(r, g, b) &#123; return "#" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);&#125;function hexToRgb(hex) &#123; var result = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex); return result ? &#123; r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) &#125; : null;&#125;alert(hexToRgb("#0033ff").g); // "51";]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识vps]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2Fstudy-vps%2F</url>
    <content type="text"><![CDATA[vps 是什么 以下来自维基百科 虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是将一台服务器分区成多个虚拟专享服务器的服务。 实现 VPS 的技术分为容器技术和虚拟机技术 。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。 VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。 vps 能做什么 可以进行科学上网，参见搭建 ss 服务器 vps 可以配置一个 ip 或者多个 ip。既然有了 ip 那么干的事情就多了。 同时想了解一下 linux 服务器或者部署自己的小作品，这个时候一个配置较低的 vps 就可以发挥作用了。比如托管静态页面，爬虫，起 node 服务等等。 一些 vps 推荐 vultr(我就是用这个的) 搬瓦工 hostmybytes linode]]></content>
  </entry>
  <entry>
    <title><![CDATA[动画了解一下(一)]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2Fstudy-animate%2F</url>
    <content type="text"><![CDATA[笼统的过一下动画的一些基本概念 基本概念 帧：在动画过程中，每一幅静止画面即为一“帧” 帧率：即每秒播放的静止画面的数量，单位是 fps(frame per second)或赫兹(Hz) 帧时长：即每一幅静止画面的停留时间，单位一般是毫秒 丢帧：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续帧被挤压而丢失的现象 我们在显示器上看到的动画，每一帧变化都是系统绘制出来的（GPU 或者 CPU）。它的最高绘制频率受限于显示器的刷新频率（而非显卡，大多数都是 60Hz 或者 75Hz） 帧率越高，屏幕上图片闪烁感就越小，稳定性也就越高。人的眼睛不容易察觉 75Hz 以上刷新频率带来的闪烁感。 实现方式 js：通过定时器（setTimeout 和 setInterval）来改变元素样式，或者使用 requestAnimationFrame css3:transition 和 animation html5:使用 html5 提供的绘图方式(canvas/svg/webgl) requestAnimationFrame 这个 api 是浏览器用于定时循环操作的一个接口，类似于 setTimeout,主要用途是按帧对网页进行重绘 目的是为了让各种网页动画效果（dom 动画，canvas 动画，svg 动画，webgl 动画）能够有一个统一的刷新机制，从而节省系统资源，提供系统性能，改善视觉效果。 代码中使用这个 api，就是告诉浏览器希望执行一个动画，让浏览器在动画帧安排一次重绘。 其接受一个回调作为参数，这个回调函数会在浏览器重绘之前调用，由于功效只是一次性的，所以想实现连续的动效，需要递归调用。 12345678910111213&lt;div id="demo" style="position:absolute; width:100px; height:100px; background:#ccc; left:0; top:0;"&gt;&lt;/div&gt;&lt;script&gt;var demo = document.getElementById('demo');function render()&#123; demo.style.left = parseInt(demo.style.left) + 1 + 'px'; //每一帧向右移动1px&#125;requestAnimationFrame(function()&#123; render(); //当超过300px后才停止 if(parseInt(demo.style.left) &lt;= 300) requestAnimationFrame(arguments.callee);&#125;);&lt;/script&gt; cancelAnimationFrame 用于取消重绘 12var requestID = requestAnimationFrame(repeatOften);cancelAnimationFrame(requestID); 使用 requestAnimationFrame 的优势如下 会把每一帧中的所有 dom 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随着显示器的刷新频率（60 或者 75Hz） 在隐藏或不可见的元素中，将不会进行重绘或回流，这就意味着更少的 cpu，gpu 和内存使用量 所以它是性能优化版/专为动画量身打造的 setTimeout，不同的是它不是自己指定回调函数运行的时间，而是跟着浏览器内建的刷新频率来执行回调，这就能达到浏览器所能实现动画的最佳效果 transition css 中的 transition 属性允许块级元素中的属性在指定的时间内平滑的改变 1transition:property duration timing-function delay property 是过渡效果的 css 属性的名称，比如 height duration 规定完成过渡效果需要多少毫秒或者秒 timing-function 规定速度效果的曲线(linear/ease..) delay 规定过渡效果何时开始 animation 跟 transition 比较，作用于元素本身而不是样式属性,可以使用关键帧的概念，应该说可以实现更自由的动画效果 1animation:name duration timing-function delay iteration-count direction name 是需要绑定到选择器的 keyframe 名称 duration 规定完成动画所花费的时间，以秒或者毫秒算 timing-function 是动画的速度曲线(line/ease..) delay 规定在动画开始之前的延迟 iteration-count 规定动画应该播放的次数 animation-direction 规定是否应该轮流反向播放动画(normal/alternate) Canvas html5 新增的元素，作为页面图形绘制的容器，可用于使用 js 中的脚本来绘制图形。 它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或者渲染 它具有如下特点 依赖分辨率，基于位图 不支持事件处理器 弱的文本渲染能力 能够以.pbg 或者.jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG scalable vector graphics==可缩放矢量图形，用来定义用于网络的基于矢量的图形，使用 xml 格式定义图像 它具有如下特点 不依赖分辨率，基于矢量图 支持事件处理器 最适合带有大型渲染区域的应用程序，如谷歌地图 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快） 不适合游戏应用 svg 示例 1234567891011&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;rect x="50" y="20" rx="20" ry="20" width="150" height="150" style="fill:red;stroke:black;stroke-width:5;opacity:0.5" /&gt;&lt;/svg&gt; svg 代码以 svg 根元素开始。 width 和 height 设定 svg 文档的高度和宽度 version 指定所使用的 svg 版本 xmlns 定义 svg 命名空间 webgl webgl 使得网页在支持 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 api 在 canvas 中进行 3D 渲染。 webgl 由 js 控制代码，和在计算机的图形处理单元（GPU）中执行的特效代码(shader code,渲染代码)组成 常用的动画库 Ani.js–基于 css 动画的生命处理库 Dynamics.js–创建具有物理运动效果动画的 js 库 Animate.css–齐全的 css3 动画库 Three.js–快速搭建 webgl 项目]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2Fblog%2F2017%2F11%2F09%2Fstudy-processAndthread%2F</url>
    <content type="text"><![CDATA[进程(process)和线程（thread） 进程和线程独立运行，并可能同时运行，多个线程能够共享单个进程的内存。 进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，换句话说进程是可以独立运行的一段程序。 线程是进程得一个实体，是 CPU 调度和分派的基本单位，他是比进程更小的独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈。 他们之间的关系是 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（就是通常说的主线程） 资源分配给进程，同一进程的所有线程共享该进程的所有资源 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的方法实现同步。 处理机分给线程，即真正在处理机上运行得是线程 线程是指进程内的一个执行单元，也是进程内的可调度实体 他们之间的区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但也可以访问隶属于进程的资源。 生动形象 书面上，进程和线程基本是一个东西，只是进程可以包含若干个线程。此外就是在操作系统中的层级上，也就是粒度不同外，没有其他大的区别。在一般使用中，需要就多开几个线程。 形象的说，进程就是一个项目组，每个程序员就是里面的线程，当然一个程序员也可以是一个项目组，对应的一个进程只有一个线程，而且还是主线程。公司里面的任务是分配给项目组级别的，也就是说系统资源是分配给进程的，但是干活的是程序员（线程）。]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂乱无章]]></title>
    <url>%2Fblog%2F2017%2F09%2F24%2Fthink%2F</url>
    <content type="text"><![CDATA[最近有点忙，忙得几乎都不像是一个才毕业了两个月的人。生活也足够简单，两点一线，下班后最大的愿望便是去书店看（zhuang）书（bi），偷得浮生半日闲。 在九月过半的时候，我突然发觉应有点仪式感——纪念一下曾经是学生的日子，于是总想写些什么。在学校的日子已算是一去不复返了，他们开学的时候，我总是觉得自己失去了些什么，那种感觉无以言状。 出来工作的时候，确实会觉得上学的时光是美好的，这种生活的内核是多彩，不重复。也许这是钱老说的那样，城里的人想出去，城外的人想进来。小时候总是想快些长大，想快点去各种自己喜欢的事情，那些盼呀盼呀总觉得盼不到的日子，现在突然就来临了。那些小时候喜欢的事，反倒是换了一份新鲜感。人呀，越是要自由，就越要担起更多的责任。而我们开始慢慢长大，获得了从前不曾有的自由，不论是经济上还是情感上，但是同时也有了更多的责任。 有时候会觉得这些日子乏味，枯燥，我渐渐地就开始看起了以前那些没看完的书。学会了以宽容的心态去面对生活，可能也是时光宽容了我。有时候，在早晨公交车如此多人的时候，每个人的心情都十分烦躁，鸟儿的声音也是聒噪多余的，但我总是会看到我们这一路司机在特别人多下车的地方，都会大声提醒外面有车开过来，下车注意些。每当看到这些画面，心里就会特别感激，对于生活，感觉才真正有了那种烟火气息。 看到很多人工作之后发的朋友圈，千篇一律的累，单调，全然没有了上学时候的激情。我曾经也迷茫，但是周遭厉害的人都很多，容不得我没有激情。当在这二十几岁的年纪里，还有很多我们不曾到达的领域，褪掉了激情，再无可能去攀登——最近在《人性的弱点》里体会到，也算是满满的鸡汤文，但是与卡耐基对话，就有种想要变得更好的冲动。 不管如何，失败一些，成功一些，本就是一件很好的事。也庆幸在大学里谈过恋爱，懂得了如何去珍惜，分开的时候会对感情这件事极其失望，当然现在是以感恩面对这些，过往不究。有时候夜深了在黄埔大道上面走着，灯影明灭，总是会看见一两对小情侣在打闹，或是依偎，我会觉得特别有生气，也会想起大学时候谈恋爱的时光。现在一个人了，虽无拘束，但心情总有波澜。 思绪很杂，文字也随之杂乱无章。]]></content>
      <tags>
        <tag>生活随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数]]></title>
    <url>%2Fblog%2F2017%2F05%2F23%2Fuse-generator%2F</url>
    <content type="text"><![CDATA[Generator 函数 generator 是生成器。generator 可以看成是一个取号机，你拿一张票去向机器请求一个号码，你接受了你的号码之后，机器不会自动为你提供下一个。换句话说，取票机“暂停”直到另外一个人来请求另一个号码，此时它才会向后进行。 generator 函数的创建 ES6 中用function*来创建生成器函数 当想要 generator 产生一个值之后暂停执行，需要使用到yield（生成）关键字，有点类似于 return 关键字（都可以返回一个值），只是 yield 返回值之后 generator 函数会暂停运行 123456function* ticketGenerate() &#123; //创建一个取号机 yield 1; yield 2; yield 3;&#125; yield*是委派至另一个生成器函数 12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i) &#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 generator 函数的使用 ticketGenerate()不会马上执行它的主体，而是会返回一个这个生成器函数的迭代器对象 当这个迭代器对象的 next 方法被调用时候，生成器函数的主体会执行到第一个 yield 表达式，该表达式定义了迭代器对象返回的值。 next()返回一个对象：{value:1,done:false}，value 属性是产出的值，done 属性是表示生成器是否已经产出了它最后的值。 12const ticket = ticketGenerate(); //返回一个生成器对象ticket.next(); //&#123;value: 1, done: false&#125; 影响 generator 的状态 next()的另一个妙用是可以给它传递值，它会被视为 generator 中的 yield 语句的结果对待。 因此 next 是在 generator 运行过程中向其传递信息的方式。我们可以借此来重置取号机，将号码变为 0。 1234567891011121314function* ticketGenerator() &#123; for (var i = 0; true; i++) &#123; var reset = yield i; if (reset) &#123; i = -1; &#125; &#125;&#125;var takeANumber = ticketGenerator();console.log(takeANumber.next().value); //0console.log(takeANumber.next().value); //1console.log(takeANumber.next().value); //2console.log(takeANumber.next(true).value); //0console.log(takeANumber.next().value); //1]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js里的异常]]></title>
    <url>%2Fblog%2F2017%2F05%2F18%2Fuse-CatchException%2F</url>
    <content type="text"><![CDATA[throw 用来抛出一个异常，throw expression throw 12 //抛出数值 12 的异常 throw ‘err’ //抛出字符串’err’的异常 throw {name:’异常的名字’,message:’异常的信息’,stack:’一般还有个函数栈’} //抛出对象的异常，一般这个对象包含名字，信息，栈。可以试一下 throw new Error(‘123’) 也可以创建自定义错误 12345function UserException(message) &#123; this.name = "UserException"; this.message = message;&#125;throw new UserException("用户消息错误"); try..catch 大法 配合 throw 能找出自己程序的异常 123456789101112function printValue(value) &#123; if (value == 1) &#123; throw new Error("值是1错误"); &#125; else &#123; console.log(value); &#125;&#125;try &#123; printValue(1);&#125; catch (e) &#123; console.log(e.message, e.name, e.stack);&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用promise]]></title>
    <url>%2Fblog%2F2017%2F05%2F17%2Fuse-promise%2F</url>
    <content type="text"><![CDATA[Promise Promise 作为 ES6 的特性，可以很好地创建异步工作流 Promise 是构造函数 Promise 只有三种状态（pending，resolve，reject），pending 是刚创建 Promise 实例的状态，然后一旦转为 resolve 或者 reject，就不可变更 创建 Promise 以封装 xhr 为例子 123456789101112131415161718function getURL(url) &#123; return new Promise((resolve, reject) =&gt; &#123; //Promise构造函数接受一个函数，这个函数接受两个参数 let xhr = new XMLHttpRequest(); xhr.open("GET", url, true); xhr.onload = function() &#123; if (xhr.status == 200) &#123; resolve(JSON.parse(xhr.responseText)); //如果成功响应，那么把这个值填充到resolve &#125; else &#123; reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面 &#125; &#125;; xhr.onError = function() &#123; reject(new Error(xhr.statusText)); //把该错误对象填充到reject里面 &#125;; xhr.send(null); &#125;);&#125; reject 必须是接受一个错误对象实例，比如new Error(&#39;12&#39;)里面是什么类型的都可以 使用 Promise 使用上面封装 xhr 的 getURL 的函数，该函数返回一个 Promise 实例 Promise 的实例方法有两个：then 和 catch，这个两个方法都返回新的 Promise 对象 then 有两个参数。then(onfilled,onrejected)，第一个是参数值 resolve 来填充，第二个是 reject 来填充 catch 实则是 then(undefined,onrejected)的别名，但是一般情况下都是用这个 then 检测不了自身 Promise 对象 onfilled 出了异常，而 catch 是基于对上次的 then 产生的 promise 对象 123456789let url1 = "http://azu.github.io/promises-book/json/comment.json", url2 = "http://azu.github.io/promises-book/json/people.json";getURL(url1) .then(val =&gt; &#123; console.log(val); //这里是onfilled填充 &#125;) .catch(error =&gt; &#123; console.log(error); //这里是onrejected填充 &#125;); Promise chain 获取上次 promise 的返回值 由于 Promise 链式调用的时候，每个 Promise 都是独立的。但是可以通过 return 值来传给下一个 Promise，因为 return 了值是填充了当前 Promise 对象的 resolve 1234567promise .then(val =&gt; &#123; return val; &#125;) .then(val =&gt; &#123; console.log(val); &#125;); Promise 静态方法 Promise.resolve(42) === new Promise((resolve,reject)=&gt;resolve(42)) ,是它的语法糖 Promise.reject(new Error(42)) === new Promise((resolve,reject)=&gt;reject(new Error(42))) 是它的语法糖 如果有多个 Promise 同时需要判断才能进行下一步，可以用 Promise.all([promise1,promise2])。这个 then 方法返回的参数也是一个数组，跟 promise1 和 promise2 的顺序一样。需要注意的是，all 是并行执行的。 Promise.race([promise1,promise2]) 则和数组的 some 方法很像，只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。 123456promise.all([getURL(url1), getURL(url2)]).then(function(result) &#123; console.log(result); //[getURL(url1)的结果，getURL(url2)的结果]&#125;);promise.race([getURL(url1), getURL(url2)]).then(function(value) &#123; console.log(value); //一旦这两个promise对象有一个完成了onfilled或onrejected状态，那么就会进行后续的then，所以这里then的参数只有一个value。但不并不会影响其他promise对象的进行，只是它们的结果值不会出现在then的里面&#125;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板字符串的替换]]></title>
    <url>%2Fblog%2F2017%2F05%2F11%2Fstudy-replace-template%2F</url>
    <content type="text"><![CDATA[简单介绍 看到 vue 模板里都是用包含变量，然后替换成变量，觉得比字符串拼接实在是好太多了 es6 的字符串模板用起来实在是舒服，所以简单用实现一下 1234// 首先 str.replace(regexp|substr, newSubStr|function) ，replace 可以传递一个函数str.replace(reg,function(match,key)=&gt;&#123;&#125;)//正则匹配&#123;&#123;内容&#125;&#125;，应该是/\&#123;\&#123;(.*?)\&#125;\&#125;/，用\转义&#123;和&#125;// /\&#123;\&#123;(.*?)\&#125;\&#125;/g; 正则表达 .*?是正则的固定搭配用法，就是表示非贪婪模式，尽可能匹配少的意思 .*则表示贪婪模式 123456789源字符串：aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc正则表达式一：&lt;div&gt;.*&lt;/div&gt;匹配结果一：&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;(从头部匹配到尾部，从第一个div到最后的那个&lt;/div&gt;)正则表达式二：&lt;div&gt;.*?&lt;/div&gt;匹配结果二：&lt;div&gt;test1&lt;/div&gt;（这里指的是一次匹配结果，不使用\/g，所以没包括&lt;div&gt;test2&lt;/div&gt;） 简单实现 所以有上面的简单铺垫，可以简单写出 12345678910function render(template, context) &#123; return template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g, (match, key) =&gt; &#123; console.log(match, key); //match是&#123;&#123;name &#125;&#125;，key是name return context[key.trim()]; &#125;);&#125;//可以使用trim去掉前后空格const template = "我是&#123;&#123;name &#125;&#125;，现在&#123;&#123;age &#125;&#125;岁";const context = &#123; name: "yoki", age: "20" &#125;;console.log(render(template, context));]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和防抖]]></title>
    <url>%2Fblog%2F2017%2F04%2F10%2FthrottleAndDebounce%2F</url>
    <content type="text"><![CDATA[节流（throttle） 函数节流是指一定时间内只跑一次函数，就像是技能 cd，你再怎么按它一段时间内只能触发一次。 主要思想就是设置一个守卫（flag），如果 setTimeout 已经执行过了就不会创建新的 setTimeout 123456789101112131415let scrollFun = function(time) &#123; let canRun = true; //初始化守卫变量 return function() &#123; if (canRun) &#123; canRun = false; setTimeout(() =&gt; &#123; console.log("throttle"); //3s后变量才为true，才可以继续执行if条件 canRun = true; &#125;, time); &#125; &#125;;&#125;;//3s执行一次window.scroll = scrollFun(3000); 适用于窗口 resize 防抖(debounce) 函数防抖呢，就是频繁触发后，一旦空闲下来才开始执行这个函数。就像公交车司机，如果有人陆续刷卡，司机一直停车等待，直到所有人上来了才回开车。 主要思想就是如果频繁触发，就取消上一个，重新创建一个规定时长的 setTimeout 123456789101112let debounce = function(time) &#123; let setTimeId = null; return function() &#123; //取消上一个的 clearTimeout(setTimeId); setTimeId = setTimeout(() =&gt; &#123; console.log("debounce"); &#125;, time); &#125;;&#125;;//直到没有输入后，3s后才执行$(el).input(dubounce(3000)); 适用于输入框输入持续监听等]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nvm]]></title>
    <url>%2Fblog%2F2017%2F03%2F10%2Fuse-nvm%2F</url>
    <content type="text"><![CDATA[Node Version Manager（node版本管理）使用nvm安装和管理node node版本更新很快，为了能在版本之间迅速切换，我们要使用nvm来安装和管理。用nvm下载了相应的node也会下载相应的npm进行管理 安装nvm我们可以从Github下载 默认安装路径是C:\Users\Administrator\AppData\Roaming\nvm，存放我们下载的各个版本的node 验证安装，打开控制台，输入nvm,看是否输出所有命令 命令 nvm list #查看本地所有node版本 nvm install 4.2.2 #安装 4.2.2 版本 nvm use 4.2.2 #切换至 4.2.2 版本 nvm uninstall 4.2.2 #卸载4.2.2 版本 镜像 nvm默认的下载地址是http://nodejs.org/dist/,这是国外的服务器，在国内下载速度很慢。 需要把下列代码复制到你nvm的安装路径下的setting.txt12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中常用git命令]]></title>
    <url>%2Fblog%2F2017%2F02%2F13%2Fstudy-git%2F</url>
    <content type="text"><![CDATA[基础命令 git clone 克隆仓库 git checkout 切换分支 git add 添加文件 git commit 提交改动 git push 推送本地分支到远端 git merge 把某个分支的代码合并到当前分支 git pull = git fetch + git merge 把远端分支更新到本地 git status 当前分支状态 我一般习惯配置别名 alias，比如 merge 变成 mg，这样少打几个字母 常用命令组合1.丢掉本地未提交改动 git checkout -f 2.丢掉本地已提交但未推送到远端的提交 git reset –hard origin/xxx 测试和发布 内部使用 gitlab master 主分支：用于外网线上发布，永远保持跟线上一致 develop 分支：用于发布测试环境 日常开发说明 详情参见git flow 日常开发从 master 拉一个分支 feature-xxx 分支到本地 要发布测试环境，直接 mg 到 develop，然后发布 要发布线上，直接 mg 到 master，然后发布 日常紧急 bug 修复，可拉一个 hotfix 分支]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[add(1)(2)(3)解题思路]]></title>
    <url>%2Fblog%2F2017%2F02%2F08%2Fadd%2F</url>
    <content type="text"><![CDATA[投机解法 当时第一眼看到这个题目的时候，第一反应就是函数里返回一个新的函数 一个不灵活的解决方案,不具备拓展性 12345678function add(a) &#123; return function(b) &#123; return function(c) &#123; return a + b + c; &#125;; &#125;;&#125;add(1)(2)(3)=6 正确解法 函数最终的和要保存一个闭包当中 123456789101112131415function add(a) &#123; //sum保存于闭包之中 let sum = a; let tmp = function(b) &#123; sum = +b; //返回自己方便日后调用 return tmp; &#125;; //如果到这里什么都不写，那么console.log(add(1)(2)(3))是add这个函数的定义 //console.log有些情况下会调用toString和valueOf方法，所以我们重写这个方法 tmp.valueOf = tmp.toString = function() &#123; return sum; &#125;; return tmp;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017%2F01%2F15%2FhelloWorld%2F</url>
    <content type="text"><![CDATA[在程序的世界里，开始的话就循例来一个 hello world 一级标题 在文字前面加上#表示标题 标题一共有六级（6 个#号）在#后面加上空格，才是标准的 md 语法 列表 在文字前面加上- 列表 1 列表 2 引用 在文字前面加上&gt; 图片与链接 插入链接与图片的语法的区别在于一个!号; 12&gt; 图片为：![](relative address);&gt; 链接为：[](); 粗体 两个**包含一段文本就是粗体 粗体 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 用三个` 把中间的代码包裹,在第一段点之后加语言名可以显示代码高亮 1console.log(12); 分割线 分割线的语法为三个-]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
